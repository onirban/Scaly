class SourceVisitor extends CppVisitor {

    mutable sourceFile: VarString
    mutable projectFile: VarString

    // Some rudimentary semantics cache
    mutable inherits: Inherits[]
    mutable classes: string[]

    constructor() {

        // null constructor of mutable members does not work yet
        moduleName = new string()
        sourceFile = new VarString()
        projectFile = new VarString()
        inherits = new Inherits[]()
        classes = new string[]()
    }

    function openProgram(program: Program): bool {
        mutable programDirectory: string$ = new string(program.directory)

        if programDirectory == null || programDirectory.equals("") {
            programDirectory = new string(".")
        }

        {
            mutable outputFilePath: VarString$ = new VarString(programDirectory)
            outputFilePath.append("/")
            outputFilePath.append(program.name)

            // Build and write the project file
            {
                buildProjectFileString(program)
                {
                    mutable projectFilePath: VarString$  = new VarString(outputFilePath)
                    projectFilePath.append(".project")
                    File.writeFromString(projectFilePath , projectFile)
                        catch _ (error: fileError)
                            return(false)
                }
            }

            collectInheritances(program)
        }

        true
    }

    function openCompilationUnit(compilationUnit: CompilationUnit): bool {

        moduleName = compilationUnit.fileName

        if !(compilationUnit.parent is Program)
            return(false)

        let programName: string = ((compilationUnit.parent) as Program).name

        // Begin cpp file
        sourceFile = new VarString(0, 4096)
        sourceFile.append("#include \"")
        sourceFile.append(programName)
        sourceFile.append(".h\"\nusing namespace scaly;\n")
        
        if isTopLevelFile(compilationUnit) {
            sourceFile.append("namespace scaly {\n\n")
            sourceFile.append("extern __thread _Page* __CurrentPage;\n")
            sourceFile.append("extern __thread _Task* __CurrentTask;\n\n")
            sourceFile.append("}\n\n")
            sourceFile.append("int main(int argc, char** argv) {\n")
            sourceFile.append("    // Allocate the root page for the main thread\n")
            sourceFile.append("    _Page* page = 0;\n")
            sourceFile.append("    posix_memalign((void**)&page, _pageSize, _pageSize * _maxStackPages);\n")
            sourceFile.append("    if (!page)\n")
            sourceFile.append("        return -1;\n")
            sourceFile.append("    new (page) _Page();\n")
            sourceFile.append("    __CurrentPage = page;\n\n")
            sourceFile.append("    _Task* task = new(page) _Task();\n")
            sourceFile.append("    __CurrentTask = task;\n\n")
            sourceFile.append("    // Collect the arguments into a string Vector\n")
            sourceFile.append("    _Array<string>* arguments = new(__CurrentPage) _Array<string>(argc - 1);\n")
            sourceFile.append("    for (int i = 1; i < argc; i++)\n")
            sourceFile.append("        arguments->push(new(__CurrentPage) string(argv[i]));\n\n")
            sourceFile.append("    // Call Scaly's top-level code\n")
            sourceFile.append("    auto _File_error = ")
            sourceFile.append(programName)
            sourceFile.append("::_main(page, arguments);\n    int ret = 0;\n\n    // Convert Scaly's error enum back to OS errno values\n")
            sourceFile.append("    if (_File_error) {\n        switch(_File_error->_getErrorCode()) {\n")
            sourceFile.append("            case _FileErrorCode_noSuchFileOrDirectory:\n                ret = ENOENT;\n")
            sourceFile.append("                break;\n            default:\n                ret = -1;\n                break;\n        }\n    }\n\n")
            sourceFile.append("    // Only for monitoring, debugging and stuff\n")
            sourceFile.append("    __CurrentTask->dispose();\n\n")
            sourceFile.append("    // Give back the return code of the top-level code\n")
            sourceFile.append("    return ret;\n")
            sourceFile.append("}\n\n")
        }
        
        sourceFile.append("namespace ")
        sourceFile.append(programName)
        sourceFile.append(" {\n\n")
        
        if isTopLevelFile(compilationUnit)
            sourceFile.append("FileError* _main(_Page* _ep,  _Array<string>* arguments) {\n    _Region _rp; _Page* _p = _rp.get();\n\n")

        true
    }

    function closeCompilationUnit(compilationUnit: CompilationUnit) {
        if !(compilationUnit.parent) is Program
            return

        let programDirectory: string = ((compilationUnit.parent) as Program).directory

        // Close and write cpp file

        mutable outputFilePath: VarString$  = new VarString(programDirectory)
        outputFilePath.append('/')
        let fileNameWithoutExtension: string$ = Path.getFileNameWithoutExtension(compilationUnit.fileName)
        outputFilePath.append(fileNameWithoutExtension)

        if isTopLevelFile(compilationUnit)
        {
            // Insert the return 0 if the last statement is not a return or a literal
            let statements: Statement[] = compilationUnit.statements
            if statements.length() > 0 {
                let statement: Statement = statements[statements.length() - 1]
                if statement is SimpleExpression {
                    let simpleExpression: SimpleExpression = statement as SimpleExpression
                    let primaryExpression: PrimaryExpression = simpleExpression.prefixExpression.expression.primaryExpression
                    if (!(primaryExpression is ReturnExpression)) && (!(primaryExpression is LiteralExpression))
                        sourceFile.append("\n    return nullptr;\n")
                }
            }

            sourceFile.append("\n}\n")
        }

        sourceFile.append("\n}\n")

        mutable sourceFilePath: VarString$ = new VarString(outputFilePath)
        sourceFilePath.append(".cpp")
        File.writeFromString(sourceFilePath, sourceFile)
            catch _ (error: fileError)
                return
    }
    
    function isTopLevelFile(compilationUnit: CompilationUnit): bool {
        let statements: Statement[] = compilationUnit.statements
        for statement: Statement in statements {
            if statement is Expression
                return(true)
        }
            
        false
    }

    function openConstantDeclaration(constantDeclaration: ConstantDeclaration): bool {

        if constantDeclaration.parent.parent.parent == null
            return(true)

        if constantDeclaration.parent.parent.parent is ClassDeclaration
            return(false)
            
        true
    }

    function openVariableDeclaration(variableDeclaration: VariableDeclaration): bool {

        if variableDeclaration.parent.parent.parent is ClassDeclaration
            return(false)

        true
    }

    function openMutableDeclaration(mutableDeclaration: MutableDeclaration): bool {

        if mutableDeclaration.parent.parent.parent is ClassDeclaration
            return(false)

        true
    }

    function openFunctionDeclaration(functionDeclaration: FunctionDeclaration): bool {

        if functionDeclaration.body == null
            return(false)

        true
    }

    function openEnumDeclaration(enumDeclaration: EnumDeclaration): bool {
        let enumDeclarationName: string = enumDeclaration.name

        sourceFile.append("long ")
        sourceFile.append(enumDeclarationName)
        sourceFile.append("::_getErrorCode() {\n    return (long)errorCode;\n}\n\nvoid* ")
        sourceFile.append(enumDeclarationName)
        sourceFile.append("::_getErrorInfo() {\n    return errorInfo;\n}\n\n")

        true
    }

    function closeClassDeclaration(classDeclaration: ClassDeclaration) {
        if classDeclaration.body == null
            return
        
        if classDeclaration.typeInheritanceClause != null {
            sourceFile.append("bool ")
            sourceFile.append(classDeclaration.name)
            sourceFile.append("::_is")
            sourceFile.append(classDeclaration.name)
            sourceFile.append("() { return (true); }\n\n")
        }
        {
            mutable derivedClasses: string[]$ = new string[]()
            collectDerivedClasses(derivedClasses, new string(classDeclaration.name))
            for derivedClass: string in derivedClasses {
                sourceFile.append("bool ")
                sourceFile.append(classDeclaration.name)
                sourceFile.append("::_is")
                sourceFile.append(derivedClass)
                sourceFile.append("() { return (false); }\n")
            }
            if derivedClasses.length() > 0
                sourceFile.append("\n")
        }
    }

    function openConstructorDeclaration(constructorDeclaration: ConstructorDeclaration): bool {

        if !constructorDeclaration.parent.parent.parent is ClassDeclaration
            return(false)

        let classDeclarationName: string = ((constructorDeclaration.parent.parent.parent) as Program).name
        
        sourceFile.append(classDeclarationName)
        sourceFile.append("::")
        sourceFile.append(classDeclarationName)
        sourceFile.append("(")
        
        true
    }

    function closeConstructorDeclaration(constructorDeclaration: ConstructorDeclaration) {
        sourceFile.append("\n")
    }

    function openCodeBlock(codeBlock: CodeBlock): bool {

        if codeBlock.parent is CodeBlock
            indent(level(codeBlock) - 1)

        if codeBlock.parent is CaseContent
            indent(level(codeBlock) - 1)
            
        sourceFile.append("{\n")

        if localAllocations(codeBlock) {
            indent(level(codeBlock))
            sourceFile.append("_Region _region; _Page* _p = _region.get();\n")
        }

        true
    }

    function localAllocations(codeBlock: CodeBlock): bool {
        let statements: Statement[] = codeBlock.statements
        if statements != null {
            for statement: Statement in statements {
                var bindingInitializer: BindingInitializer = null
                if statement is ConstantDeclaration {
                    let constantDeclaration: ConstantDeclaration = statement as ConstantDeclaration
                    bindingInitializer = constantDeclaration.initializer
                }
                if statement is MutableDeclaration {
                    let mutableDeclaration: MutableDeclaration = statement as MutableDeclaration
                    bindingInitializer = mutableDeclaration.initializer
                }
                if statement is VariableDeclaration {
                    let variableDeclaration: VariableDeclaration = statement as VariableDeclaration
                    bindingInitializer = variableDeclaration.initializer
                }
                if isRootBinding(bindingInitializer)
                    return(true)
            }
        }
        false
    }

    function getFunctionCall(patternInitializer: PatternInitializer&): FunctionCall& {
        if patternInitializer.initializer != null {
            let expression: Expression = patternInitializer.initializer.expression
            if expression is SimpleExpression {
                let simpleExpression: SimpleExpression = expression as SimpleExpression
                let prefixExpression: PrefixExpression = simpleExpression.prefixExpression
                let postfixExpression: PostfixExpression = prefixExpression.expression
                if postfixExpression.primaryExpression is IdentifierExpression {
                    if postfixExpression.postfixes != null {
                        let postfixes: Postfix[] = postfixExpression.postfixes
                        for postfix: Postfix in postfixes {
                            if postfix is FunctionCall {
                                return(postfix as FunctionCall)
                            }
                        }
                    }
                }
            }
        }
        null
    }

    function isCatchingFunctionCall(patternInitializer: PatternInitializer): bool {
        if catchesError(getFunctionCall(patternInitializer))
            return(true)

        false
    }

    function closeCodeBlock(codeBlock: CodeBlock) {
        if codeBlock.parent is FunctionDeclaration {
            let functionDeclaration: FunctionDeclaration = codeBlock.parent as FunctionDeclaration
            if (functionDeclaration.signature.throwsClause != null) && (functionDeclaration.signature.result == null) {
                indent(level(codeBlock))
                sourceFile.append("return nullptr;\n")
            }
        }
 
        indent(level(codeBlock) - 1)
        sourceFile.append("}\n")
        if codeBlock.parent is FunctionDeclaration
            sourceFile.append("\n")
    }

    function openSimpleExpression(simpleExpression: SimpleExpression): bool {

        let statement: Statement = simpleExpression as Statement
        if statement.parent is CodeBlock || statement.parent is CaseContent || statement.parent is CompilationUnit
            indent(level(simpleExpression))

        // Prepend a return if this expression is the only one of a function
        if statement.parent is FunctionDeclaration {
            let returnType: string$ = getReturnType(statement)
            if returnType != null
                prependReturn(simpleExpression)
        }
        
        // Prepend a return if this expression is the last one in the enclosing block if that block is the root block of a function declaration
        if statement.parent is CodeBlock {
            let block: CodeBlock = statement.parent as CodeBlock
            if block.parent is FunctionDeclaration {
                let statements: Statement[] = block.statements
                if statements[statements.length() - 1] == statement {
                    let returnType: string$ = getReturnType(statement)
                    if returnType != null
                        prependReturn(simpleExpression)
                }
            }
        }

        // Prefix type cast if any
        if simpleExpression.binaryOps != null {
            let binaryOps: BinaryOp[] = simpleExpression.binaryOps
            for binaryOp: BinaryOp in binaryOps {
                if binaryOp is TypeCast {
                    let typeCast: TypeCast = binaryOp as TypeCast
                    if  typeCast.objectType is Type {
                        let type: Type = typeCast.objectType as Type
                        sourceFile.append("(")
                        sourceFile.append(type.name)
                        sourceFile.append("*)")
                        simpleExpression.prefixExpression.accept(this)
                        return(false)
                    }
                }
            }
        }

        if simpleExpression.prefixExpression.expression.primaryExpression is IdentifierExpression {
            let binaryOps: BinaryOp[] = simpleExpression.binaryOps

            // If we assign to a member then clear the exclusive page of that member
            if binaryOps != null {
                if binaryOps.length() == 1 {
                    let binaryOp: BinaryOp = binaryOps[0]
                    if binaryOp is Assignment {
                        let assignment: Assignment = binaryOp as Assignment
                        let memberName: string& = getMemberIfCreatingObject(assignment)
                        if (memberName != null) && (!inConstructor(assignment)) {
                            sourceFile.append("if (")
                            sourceFile.append(memberName)
                            sourceFile.append(" != nullptr)\n")
                            this.indent(level(simpleExpression))
                            sourceFile.append("    ")
                            sourceFile.append(memberName)
                            sourceFile.append("->_getPage()->clear();\n")
                            this.indent(level(simpleExpression))
                        }
                    }
                }
            }

            // Prefix the error result for a catching function call
            if simpleExpression.parent is CodeBlock || simpleExpression.parent is CaseContent || simpleExpression.parent is CompilationUnit {
                let postfixes: Postfix[] = simpleExpression.prefixExpression.expression.postfixes
                if postfixes != null {
                    for postfix: Postfix in postfixes {
                        if postfix is FunctionCall {
                            let functionCall: FunctionCall = postfix as FunctionCall
                            if functionCall.catchClauses != null {
                                let identifierExpression: IdentifierExpression = simpleExpression.prefixExpression.expression.primaryExpression as IdentifierExpression
                                sourceFile.append("auto _")
                                sourceFile.append(identifierExpression.name)
                                sourceFile.append("_error = ")
                            }
                        }
                    }
                }
            }
        }

        if simpleExpression.parent is CompilationUnit {

            // Prefix the error result for a global function call which throws FileError
            let postfixes: Postfix[] = simpleExpression.prefixExpression.expression.postfixes
            if postfixes != null {
                for postfix: Postfix in postfixes {
                    if postfix is FunctionCall {
                        let functionCall: FunctionCall = postfix as FunctionCall
                        if functionCall.catchClauses == null {
                            if functionCall.parent is PostfixExpression {
                                let postfixExpression: PostfixExpression = (functionCall.parent) as PostfixExpression
                                if postfixExpression.primaryExpression is IdentifierExpression {
                                    let identifierExpression: IdentifierExpression = (postfixExpression.primaryExpression) as IdentifierExpression

                                    // Fix when print is recognized as external function
                                    if identifierExpression.name.equals("print") {
                                        sourceFile.append("{\n    auto _File_error = ")
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        true
    }

    function prependReturn(simpleExpression: SimpleExpression) {
        let expression: PrimaryExpression = simpleExpression.prefixExpression.expression.primaryExpression
        if (!expression is ReturnExpression) 
        && (!expression is ThrowExpression) 
        && (!expression is WhileExpression) 
        && (!expression is DoExpression)
            sourceFile.append("return ")
    }

    function closeSimpleExpression(simpleExpression: SimpleExpression) {

        let primaryExpression: PrimaryExpression = simpleExpression.prefixExpression.expression.primaryExpression

        if primaryExpression is IfExpression
            return

        if primaryExpression is SwitchExpression
            return

        if primaryExpression is ForExpression
            return

        if primaryExpression is WhileExpression
            return

        if primaryExpression is IdentifierExpression {
            let postfixExpression: PostfixExpression = simpleExpression.prefixExpression.expression
            if postfixExpression.postfixes != null {
                let postfixes: Postfix[] = postfixExpression.postfixes
                for postfix: Postfix in postfixes {
                    if postfix is FunctionCall {
                        let functionCall: FunctionCall = postfix as FunctionCall
                        if catchesError(functionCall)
                            return
                    }
                }
            }
        }
        if simpleExpression.parent is CodeBlock || simpleExpression.parent is CaseContent || simpleExpression.parent is CompilationUnit
            sourceFile.append(";\n")
            
        if simpleExpression.parent is CompilationUnit {

            // Check and return the error result for a global function call which throws FileError
            let postfixes: Postfix[] = simpleExpression.prefixExpression.expression.postfixes
            if postfixes != null {
                for postfix: Postfix in postfixes {
                    if postfix is FunctionCall {
                        let functionCall: FunctionCall = postfix as FunctionCall
                        if functionCall.catchClauses == null {
                            if functionCall.parent is PostfixExpression {
                                let postfixExpression: PostfixExpression = (functionCall.parent) as PostfixExpression
                                if postfixExpression.primaryExpression is IdentifierExpression {
                                    let identifierExpression: IdentifierExpression = (postfixExpression.primaryExpression) as IdentifierExpression

                                    // Fix this when print is recognized as external function
                                    if identifierExpression.name.equals("print") {
                                        sourceFile.append("    if (_File_error)\n        return _File_error;\n}\n")
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    function openInitializer(initializer: Initializer): bool {
        sourceFile.append(" = ")

        true
    }

    function openBindingInitializer(bindingInitializer: BindingInitializer): bool {

        if bindingInitializer.parent.parent is CodeBlock || bindingInitializer.parent.parent is CaseContent || bindingInitializer.parent.parent is CompilationUnit
            indent(level(bindingInitializer))

        true
    }

    function closeBindingInitializer(bindingInitializer: BindingInitializer) {

        if isCatchingFunctionCall(bindingInitializer.initializer)
            return

        if bindingInitializer.parent.parent is CodeBlock || bindingInitializer.parent.parent is CaseContent || bindingInitializer.parent.parent is CompilationUnit
            sourceFile.append(";\n")
    }

    function openFunctionSignature(functionSignature: FunctionSignature): bool {

        let functionName: string = (functionSignature.parent as FunctionDeclaration).name

        if functionSignature.result == null {
            if functionSignature.throwsClause == null
                sourceFile.append("void")
            else
                appendCppType(sourceFile, functionSignature.throwsClause.throwsType)
        }
        else {
            if functionSignature.throwsClause != null {

                sourceFile.append("_Result<")

                if hasArrayPostfix(functionSignature.result.resultType) {
                    let type: Type = functionSignature.result.resultType
                    sourceFile.append("_Array<")
                    appendCppTypeName(sourceFile, type)
                    sourceFile.append(">")
                }
                else {
                    let type: Type = functionSignature.result.resultType as Type
                    appendCppTypeName(sourceFile, type)
                }
                sourceFile.append(", ")
                appendCppTypeName(sourceFile, (functionSignature.throwsClause.throwsType) as Type)
                sourceFile.append(">")
            }
            else {
                if hasArrayPostfix(functionSignature.result.resultType) {
                    let type: Type = functionSignature.result.resultType
                    sourceFile.append("_Array<")
                    appendCppTypeName(sourceFile, type)
                    sourceFile.append(">")
                }
                else {
                    let type: Type = functionSignature.result.resultType as Type
                    appendCppTypeName(sourceFile, type)
                    if isClass(type.name) {
                        sourceFile.append("*")
                    }
                }
            }
        }

        sourceFile.append(" ")    
        if functionSignature.parent.parent.parent.parent is ClassDeclaration {
            let classDeclaration: ClassDeclaration = functionSignature.parent.parent.parent.parent as ClassDeclaration
            sourceFile.append(classDeclaration.name)
            sourceFile.append("::")
        }
        sourceFile.append(functionName)
        sourceFile.append("(")
        if functionSignature.result != null {
            let type: Type = functionSignature.result.resultType as Type
            if isClass(type.name) {
                let lifeTime: LifeTime = type.lifeTime
                if (lifeTime == null) || !(lifeTime is Reference) {
                    sourceFile.append("_Page* _rp")
                    if (functionSignature.parameterClause.parameters) || (functionSignature.throwsClause) {
                        sourceFile.append(", ")
                    }
                }
            }
        }
        if functionSignature.throwsClause != null {
            sourceFile.append("_Page* _ep")
            if functionSignature.parameterClause.parameters {
                sourceFile.append(", ")
            }
        }

        true
    }

    function openFunctionResult(functionResult: FunctionResult): bool {
        false
    }

    function closeParameterClause(parameterClause: ParameterClause) {
        sourceFile.append(") ")
    }

    function openConstParameter(constParameter: ConstParameter): bool {
        let constParameterName: string = constParameter.name
        writeParameter(constParameterName, constParameter.parameterType)

        false
    }

    function writeParameter(name: string, parameterType: Type) {
        let parameterClause: ParameterClause = parameterType.parent.parent as ParameterClause
        let parameters: Parameter[] = parameterClause.parameters
        let parameter: Parameter = parameterType.parent as Parameter
        if parameter != parameters[0]
            sourceFile.append(", ")
        parameterType.accept(this)
        sourceFile.append(" ")
        sourceFile.append(name)
    }

    function isClass(name: string): bool {
        if (    name.equals("string")
            ||  name.equals("VarString")
            ||  name.equals("File")
            ||  name.equals("Directory")
            ||  name.equals("Path")
            ||  name.equals("DirectoryError")
            ||  name.equals("FileError")
            ||  name.equals("ParserError")
            ||  name.equals("CppError")
            ||  name.equals("CompilerError")
           )
        {
            return(true)
        }

        for className: string in classes {
            if className.equals(name) {
                return(true)
            }
        }

        false
    }

    function openVarParameter(varParameter: VarParameter): bool {
        writeParameter(varParameter.name, varParameter.parameterType)
        false
    }

    function openThrowsClause(throwsClause: ThrowsClause): bool {
        false
    }

    function openEnumMember(enumMember: EnumMember): bool {
        if !enumMember.parent is EnumDeclaration
            return(false)

        let enumDeclarationName: string = ((enumMember.parent) as EnumDeclaration).name
        if enumMember.parameterClause {
            sourceFile.append("_")
            sourceFile.append(enumDeclarationName)
            sourceFile.append("_")
            sourceFile.append(enumMember.enumCase.name)
            sourceFile.append("::_")
            sourceFile.append(enumDeclarationName)
            sourceFile.append("_")
            sourceFile.append(enumMember.enumCase.name)
            sourceFile.append("(")
        }

        true
    }

    function closeEnumMember(enumMember: EnumMember) {
        if enumMember.parameterClause != null {
            sourceFile.append("\n")

            let parameters: Parameter[] = enumMember.parameterClause.parameters
            if parameters != null {
                sourceFile.append(": ")
                var pos: number = 0
                for parameter: Parameter in parameters {
                    if parameter is ConstParameter {
                        let constParameter: ConstParameter = parameter as ConstParameter
                        if pos != 0
                            sourceFile.append(", ")
                        sourceFile.append(constParameter.name)
                        sourceFile.append("(")
                        sourceFile.append(constParameter.name)
                        sourceFile.append(")")
                    }
                    pos++
                }
            }

            sourceFile.append(" { }\n\n_")
            let enumDeclarationName: string = ((enumMember.parent) as EnumDeclaration).name
            sourceFile.append(enumDeclarationName)
            sourceFile.append("_")
            sourceFile.append(enumMember.enumCase.name)
            sourceFile.append("* ")
            sourceFile.append(enumDeclarationName)
            sourceFile.append("::get_")
            sourceFile.append(enumMember.enumCase.name)
            sourceFile.append("() {\n    return (_")
            sourceFile.append(enumDeclarationName)
            sourceFile.append("_")
            sourceFile.append(enumMember.enumCase.name)
            sourceFile.append("*)errorInfo;\n}\n\n")
        }
    }

    function level(syntaxNode: SyntaxNode): number {

        mutable level: number = 0
        mutable node: SyntaxNode = syntaxNode
        
        while node != null {

            if node is CodeBlock
            || node is CompilationUnit
            || node is ForExpression
            || node is CatchClause
            || node is CurliedSwitchBody
            || node is CaseContent
                level++

            if node is ClassDeclaration
                level--
            
            node = node.parent
        }
        
        level
    }

    function indent(level: number) {
        var i: number = 0
        while i < level {
            sourceFile.append("    ")
            i++
        }
    }

    function collectDerivedClasses(mutable derivedClasses: string[], className: string) {
        for inherit: Inherits in inherits {
            if inherit.name.equals(className)
                appendDerivedClasses(derivedClasses, inherit.inheritors)
        }
    }

    function appendDerivedClasses(mutable derivedClasses: string[], mutable inheritors: string[]) {
        for inheritor: string in inheritors {
            derivedClasses.push(inheritor)
            collectDerivedClasses(derivedClasses, inheritor)
        }
    }

    function openPrefixExpression(prefixExpression: PrefixExpression): bool {
        if prefixExpression.prefixOperator != null
            sourceFile.append(prefixExpression.prefixOperator)

        true
    }

    function openPostfixExpression(postfixExpression: PostfixExpression): bool {
        if postfixExpression.postfixes != null {
            let postfixes: Postfix[] = postfixExpression.postfixes
            if (postfixes[0]) is Subscript {
                sourceFile.append("*(*")
            }
        }

        true
    }

    function openBinaryOperation(binaryOperation: BinaryOperation): bool {
        sourceFile.append(" ")
        sourceFile.append(binaryOperation.binaryOperator)
        sourceFile.append(" ")

        true
    }

    function openAssignment(assignment: Assignment): bool {
        sourceFile.append(" = ")

        true
    }

    function inConstructor(node: SyntaxNode): bool {

        if node is ConstructorDeclaration
            return(true)

        if node.parent == null
            return(false)

        inConstructor(node.parent)
    }

    function inReturn(node: SyntaxNode): bool {

        if node is ReturnExpression
            return(true)

        if node.parent == null
            return(false)

        inReturn(node.parent)
    }

    function inThrow(node: SyntaxNode): bool {

        if node is ThrowExpression
            return(true)

        if node.parent == null
            return(false)

        inThrow(node.parent)
    }

    function getMemberIfCreatingObject(assignment: Assignment&): string& {
        let functionName: string& = getFunctionName(assignment)
        if functionName == null {
            return(null)
        }

        if assignment.expression is SimpleExpression {
            if isClass(functionName) || isCreatingObject(functionName, assignment) {
                if assignment.parent is SimpleExpression {
                    let simpleExpression: SimpleExpression = (assignment.parent) as SimpleExpression
                    if simpleExpression.prefixExpression.prefixOperator == 0 {
                        let leftSide: PostfixExpression = simpleExpression.prefixExpression.expression
                        if (leftSide.postfixes == 0) && (leftSide.primaryExpression is IdentifierExpression) {
                            let memberExpression: IdentifierExpression = (leftSide.primaryExpression) as IdentifierExpression
                            let memberName: string = memberExpression.name
                            var classDeclaration: ClassDeclaration = getClassDeclaration(assignment)
                            if classDeclaration != null {
                                if isVariableMember(memberName, classDeclaration)
                                    return(memberName)
                            }
                        }
                    }
                }
            }
        }
        
        null
    }

    function getFunctionName(assignment: Assignment&): string& {
        if assignment.expression is SimpleExpression {
            let simpleExpression: SimpleExpression = (assignment.expression) as SimpleExpression
            let prefixExpression: PrefixExpression = simpleExpression.prefixExpression
            if prefixExpression.prefixOperator == null {
                let rightSide: PostfixExpression = prefixExpression.expression
                if rightSide.primaryExpression is IdentifierExpression {
                    let classExpression: IdentifierExpression = (rightSide.primaryExpression) as IdentifierExpression
                    return(classExpression.name)
                }
                else {
                    if rightSide.primaryExpression is ConstructorCall {
                        let constructorCall: ConstructorCall = (rightSide.primaryExpression) as ConstructorCall
                        let type: Type = constructorCall.typeToConstruct
                        return(type.name)
                    }
                }
            }
        }

        null
    }
    
    function isCreatingObject(functionName: string, node: SyntaxNode): bool {
        var classDeclaration: ClassDeclaration = getClassDeclaration(node)
        if classDeclaration == null
            return(false)

        let members: ClassMember[] = classDeclaration.body.members
        if members == null
            return(false)

        for member: ClassMember in members {
            if member.declaration is FunctionDeclaration {
                let functionDeclaration: FunctionDeclaration = (member.declaration) as FunctionDeclaration
                if functionDeclaration.name.equals(functionName)
                    return(true)
            } 
        }

        false
    }

    function getClassDeclaration(node: SyntaxNode&): ClassDeclaration& {
        if node is ClassDeclaration
            return(node as ClassDeclaration)

        if node.parent != null
            return(getClassDeclaration(node.parent))
        
        null
    }
    
    function isVariableMember(memberName: string, classDeclaration: ClassDeclaration): bool {
        let classMembers: ClassMember[] = classDeclaration.body.members
        for member: ClassMember in classMembers {
            var bindingInitializer: BindingInitializer = null
            if member.declaration is MutableDeclaration {
                let mutableDeclaration: MutableDeclaration = (member.declaration) as MutableDeclaration
                bindingInitializer = mutableDeclaration.initializer
            }
            if member.declaration is VariableDeclaration {
                let variableDeclaration: VariableDeclaration = (member.declaration) as VariableDeclaration
                bindingInitializer = variableDeclaration.initializer
            }
            
            if bindingInitializer == null
                continue
                
            let patternInitializer: PatternInitializer = bindingInitializer.initializer
            if patternInitializer.pattern is IdentifierPattern {
                let identifierPattern: IdentifierPattern = (patternInitializer.pattern) as IdentifierPattern
                if identifierPattern.identifier.equals(memberName)
                    return(true)
            }
        }

        false
    }

    function openTypeQuery(typeQuery: TypeQuery): bool {
        sourceFile.append("->_is")

        true
    }

    function openCatchClause(catchClause: CatchClause): bool {
        if catchClause.parent is FunctionCall {
            let functionCall: FunctionCall = (catchClause.parent) as FunctionCall
            {
                var bindingInitializer: BindingInitializer = getBindingInitializer(functionCall)
                if bindingInitializer != null {
                    let patternInitializer: PatternInitializer = bindingInitializer.initializer
                    if patternInitializer.pattern is IdentifierPattern {
                        let identifierPattern: IdentifierPattern = (patternInitializer.pattern) as IdentifierPattern
                        let catchClauses: CatchClause[] = functionCall.catchClauses
                        if catchClauses[0] == catchClause {
                            sourceFile.append(";\n")

                            indent(level(catchClause) - 1)
                            identifierPattern.annotationForType.accept(this)
                            sourceFile.append(" ")
                            sourceFile.append(identifierPattern.identifier)
                            sourceFile.append(" = nullptr;\n")

                            indent(level(catchClause) - 1)
                            sourceFile.append("if (_")
                            sourceFile.append(identifierPattern.identifier)
                            sourceFile.append("_result.succeeded()) {\n")

                            indent(level(catchClause) - 1)
                            sourceFile.append("    ")
                            sourceFile.append(identifierPattern.identifier)
                            sourceFile.append(" = _")
                            sourceFile.append(identifierPattern.identifier)                    
                            sourceFile.append("_result.getResult();\n")
                            indent(level(catchClause) - 1)
                            sourceFile.append("}\n")
                        }

                        indent(level(catchClause) - 1)
                        sourceFile.append("else")
                        if catchClause.catchPattern is IdentifierCatchPattern {
                            let identifierCatchPattern: IdentifierCatchPattern = (catchClause.catchPattern) as IdentifierCatchPattern
                            sourceFile.append(" if (_")
                            sourceFile.append(identifierPattern.identifier)
                            sourceFile.append("_result._getErrorCode() == _")
                            sourceFile.append(identifierCatchPattern.name)
                            sourceFile.append("Code_")
                            var errorType: string = getErrorType(catchClause)
                            if errorType != null
                                sourceFile.append(errorType)
                            sourceFile.append(")")
                        }
                        sourceFile.append(" {\n")

                        if catchClause.catchPattern is WildCardCatchPattern {
                            if catchClause.bindingPattern != null {
                                let bindingPattern: TuplePattern = catchClause.bindingPattern
                                if bindingPattern.elements != null {
                                    if bindingPattern.elements.length() > 0 {
                                        let elements: TuplePatternElement[] = bindingPattern.elements
                                        let element: TuplePatternElement = elements[0]
                                        if element.pattern is IdentifierPattern {
                                            let pattern: IdentifierPattern = (element.pattern) as IdentifierPattern

                                            indent(level(catchClause))
                                            sourceFile.append("auto ")
                                            sourceFile.append(pattern.identifier)                    
                                            sourceFile.append(" = _")
                                            sourceFile.append(identifierPattern.identifier)
                                            sourceFile.append("_result.getError();\n")
                                        }
                                    }
                                }
                            }
                        }
                        
                        indent(level(catchClause))
                        if catchClause.expression is SimpleExpression {
                            let simpleExpression: SimpleExpression = (catchClause.expression) as SimpleExpression
                            let primaryExpression: PrimaryExpression = simpleExpression.prefixExpression.expression.primaryExpression
                            if (!primaryExpression is ReturnExpression) && (!primaryExpression is BreakExpression) && (!primaryExpression is ThrowExpression) {
                                sourceFile.append(identifierPattern.identifier)
                                sourceFile.append(" = ")
                            }
                        }
                        catchClause.expression.accept(this)
                        if catchClause.expression is SimpleExpression
                            sourceFile.append(";\n")
                        indent(level(catchClause) - 1)
                        sourceFile.append("}\n")
                    }
                }
            }
            {
                var identifierExpression: IdentifierExpression = getIdentifierExpression((functionCall.parent) as PostfixExpression)
                if identifierExpression != null {
                    let catchClauses: CatchClause[] = functionCall.catchClauses
                    if catchClauses[0] == catchClause {
                        sourceFile.append(";\n")
                        indent(level(catchClause) - 1)
                        sourceFile.append("if (_")
                        sourceFile.append(identifierExpression.name)
                        sourceFile.append("_error) { switch (_")
                        sourceFile.append(identifierExpression.name)
                        sourceFile.append("_error->_getErrorCode()) {\n")
                    }
                    indent(level(catchClause))
                    if catchClause.catchPattern is IdentifierCatchPattern {
                        sourceFile.append("case _")
                        let identifierCatchPattern: IdentifierCatchPattern = (catchClause.catchPattern) as IdentifierCatchPattern
                        sourceFile.append(identifierCatchPattern.name)
                        sourceFile.append("Code_")
                        if identifierCatchPattern.member != null {
                            sourceFile.append(identifierCatchPattern.member.member)
                            sourceFile.append(": {\n")
                            indent(level(catchClause) - 1)
                            sourceFile.append("    _")
                            sourceFile.append(identifierCatchPattern.name)
                            sourceFile.append("_")
                            sourceFile.append(identifierCatchPattern.member.member)                            
                            sourceFile.append("* ")
                            if catchClause.bindingPattern != null {
                                let bindingPattern: TuplePattern = catchClause.bindingPattern
                                if bindingPattern.elements != null {
                                    if bindingPattern.elements.length() > 0 {
                                        let elements: TuplePatternElement[] = bindingPattern.elements
                                        let element: TuplePatternElement = elements[0]
                                        if element.pattern is IdentifierPattern {
                                            let pattern: IdentifierPattern = (element.pattern) as IdentifierPattern
                                            sourceFile.append(pattern.identifier)                    
                                            sourceFile.append(" = _")
                                            sourceFile.append(identifierExpression.name)
                                            sourceFile.append("_error->get_")
                                            sourceFile.append(identifierCatchPattern.member.member)                            
                                            sourceFile.append("();")
                                        }
                                    }
                                }
                            }
                            sourceFile.append("\n")
                        }
                    }
                    if catchClause.catchPattern is WildCardCatchPattern {
                        sourceFile.append("default: {\n")
                        //indent(level(catchClause))
                    }
                    
                    indent(level(catchClause))
                    catchClause.expression.accept(this)
                    {
                        var insertBreak: bool = true
                        if catchClause.expression is SimpleExpression {
                            let simpleExpression: SimpleExpression = catchClause.expression as SimpleExpression
                            if simpleExpression.prefixExpression.expression.primaryExpression is ReturnExpression {
                                sourceFile.append(";\n")
                                insertBreak = false
                            }
                        }
                        if insertBreak {
                            indent(level(catchClause))
                            sourceFile.append("break;\n")
                        }
                    }

                    indent(level(catchClause))
                    sourceFile.append("}\n")
                    
                    let clauses: CatchClause[] = functionCall.catchClauses
                    if clauses[functionCall.catchClauses.length() - 1] == catchClause {
                        indent(level(catchClause) - 1)
                        sourceFile.append("} }\n")
                    }
                }
            }
        }
        false
    }

    function getIdentifierExpression(postfixExpression: PostfixExpression&): IdentifierExpression& {
        if postfixExpression.parent.parent.parent is CodeBlock || postfixExpression.parent.parent.parent is CompilationUnit {
            if postfixExpression.parent is PrefixExpression {
                let prefixExpression: PrefixExpression = (postfixExpression.parent) as PrefixExpression
                if prefixExpression.expression.primaryExpression is IdentifierExpression {
                    return((prefixExpression.expression.primaryExpression) as IdentifierExpression)
                }
            }
        }

        null
    }

    function getErrorType(catchClause: CatchClause&): string& {
        if catchClause.bindingPattern != null {
            if catchClause.bindingPattern.elements != null {
                if catchClause.bindingPattern.elements.length() == 1 {
                    let elements: TuplePatternElement[] = catchClause.bindingPattern.elements
                    let element: TuplePatternElement = elements[0]
                    if element.pattern is IdentifierPattern {
                        let pattern: IdentifierPattern = (element.pattern) as IdentifierPattern
                        if pattern.annotationForType != null {
                            if pattern.annotationForType.annotationForType is Type {
                                let type: Type = (pattern.annotationForType.annotationForType) as Type
                                return(type.name)
                            }
                        }
                    }
                }
            }
        }

        null
    }

    function visitOperatorPostfix(operatorPostfix: OperatorPostfix) {
        sourceFile.append(operatorPostfix.postfixOperator)
    }

    function visitMemberExpression(memberExpression: MemberExpression) {
        if memberExpression.parent is PostfixExpression {
            let postfixExpression: PostfixExpression = (memberExpression.parent) as PostfixExpression
            if postfixExpression.primaryExpression is IdentifierExpression {
                let identifierExpression: IdentifierExpression = (postfixExpression.primaryExpression) as IdentifierExpression
                if postfixExpression.postfixes.length() > 1 {
                    let postfixes: Postfix[] = postfixExpression.postfixes
                    if (postfixes[0] == explicitMemberExpression as Postfix) && ((postfixes[1]) is FunctionCall) {
                        if isClass(identifierExpression.name) {
                            sourceFile.append("::")
                            sourceFile.append(memberExpression.member)
                            return
                        }
                    }
                }
            }
        }
        sourceFile.append("->")
        sourceFile.append(memberExpression.member)
    }

    function openSubscript(subscript: Subscript): bool {
        sourceFile.append("[")

        true
    }

    function closeSubscript(subscript: Subscript) {
        sourceFile.append("]")
    }

    function closeExpressionElement(expressionElement: ExpressionElement) {
        if !isLastExpressionElement(expressionElement)
            sourceFile.append(", ")
    }

    function isLastExpressionElement(expressionElement: ExpressionElement): bool {
        if expressionElement.parent is ParenthesizedExpression {
            let parenthesizedExpression: ParenthesizedExpression = (expressionElement.parent) as ParenthesizedExpression
            let expressionElements: ExpressionElement[] = parenthesizedExpression.expressionElements
            let length: number = expressionElements.length() - 1
            let i: number = 0
            for element: ExpressionElement in expressionElements {
                if (element == expressionElement) && (i == length)
                    return(true)
                i++
            }
        }

        if expressionElement.parent is Subscript {
            let subscript: Subscript = (expressionElement.parent) as Subscript
            let expressions: ExpressionElement[] = subscript.expressions
            let length: number = expressions.length() - 1
            let i: number = 0
            for element: ExpressionElement in expressions {
                if (element == expressionElement) && (i == length)
                    return(true)
                i++
            }
        }

        false
    }

    function visitIdentifierExpression(identifierExpression: IdentifierExpression) {
        sourceFile.append(identifierExpression.name)
        if identifierExpression.parent is PostfixExpression {
            let postfixExpression: PostfixExpression = (identifierExpression.parent) as PostfixExpression
            if postfixExpression.postfixes != null {
                let postfixes: Postfix[] = postfixExpression.postfixes
                if (postfixes[0]) is Subscript {
                    sourceFile.append(")")
                }
            }
        }
    }

    function inAssignment(syntaxNode: SyntaxNode): bool {
        if syntaxNode is Assignment
            return(true)

        let parentNode: SyntaxNode = syntaxNode.parent
        if parentNode == null
            return(false)

        inAssignment(parentNode)
    }

    function getAssignment(syntaxNode: SyntaxNode&): Assignment& {
        if syntaxNode is Assignment
            return(syntaxNode as Assignment)

        let parentNode: SyntaxNode = syntaxNode.parent
        if parentNode == null
            return(null)

        getAssignment(parentNode)
    }

    function getInitializer(syntaxNode: SyntaxNode&): Initializer& {
        if syntaxNode is Initializer
            return(syntaxNode as Initializer)

        let parentNode: SyntaxNode = syntaxNode.parent
        if parentNode == null
            return(null)

        getInitializer(parentNode)
    }

    function inRetDeclaration(syntaxNode: SyntaxNode): bool {
        if syntaxNode == null
            return(false)

        var bindingInitializer: BindingInitializer = null

        do {
            if syntaxNode is BindingInitializer {
                bindingInitializer = (syntaxNode as BindingInitializer)
                break
            }
            syntaxNode = syntaxNode.parent
        } 
        while syntaxNode != null

        if bindingInitializer == null
            return(false)

        if bindingInitializer.initializer != null {
            let patternInitializer: PatternInitializer = bindingInitializer.initializer
            if patternInitializer.pattern is IdentifierPattern {
                let identifierPattern: IdentifierPattern = (patternInitializer.pattern) as IdentifierPattern
                return(identifierPattern.identifier.equals("ret"))
            }
        }

        false
    }

    function visitLiteralExpression(literalExpression: LiteralExpression) {
        let literal: Literal = literalExpression.literal
        if literal is NumericLiteral {
            let numericLiteral: NumericLiteral = literal as NumericLiteral
            sourceFile.append(numericLiteral.value)
        }
        else {
            if literal is StringLiteral {
                let stringLiteral: StringLiteral = literal as StringLiteral
                sourceFile.append("\"")
                sourceFile.append(stringLiteral.value)
                sourceFile.append("\"")
            }
            else {
                if literal is CharacterLiteral {
                    let characterLiteral: CharacterLiteral = literal as CharacterLiteral
                    sourceFile.append("\'")
                    if characterLiteral.value.getLength() > 0 {
                        if (characterLiteral.value.charAt(0) == '"') || (characterLiteral.value.charAt(0) == '\'') {
                            sourceFile.append("\\")
                            sourceFile.append(characterLiteral.value)
                        }
                        else {                        
                            switch characterLiteral.value.charAt(0) {                            
                                case '\r': sourceFile.append("\\r")
                                case '\n': sourceFile.append("\\n")
                                case '\t': sourceFile.append("\\t")
                                case '\0': sourceFile.append("\\0")
                                case '\\': sourceFile.append("\\\\")
                                default:   sourceFile.append(characterLiteral.value)                                    
                            }
                        }
                    }
                    sourceFile.append("\'")
                }
            }
        }
    }

    function openIfExpression(ifExpression: IfExpression): bool {
        sourceFile.append("if (")
        ifExpression.condition.accept(this)
        sourceFile.append(")")
        if ifExpression.consequent is SimpleExpression {
            sourceFile.append("\n    ")
            indent(level(ifExpression))
            ifExpression.consequent.accept(this)
            sourceFile.append(";\n")
        }
        else {
            sourceFile.append(" ")
            ifExpression.consequent.accept(this)
        }
        if ifExpression.elseClause != null {
            if ifExpression.elseClause.alternative is SimpleExpression {
                ifExpression.elseClause.accept(this)
                sourceFile.append(";\n")
            }
            else {
                ifExpression.elseClause.accept(this)
            }
        }

        false
    }

    function openSwitchExpression(switchExpression: SwitchExpression): bool {
        sourceFile.append("switch (")

        true
    }

    function closeSwitchExpression(switchExpression: SwitchExpression) {
    }

    function openForExpression(forExpression: ForExpression): bool {
        let pattern: Pattern = forExpression.pattern
        pattern.accept(this)    
        if pattern is IdentifierPattern {
            sourceFile.append(" = nullptr;\n")
            indent(level(forExpression) - 1)
            sourceFile.append("size_t _")
            let expression: Expression = forExpression.expression
            if expression is SimpleExpression {
                let simpleExpression: SimpleExpression = expression as SimpleExpression
                if simpleExpression.prefixExpression.expression.primaryExpression is IdentifierExpression {
                    let identifierExpression: IdentifierExpression = (simpleExpression.prefixExpression.expression.primaryExpression) as IdentifierExpression
                    let collectionName: string = identifierExpression.name
                    sourceFile.append(collectionName)
                    sourceFile.append("_length = ")
                    sourceFile.append(collectionName)
                    sourceFile.append("->length();\n")
                    indent(level(forExpression) - 1)
                    sourceFile.append("for (size_t _i = 0; _i < _")
                    sourceFile.append(collectionName)
                    sourceFile.append("_length; _i++) {\n")
                    indent(level(forExpression))
                    if forExpression.pattern is IdentifierPattern {
                        let identifierPattern: IdentifierPattern = (forExpression.pattern) as IdentifierPattern
                        sourceFile.append(identifierPattern.identifier)
                        sourceFile.append(" = *(*")
                        sourceFile.append(collectionName)
                        sourceFile.append(")[_i];\n")
                        indent(level(forExpression))
                        forExpression.code.accept(this)
                        if forExpression.code is SimpleExpression
                            sourceFile.append(";\n")
                        indent(level(forExpression) - 1)
                        sourceFile.append("}\n")
                    }
                }
            }
        }

        false
    }

    function openWhileExpression(whileExpression: WhileExpression): bool {
        sourceFile.append("while (")
        whileExpression.condition.accept(this)
        sourceFile.append(")")
        if whileExpression.code is SimpleExpression {
            sourceFile.append("\n")
            indent(level(whileExpression) + 1)
            whileExpression.code.accept(this)
            sourceFile.append(";\n")
        }
        else {
            sourceFile.append(" ")
            whileExpression.code.accept(this)
        }

        false
    }

    function openDoExpression(doExpression: DoExpression): bool {
        sourceFile.append("do")
        if doExpression.code is SimpleExpression {
            sourceFile.append("\n")
            indent(level(doExpression) + 1)
            doExpression.code.accept(this)
            sourceFile.append(";")
        }
        else {
            sourceFile.append(" ")
            doExpression.code.accept(this)
        }
        indent(level(doExpression))
        sourceFile.append("while (")
        doExpression.condition.accept(this)
        sourceFile.append(")")

        false
    }

    function openParenthesizedExpression(parenthesizedExpression: ParenthesizedExpression): bool {
        if !(parenthesizedExpression.parent) is ReturnExpression
            sourceFile.append("(")
        if parenthesizedExpression.parent is FunctionCall {
            let functionCall: FunctionCall = (parenthesizedExpression.parent) as FunctionCall
            if functionCall.parent is PostfixExpression {
                let postfixExpression: PostfixExpression = (functionCall.parent) as PostfixExpression
                if postfixExpression.primaryExpression is IdentifierExpression {
                    let identifierExpression: IdentifierExpression = (postfixExpression.primaryExpression) as IdentifierExpression
                    if !isClass(identifierExpression.name) {
                        if postfixExpression.parent.parent.parent is Assignment {
                            let assignment: Assignment = (postfixExpression.parent.parent.parent) as Assignment
                            let member: string& = getMemberIfCreatingObject(assignment)
                            if member != null {
                                var classDeclaration: ClassDeclaration = getClassDeclaration(assignment)
                                if isVariableMember(member, classDeclaration) {
                                    sourceFile.append(member)
                                    sourceFile.append("->_getPage()")
                                    if functionCall.arguments != null && functionCall.arguments.expressionElements != null
                                        sourceFile.append(", ")
                                }
                            }
                        }
                    }
                }
            }

            let parameterInserted: bool = false
            if !callsInitializer(functionCall) {
                if assignedToRootObject(functionCall) {
                    sourceFile.append("_p")
                    parameterInserted = true
                }
                else {
                    if assignedToReturnedObject(functionCall) {
                        sourceFile.append("_rp")
                        parameterInserted = true
                    }
                    else {
                        let identifier: string& = getLocalPage(functionCall)
                        if identifier != null {
                            sourceFile.append(identifier)
                            sourceFile.append("->_getPage()")
                            parameterInserted = true
                        }
                    }
                }
            }
            if catchesError(functionCall) {
                if !inThrow(functionCall) {
                    if parameterInserted
                        sourceFile.append(", ")
                    let thrownType: string$ = getThrownType(functionCall)
                    if thrownType == null
                        sourceFile.append("_p")
                    else
                        sourceFile.append("_ep")
                    parameterInserted = true
                }
            }
            
            if functionCall.catchClauses == null {
                if functionCall.parent is PostfixExpression {
                    let postfixExpression: PostfixExpression = (functionCall.parent) as PostfixExpression
                    if postfixExpression.primaryExpression is IdentifierExpression {
                        let identifierExpression: IdentifierExpression = (postfixExpression.primaryExpression) as IdentifierExpression
                        // Fix when print is recognized as external function
                        if identifierExpression.name.equals("print") {
                            sourceFile.append("_ep")
                            parameterInserted = true
                        }
                    }
                }
            }

            if parameterInserted && (parenthesizedExpression.expressionElements != null)
                sourceFile.append(", ")
        }

        true
    }

    function assignedToRootObject(functionCall: FunctionCall): bool {
        var bindingInitializer: BindingInitializer = getBindingInitializer(functionCall)
        if bindingInitializer == null
            return(false)
        
        isRootBinding(bindingInitializer)
    }
    
    function getLocalPage(functionCall: FunctionCall&): string& {
        var bindingInitializer: BindingInitializer = getBindingInitializer(functionCall) 
        if bindingInitializer == null
            return(null)
            
        let patternInitializer: PatternInitializer = bindingInitializer.initializer
        if patternInitializer.pattern is IdentifierPattern {
            let identifierPattern: IdentifierPattern = (patternInitializer.pattern) as IdentifierPattern
            let type: Type = identifierPattern.annotationForType.annotationForType

            if type.lifeTime == null
                return(null)

            if type.lifeTime is Local {
                let local: Local = type.lifeTime as Local
                return (local.location)
            }
        }
        
        null
    }
    
    function isRootBinding(bindingInitializer: BindingInitializer): bool {
 
       if bindingInitializer == null
            return(false)
            
        let patternInitializer: PatternInitializer = bindingInitializer.initializer
        if patternInitializer.pattern is IdentifierPattern {
            let identifierPattern: IdentifierPattern = (patternInitializer.pattern) as IdentifierPattern
            let type: Type = identifierPattern.annotationForType.annotationForType

            if type.lifeTime == null
                return(false)

            if type.lifeTime is Root
                return(true)
        }
        
        false
    }

    function assignedToReturnedObject(functionCall: FunctionCall): bool {
        var bindingInitializer: BindingInitializer = getBindingInitializer(functionCall)
        if bindingInitializer == null
            return(false)

        if bindingInitializer.parent is ConstantDeclaration {
            if boundToObject(bindingInitializer)
                return(true)
        }

        false
    }

    function boundToObject(bindingInitializer: BindingInitializer): bool {
        
        if bindingInitializer == null
            return(false)

        let patternInitializer: PatternInitializer = bindingInitializer.initializer
        if patternInitializer.pattern is IdentifierPattern {
            let identifierPattern: IdentifierPattern = (patternInitializer.pattern) as IdentifierPattern
            let type: Type = identifierPattern.annotationForType.annotationForType
            
            if type.lifeTime != null
                return(false)

            if isClass(type.name) && (getFunctionCall(patternInitializer) != null)
                return(true)
        }

        false
    }

    function getBindingInitializer(functionCall: FunctionCall&): BindingInitializer& {
        if functionCall.parent is PostfixExpression {
            let postfixExpression: PostfixExpression = (functionCall.parent) as PostfixExpression
            if postfixExpression.parent.parent.parent is Initializer {
                let initializer: Initializer = (postfixExpression.parent.parent.parent) as Initializer
                if initializer.parent is PatternInitializer {
                    let patternInitializer: PatternInitializer = (initializer.parent) as PatternInitializer
                    if patternInitializer.parent is BindingInitializer {
                        return((patternInitializer.parent) as BindingInitializer)
                    }
                }
            }
        }

        null
    }

    function callsInitializer(functionCall: FunctionCall): bool {
        if functionCall.parent is PostfixExpression {
            let postfixExpression: PostfixExpression = (functionCall.parent) as PostfixExpression
            if postfixExpression.postfixes.length() == 1 {
                if postfixExpression.primaryExpression is IdentifierExpression {
                    let identifierExpression: IdentifierExpression = (postfixExpression.primaryExpression) as IdentifierExpression
                    if isClass(identifierExpression.name) {
                        return(true)
                    }
                }
            }
        }

        false
    }

    function catchesError(functionCall: FunctionCall): bool {
        if functionCall == null
            return(false)

        if functionCall.catchClauses != null
            return(true)

        false
    }

    function closeParenthesizedExpression(parenthesizedExpression: ParenthesizedExpression) {
        if !(parenthesizedExpression.parent) is ReturnExpression
            sourceFile.append(")")
    }

    function openReturnExpression(returnExpression: ReturnExpression): bool {
        sourceFile.append("return")
        if returnExpression.expression != null {
            sourceFile.append(" ")
            let returnType: string$ = getReturnType(returnExpression)
            let thrownType: string$ = getThrownType(returnExpression)
            if thrownType != null {
                sourceFile.append("_Result<")
                if returnType != null
                    sourceFile.append(returnType)
                sourceFile.append(", ")
                sourceFile.append(thrownType)
                sourceFile.append(">(")
            }
            returnExpression.expression.accept(this)
            if returnsArray(returnExpression) {
                sourceFile.append(" ? new(_rp) ")
                sourceFile.append(returnType)
                sourceFile.append("(")
                returnExpression.expression.accept(this)
                sourceFile.append(") : nullptr")
            }
            if thrownType != null
                sourceFile.append(")")
        }
        else {
            if inTopLevelCode(returnExpression)
                sourceFile.append(" nullptr")
        }

        false
    }
    
    function inTopLevelCode(syntaxNode: SyntaxNode):bool {

        if syntaxNode == null
            return(false)

        if syntaxNode is FunctionDeclaration
            return(false)

        if syntaxNode is CompilationUnit
            return(true)
            
        if syntaxNode.parent == null
            return(false)

        inTopLevelCode(syntaxNode.parent)
    }

    function closeReturnExpression(returnExpression: ReturnExpression) {
        let returnType: string$ = getReturnType(returnExpression)
        if returnType != null {
            sourceFile.append(")")
        }
    }

    function openThrowExpression(throwExpression: ThrowExpression): bool {
        let thrownType: string$ = getThrownType(throwExpression)
        if thrownType == null
            return(false)

        sourceFile.append("return ")
        let returnType: string$ = getReturnType(throwExpression)
        if returnType != null {
            sourceFile.append("_Result<")
            sourceFile.append(returnType)
            sourceFile.append(", ")
            sourceFile.append(thrownType)
            sourceFile.append(">(")
        }
        {
            let buildError: bool = true
            if throwExpression.arguments == null {
                if throwExpression.error is IdentifierExpression {
                    let errorExpression: IdentifierExpression = (throwExpression.error) as IdentifierExpression
                    let errorName: string = errorExpression.name
                    var catchClause: CatchClause = getCatchClause(throwExpression)
                    if catchClause != null {
                        if catchClause.catchPattern != null {
                            if catchClause.catchPattern is WildCardCatchPattern {
                                if catchClause.bindingPattern != null {
                                    let bindingPattern: TuplePattern bindingPattern = catchClause.bindingPattern
                                    if bindingPattern.elements != null {
                                        if bindingPattern.elements.length() > 0 {
                                            let elements: TuplePatternElement[] = bindingPattern.elements
                                            let element: TuplePatternElement = elements[0]
                                            if element.pattern is IdentifierPattern {
                                                let pattern: IdentifierPattern = (element.pattern) as IdentifierPattern
                                                if pattern.identifier.equals(errorName)
                                                    buildError = false
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if buildError {
                sourceFile.append("new(_ep) ")
                sourceFile.append(thrownType)
                sourceFile.append("(")
                if throwExpression.arguments != null
                    sourceFile.append("new(_ep) ")
                sourceFile.append("_")
                sourceFile.append(thrownType)
                if throwExpression.arguments == null
                    sourceFile.append("Code")
                sourceFile.append("_")
            }
            if throwExpression.error != null
                throwExpression.error.accept(this)
            if throwExpression.arguments != null
                throwExpression.arguments.accept(this)
            if buildError
                sourceFile.append(")")
        }
        if returnType != null
            sourceFile.append(")")

        false
    }

    function inWildcardCatchClause(throwExpression: ThrowExpression): bool {
        var catchClause: CatchClause = getCatchClause(throwExpression)
        if (catchClause != null) && (catchClause.catchPattern is WildCardCatchPattern)
            return(true)

        false
    }

    function getCatchClause(syntaxNode: SyntaxNode&): CatchClause& {
        if syntaxNode is CatchClause
            return(syntaxNode as CatchClause)

        if syntaxNode.parent == null
            return(null)

        getCatchClause(syntaxNode.parent)
    }

    function getReturnType(syntaxNode: SyntaxNode): string {
        var functionDeclaration: FunctionDeclaration = getFunctionDeclaration(syntaxNode)
        if functionDeclaration != null {
            let functionResult: FunctionResult = functionDeclaration.signature.result
            if functionResult != null {
                let ret: VarString = new VarString()
                if hasArrayPostfix(functionResult.resultType) {
                    let type: Type = functionResult.resultType
                    ret.append("_Array<")
                    appendCppTypeName(ret, type)
                    ret.append(">")
                    return(new string(ret))
                }
                else {
                    appendCppTypeName(ret, functionResult.resultType)
                    return(new string(ret))
                }
            }
        }
        
        null
    }
    
    function getThrownType(syntaxNode: SyntaxNode): string {
        var functionDeclaration: FunctionDeclaration = getFunctionDeclaration(syntaxNode)
        if functionDeclaration != null {
            let throwsClause: ThrowsClause = functionDeclaration.signature.throwsClause
            if throwsClause != null {
                let ret: VarString = new VarString()
                if hasArrayPostfix(throwsClause.throwsType) {
                    let type: Type = throwsClause.throwsType
                    ret.append("_Array<")
                    appendCppTypeName(ret, type)
                    ret.append(">")
                    return(new string(ret))
                }
                else {
                    appendCppTypeName(ret, throwsClause.throwsType)
                    return(new string(ret))
                }
            }
        }
        
        null
    }

    function returnsArray(syntaxNode: SyntaxNode): bool {
        var functionDeclaration: FunctionDeclaration = getFunctionDeclaration(syntaxNode)
        if functionDeclaration != null {
            let functionResult: FunctionResult = functionDeclaration.signature.result
            if functionResult != null {
                if hasArrayPostfix(functionResult.resultType)
                    return(true)
            }
        }    

        false
    }

    function getFunctionDeclaration(syntaxNode: SyntaxNode&): FunctionDeclaration& {
        if syntaxNode is FunctionDeclaration
            return(syntaxNode as FunctionDeclaration)

        if syntaxNode.parent == null
            return(null)

        getFunctionDeclaration(syntaxNode.parent)
    }

    function openBreakExpression(breakExpression: BreakExpression): bool {
        sourceFile.append("break")

        true
    }
    
    function getPage(node: SyntaxNode): string {

        while node != null {
            if node is ReturnExpression
                return(new string("_rp"))

            if node is ThrowExpression
                return(new string("_ep"))

            node = node.parent
        }

        null
    }

    function openConstructorCall(constructorCall: ConstructorCall): bool {
        sourceFile.append("new(")
        
        let page: string$ = getPage(constructorCall.parent)
        if page != null {
            sourceFile.append(page)
        }
        else {
            if initializerIsBoundOrAssigned(constructorCall) {
                let assignment: Assignment& = getAssignment(constructorCall)
                if assignment != null {
                    var classDeclaration: ClassDeclaration = getClassDeclaration(assignment)
                    let memberName: string& = getMemberIfCreatingObject(assignment)
                    if memberName != null {
                        if isVariableMember(memberName, classDeclaration) {
                            if !inConstructor(assignment) {
                                sourceFile.append(memberName)
                                sourceFile.append("->")
                            }
                            sourceFile.append("_getPage()")
                            if inConstructor(assignment) {
                                sourceFile.append("->allocateExclusivePage()")
                            }
                        }
                    }
                    else {
                        let simpleExpression: SimpleExpression = (assignment.parent) as SimpleExpression
                        if simpleExpression.prefixExpression.prefixOperator == null {
                            let leftSide: PostfixExpression = simpleExpression.prefixExpression.expression
                            if (leftSide.postfixes == null) && (leftSide.primaryExpression is IdentifierExpression) {
                                let memberExpression: IdentifierExpression = (leftSide.primaryExpression) as IdentifierExpression
                                let memberName: string = memberExpression.name
                                var classDeclaration: ClassDeclaration = getClassDeclaration(assignment)
                                if (classDeclaration != null) && (memberName != null) && !hasArrayPostfix(constructorCall.typeToConstruct) {
                                    if isVariableMember(memberName, classDeclaration) {
                                        sourceFile.append(memberName)
                                        sourceFile.append("->")
                                    }
                                    sourceFile.append("_getPage()")
                                }
                                else {
                                    sourceFile.append("_p")
                                }
                            }
                            else {
                                sourceFile.append("_p")
                            }
                        }
                        else {
                            sourceFile.append("_p")
                        }
                    }
                }
                else {
                    let initializer: Initializer& = getInitializer(constructorCall)
                    if initializer != null {
                        if inRetDeclaration(constructorCall) {
                            sourceFile.append("_rp")
                        }
                        else {
                            sourceFile.append("_p")
                        }
                    }
                }
            }
            else {
                sourceFile.append("_p")
            }
        }

        sourceFile.append(") ")

        true
    }

    function initializerIsBoundOrAssigned(initializerCall: ConstructorCall): bool {
        if initializerCall.parent is PostfixExpression {
            let postfixExpression: PostfixExpression = (initializerCall.parent) as PostfixExpression
            if (postfixExpression.parent.parent.parent is Assignment) || (postfixExpression.parent.parent.parent is Initializer)
                return(true)
            if postfixExpression.parent.parent.parent.parent.parent is ConstructorCall {
                let constructorCall: ConstructorCall = postfixExpression.parent.parent.parent.parent.parent as ConstructorCall
                return(initializerIsBoundOrAssigned(constructorCall))
            }
        }

        false
    }

    function visitThisExpression(thisExpression: ThisExpression) {
        sourceFile.append("this")
    }

    function visitNullExpression(nullExpression: NullExpression) {
        sourceFile.append("nullptr")
    }

    function openElseClause(elseClause: ElseClause): bool {
        indent(level(elseClause))
        sourceFile.append("else")
        if elseClause.alternative is SimpleExpression {
            sourceFile.append("\n    ")
            indent(level(elseClause))
            elseClause.alternative.accept(this)
        }
        else {
            sourceFile.append(" ")
            elseClause.alternative.accept(this)
        }
        
        false
    }

    function openCurliedSwitchBody(curliedSwitchBody: CurliedSwitchBody): bool {
        sourceFile.append(") {\n")

        true
    }

    function closeCurliedSwitchBody(curliedSwitchBody: CurliedSwitchBody) {
        indent(level(curliedSwitchBody) - 1)
        sourceFile.append("}\n")
    }

    function openSwitchCase(switchCase: SwitchCase): bool {
        indent(level(switchCase))

        true
    }

    function openItemCaseLabel(itemCaseLabel: ItemCaseLabel): bool {
        sourceFile.append("case ")

        true
    }

    function visitDefaultCaseLabel(defaultCaseLabel: DefaultCaseLabel) {
        sourceFile.append("default: ")
    }

    function openCaseItem(caseItem: CaseItem): bool {
        sourceFile.append("case ")

        true
    }

    function closeCaseItem(caseItem: CaseItem) {
        sourceFile.append(": ")
    }

    function openIdentifierPattern(identifierPattern: IdentifierPattern): bool {
        if identifierPattern.parent is PatternInitializer {
            let patternInitializer: PatternInitializer = (identifierPattern.parent) as PatternInitializer
            if isCatchingPatternInitializer(patternInitializer)
            {
                sourceFile.append("auto _")
                sourceFile.append(identifierPattern.identifier)
                sourceFile.append("_result")
                return(false)
            }
        }

        if identifierPattern.annotationForType != null {
            identifierPattern.annotationForType.accept(this)

            sourceFile.append(" ")
        }

        sourceFile.append(identifierPattern.identifier)

        false
    }

    function isCatchingPatternInitializer(patternInitializer: PatternInitializer): bool {
        if patternInitializer.initializer != null {
            if patternInitializer.initializer.expression is SimpleExpression {
                let simpleExpression: SimpleExpression = (patternInitializer.initializer.expression) as SimpleExpression
                let postfixExpression: PostfixExpression = simpleExpression.prefixExpression.expression
                if postfixExpression.postfixes != null {
                    let functionCall: FunctionCall =  null
                    if postfixExpression.postfixes.length() > 0 {
                        let postfixes: Postfix[] = postfixExpression.postfixes
                        let postfix: Postfix = postfixes[0]
                        if postfix is FunctionCall {
                            functionCall = postfix as FunctionCall
                        }
                        else {
                            if postfix is MemberExpression {
                                if postfixExpression.postfixes.length() > 1 {
                                    let postfix: Postfix = postfixes[1]
                                    if postfix is FunctionCall {
                                        functionCall = postfix as FunctionCall
                                    }
                                }
                            }
                        }
                    }
                    if functionCall != null {
                        if functionCall.catchClauses != null
                            return(true)
                    }
                }
            }
        }

        false
    }

    function closeExpressionPattern(expressionPattern: ExpressionPattern) {
        if expressionPattern.parent is ItemCaseLabel
            sourceFile.append(": ")
    }

    function openCaseContent(caseContent: CaseContent): bool {
        sourceFile.append("{\n")

        true
    }

    function closeCaseContent(caseContent: CaseContent) {
        var additionalLineFeed: bool = true
        if caseContent.parent is SwitchCase {
            let switchCase: SwitchCase = caseContent.parent as SwitchCase
            if !switchCase.label is DefaultCaseLabel {
                indent(level(caseContent))
                sourceFile.append("break;\n")
            }
            else
                additionalLineFeed = false
        }

        indent(level(caseContent) - 1)
        sourceFile.append("}\n")
        if additionalLineFeed
            sourceFile.append("\n")
    }

    function openType(type: Type): bool {
        if hasArrayPostfix(type) {
            sourceFile.append("_Array<")
        }
        appendCppTypeName(sourceFile, type)
 
       true
    }

    function closeType(type: Type) {
        if hasArrayPostfix(type) {
            sourceFile.append(">")
            if !type.parent is ConstructorCall
                sourceFile.append("*")
        }
        if isClass(type.name) && !hasArrayPostfix(type) && !inTypeQuery(type) && !type.parent is ConstructorCall {
            sourceFile.append("*")
        }
        if inTypeQuery(type)
            sourceFile.append("()")
    }

    function inTypeQuery(type: Type): bool {
        if type.parent is TypeQuery
            return(true)

        false
    }

    function visitPointer(pointer: Pointer) {
        sourceFile.append("*")
    }

    function openInheritance(inheritance: Inheritance): bool {
        false
    }
    
    function buildProjectFileString(program: Program) {
        projectFile.append("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n")
        projectFile.append("<CodeLite_Project Name=\"")
        projectFile.append(program.name)
        projectFile.append("\" InternalType=\"Console\">\n  <Plugins>\n    <Plugin Name=\"qmake\">\n")
        projectFile.append("      <![CDATA[00020001N0005Debug0000000000000001N0007Release000000000000]]>\n    </Plugin>\n")
        projectFile.append("    <Plugin Name=\"CMakePlugin\">\n      <![CDATA[[{\n")
        projectFile.append("  \"name\": \"Debug\",\n  \"enabled\": false,\n  \"buildDirectory\": \"build\",\n")
        projectFile.append("  \"sourceDirectory\": \"$(ProjectPath)\",\n  \"generator\": \"\",\n  \"buildType\": \"\",\n")
        projectFile.append("  \"arguments\": [],\n  \"parentProject\": \"\"\n")
        projectFile.append(" }, {\n")
        projectFile.append("  \"name\": \"Release\",\n")
        projectFile.append("  \"enabled\": false,\n")
        projectFile.append("  \"buildDirectory\": \"build\",\n")
        projectFile.append("  \"sourceDirectory\": \"$(ProjectPath)\",\n")
        projectFile.append("  \"generator\": \"\",\n")
        projectFile.append("  \"buildType\": \"\",\n")
        projectFile.append("  \"arguments\": [],\n")
        projectFile.append("  \"parentProject\": \"\"\n")
        projectFile.append(" }]]]>\n    </Plugin>\n  </Plugins>\n")
        projectFile.append("  <Description/>\n  <Dependencies/>\n")
        projectFile.append("  <VirtualDirectory Name=\"src\">\n")
        {
            let compilationUnits: CompilationUnit[] = program.compilationUnits
            for compilationUnit: CompilationUnit in compilationUnits {
                projectFile.append("    <File Name=\"")
                let fileName: string$ = Path.getFileNameWithoutExtension(compilationUnit.fileName)
                projectFile.append(fileName)
                projectFile.append(".cpp\"/>\n")
                projectFile.append("    <File Name=\"")
                projectFile.append(fileName)
                projectFile.append(".scaly\"/>\n")
            }
        }
        projectFile.append("  </VirtualDirectory>\n  <VirtualDirectory Name=\"include\">\n")
        {
            let compilationUnits: CompilationUnit[] = program.compilationUnits
            for compilationUnit: CompilationUnit in compilationUnits {
                projectFile.append("    <File Name=\"")
                let fileName: string$ = Path.getFileNameWithoutExtension(compilationUnit.fileName)
                projectFile.append(fileName)
                projectFile.append(".h\"/>\n")
            }
        }
        projectFile.append("  </VirtualDirectory>\n  <Dependencies Name=\"Debug\"/>\n  <Dependencies Name=\"Release\"/>\n")
        projectFile.append("  <Settings Type=\"Executable\">\n    <GlobalSettings>\n")
        projectFile.append("      <Compiler Options=\"\" C_Options=\"\" Assembler=\"\">\n")
        projectFile.append("        <IncludePath Value=\".\"/>\n      </Compiler>\n      <Linker Options=\"\">\n")
        projectFile.append("        <LibraryPath Value=\".\"/>\n      </Linker>\n      <ResourceCompiler Options=\"\"/>\n")
        projectFile.append("    </GlobalSettings>\n")
        projectFile.append("    <Configuration Name=\"Debug\" CompilerType=\"GCC\" DebuggerType=\"GNU gdb debugger\"")
        projectFile.append(" Type=\"Executable\" BuildCmpWithGlobalSettings=\"append\" BuildLnkWithGlobalSettings=\"append\"")
        projectFile.append(" BuildResWithGlobalSettings=\"append\">\n")
        projectFile.append("      <Compiler Options=\"-g;-O0;-std=c++11;-Wall\" C_Options=\"-g;-O0;-Wall\" Assembler=\"\"")
        projectFile.append(" Required=\"yes\" PreCompiledHeader=\"\" PCHInCommandLine=\"no\" PCHFlags=\"\" PCHFlagsPolicy=\"0\">\n")
        projectFile.append("        <IncludePath Value=\".\"/>\n        <IncludePath Value=\"../scaly\"/>\n      </Compiler>\n")
        projectFile.append("      <Linker Options=\"\" Required=\"yes\">\n        <LibraryPath Value=\"../Debug\"/>\n")
        projectFile.append("        <Library Value=\"libscaly\"/>\n      </Linker>\n      <ResourceCompiler Options=\"\" Required=\"no\"/>\n")
        projectFile.append("      <General OutputFile=\"$(IntermediateDirectory)/$(ProjectName)\" IntermediateDirectory=\"../Debug\" ")
        projectFile.append("Command=\"./$(ProjectName)\" CommandArguments=\"-o ")
        projectFile.append(program.name)
        projectFile.append(" -d ../")
        projectFile.append(program.name)
        {
            let compilationUnits: CompilationUnit[] = program.compilationUnits
            for compilationUnit: CompilationUnit in compilationUnits {
                projectFile.append(" ../")
                projectFile.append(program.name)
                projectFile.append("/")
                let fileName: string$ = Path.getFileNameWithoutExtension(compilationUnit.fileName)
                projectFile.append(fileName)
                projectFile.append(".scaly")
            }
        }
        projectFile.append("\" UseSeparateDebugArgs=\"no\" DebugArguments=\"\" WorkingDirectory=\"$(IntermediateDirectory)\"")
        projectFile.append(" PauseExecWhenProcTerminates=\"yes\" IsGUIProgram=\"no\" IsEnabled=\"yes\"/>\n")
        projectFile.append("      <Environment EnvVarSetName=\"&lt;Use Defaults&gt;\" DbgSetName=\"&lt;Use Defaults&gt;\">\n")
        projectFile.append("        <![CDATA[]]>\n      </Environment>\n")
        projectFile.append("      <Debugger IsRemote=\"no\" RemoteHostName=\"\" RemoteHostPort=\"\" DebuggerPath=\"\" IsExtended=\"yes\">\n")
        projectFile.append("        <DebuggerSearchPaths/>\n        <PostConnectCommands/>\n        <StartupCommands/>\n      </Debugger>\n")
        projectFile.append("      <PreBuild/>\n      <PostBuild/>\n      <CustomBuild Enabled=\"no\">\n        <RebuildCommand/>\n")
        projectFile.append("        <CleanCommand/>\n        <BuildCommand/>\n        <PreprocessFileCommand/>\n        <SingleFileCommand/>\n")
        projectFile.append("        <MakefileGenerationCommand/>\n        <ThirdPartyToolName>None</ThirdPartyToolName>\n")
        projectFile.append("        <WorkingDirectory/>\n      </CustomBuild>\n      <AdditionalRules>\n")
        projectFile.append("        <CustomPostBuild/>\n        <CustomPreBuild/>\n      </AdditionalRules>\n")
        projectFile.append("      <Completion EnableCpp11=\"no\" EnableCpp14=\"no\">\n        <ClangCmpFlagsC/>\n        <ClangCmpFlags/>\n")
        projectFile.append("        <ClangPP/>\n        <SearchPaths/>\n      </Completion>\n")
        projectFile.append("    </Configuration>\n")
        projectFile.append("    <Configuration Name=\"Release\" CompilerType=\"GCC\" DebuggerType=\"GNU gdb debugger\" Type=\"Executable\"")
        projectFile.append(" BuildCmpWithGlobalSettings=\"append\" BuildLnkWithGlobalSettings=\"append\" BuildResWithGlobalSettings=\"append\">\n")
        projectFile.append("      <Compiler Options=\"-O2;-Wall\" C_Options=\"-O2;-Wall\" Assembler=\"\" Required=\"yes\" PreCompiledHeader=\"\"")
        projectFile.append(" PCHInCommandLine=\"no\" PCHFlags=\"\" PCHFlagsPolicy=\"0\">\n")
        projectFile.append("        <IncludePath Value=\".\"/>\n        <Preprocessor Value=\"NDEBUG\"/>\n")
        projectFile.append("      </Compiler>\n      <Linker Options=\"\" Required=\"yes\">\n")
        projectFile.append("        <LibraryPath Value=\"../Release\"/>\n        <Library Value=\"libscaly\"/>\n      </Linker>\n")
        projectFile.append("      <ResourceCompiler Options=\"\" Required=\"no\"/>\n")
        projectFile.append("      <General OutputFile=\"$(IntermediateDirectory)/$(ProjectName)\" IntermediateDirectory=\"../Release\"")
        projectFile.append(" Command=\"./$(ProjectName)\" CommandArguments=\"\" UseSeparateDebugArgs=\"no\" DebugArguments=\"\"")
        projectFile.append(" WorkingDirectory=\"$(IntermediateDirectory)\" PauseExecWhenProcTerminates=\"yes\" IsGUIProgram=\"no\" IsEnabled=\"yes\"/>\n")
        projectFile.append("      <Environment EnvVarSetName=\"&lt;Use Defaults&gt;\" DbgSetName=\"&lt;Use Defaults&gt;\">\n")
        projectFile.append("        <![CDATA[]]>\n      </Environment>\n")
        projectFile.append("      <Debugger IsRemote=\"no\" RemoteHostName=\"\" RemoteHostPort=\"\" DebuggerPath=\"\" IsExtended=\"yes\">\n")
        projectFile.append("        <DebuggerSearchPaths/>\n        <PostConnectCommands/>\n        <StartupCommands/>\n")
        projectFile.append("      </Debugger>\n      <PreBuild/>\n      <PostBuild/>\n      <CustomBuild Enabled=\"no\">\n")
        projectFile.append("        <RebuildCommand/>\n        <CleanCommand/>\n        <BuildCommand/>\n        <PreprocessFileCommand/>\n")
        projectFile.append("        <SingleFileCommand/>\n        <MakefileGenerationCommand/>\n")
        projectFile.append("        <ThirdPartyToolName>None</ThirdPartyToolName>\n        <WorkingDirectory/>\n")
        projectFile.append("      </CustomBuild>\n      <AdditionalRules>\n        <CustomPostBuild/>\n")
        projectFile.append("        <CustomPreBuild/>\n      </AdditionalRules>\n      <Completion EnableCpp11=\"no\" EnableCpp14=\"no\">\n")
        projectFile.append("        <ClangCmpFlagsC/>\n        <ClangCmpFlags/>\n        <ClangPP/>\n")
        projectFile.append("        <SearchPaths/>\n      </Completion>\n    </Configuration>\n  </Settings>\n")
        projectFile.append("  <Dependencies Name=\"Debug\"/>\n  <Dependencies Name=\"Release\"/>\n</CodeLite_Project>\n")
    }

    function collectInheritances(program: Program) {
        let compilationUnits: CompilationUnit[] = program.compilationUnits
        for compilationUnit: CompilationUnit in compilationUnits
            collectInheritancesInCompilationUnit(compilationUnit)
    }

    function collectInheritancesInCompilationUnit(compilationUnit: CompilationUnit) {
        if compilationUnit.statements != null {
            let statements: Statement[] = compilationUnit.statements
            for statement: Statement in statements {
                if statement is ClassDeclaration {
                    let classDeclaration: ClassDeclaration = statement as ClassDeclaration
                    classes.push(classDeclaration.name)
                    if classDeclaration.typeInheritanceClause != null {
                        let inheritanceClause: TypeInheritanceClause  = classDeclaration.typeInheritanceClause
                        let inheritances: Inheritance[] = inheritanceClause.inheritances
                        for inheritance: Inheritance in inheritances {
                            registerInheritance(classDeclaration.name, inheritance.type.name)
                        }
                    }
                }
            }
        }
    }

    function registerInheritance(className: string, baseName: string) {
        var inherit: Inherits@inherits = null
        for inh: Inherits in inherits {
            if inh.name.equals(baseName)
             inherit = inh
        }

        if inherit == null {
            inherit = new Inherits(baseName)
            inherits.push(inherit)
        }
        inherit.inheritors.push(className)
    }
}
