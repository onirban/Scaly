class SyntaxNode {

    init(start: Position, end: Position) {
        start = start
        end = end
    }
    
    let start: Position
    let end: Position
}

class Program : SyntaxNode {

    init() {
        super.init(Position(0, 0), Position(0, 0))
    }

    function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenProgram(this)
        for node in compilationUnits! {
            node.Accept(visitor)
        }
        visitor.CloseProgram(this)
    }

    let name: String?
    let compilationUnits: [CompilationUnit]?
}

class CompilationUnit : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenCompilationUnit(this)
        for node in statements! {
            node.Accept(visitor)
        }
        visitor.CloseCompilationUnit(this)
    }

    let statements: [StatementWithSemicolon]?
    let fileName: String
}

class StatementWithSemicolon : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenStatementWithSemicolon(this)
        statement!.Accept(visitor)
        visitor.CloseStatementWithSemicolon(this)
    }

    let statement: Statement?
}

class Statement : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenStatement(this)
        visitor.CloseStatement(this)
    }

}

class Declaration : Statement {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenDeclaration(this)
        visitor.CloseDeclaration(this)
    }

}

class UseDeclaration : Declaration {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenUseDeclaration(this)
        importModule!.Accept(visitor)
        if importExtensions != nil {
            for node in importExtensions! {
                node.Accept(visitor)
            }
        }
        visitor.CloseUseDeclaration(this)
    }

    let importModule: PathItem?
    let importExtensions: [PathIdentifier]?
}

class PathIdentifier : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenPathIdentifier(this)
        extension!.Accept(visitor)
        visitor.ClosePathIdentifier(this)
    }

    let extension: PathItem?
}

class PathItem : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenPathItem(this)
        visitor.ClosePathItem(this)
    }

    let name: String?
}

class Initializer : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenInitializer(this)
        expression!.Accept(visitor)
        visitor.CloseInitializer(this)
    }

    let expression: Expression?
}

class ConstantDeclaration : Declaration {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenConstantDeclaration(this)
        initializer!.Accept(visitor)
        visitor.CloseConstantDeclaration(this)
    }

    let initializer: BindingInitializer?
}

class VariableDeclaration : Declaration {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenVariableDeclaration(this)
        initializer!.Accept(visitor)
        visitor.CloseVariableDeclaration(this)
    }

    let initializer: BindingInitializer?
}

class BindingInitializer : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenBindingInitializer(this)
        initializer!.Accept(visitor)
        if additionalInitializers != nil {
            for node in additionalInitializers! {
                node.Accept(visitor)
            }
        }
        visitor.CloseBindingInitializer(this)
    }

    let initializer: PatternInitializer?
    let additionalInitializers: [AdditionalInitializer]?
}

class PatternInitializer : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenPatternInitializer(this)
        pattern!.Accept(visitor)
        if initializer != nil {
            initializer!.Accept(visitor)
        }
        visitor.ClosePatternInitializer(this)
    }

    let pattern: Pattern?
    let initializer: Initializer?
}

class AdditionalInitializer : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenAdditionalInitializer(this)
        pattern!.Accept(visitor)
        visitor.CloseAdditionalInitializer(this)
    }

    let pattern: PatternInitializer?
}

class FunctionDeclaration : Declaration {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenFunctionDeclaration(this)
        if modifiers != nil {
            for node in modifiers! {
                node.Accept(visitor)
            }
        }
        name!.Accept(visitor)
        signature!.Accept(visitor)
        body!.Accept(visitor)
        visitor.CloseFunctionDeclaration(this)
    }

    let modifiers: [Modifier]?
    let name: FunctionName?
    let signature: FunctionSignature?
    let body: Expression?
}

class InitializerDeclaration : Declaration {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenInitializerDeclaration(this)
        if modifiers != nil {
            for node in modifiers! {
                node.Accept(visitor)
            }
        }
        parameterClause!.Accept(visitor)
        if throwsClause != nil {
            throwsClause!.Accept(visitor)
        }
        body!.Accept(visitor)
        visitor.CloseInitializerDeclaration(this)
    }

    let modifiers: [Modifier]?
    let parameterClause: ParameterClause?
    let throwsClause: ThrowsClause?
    let body: Expression?
}

class Modifier : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenModifier(this)
        visitor.CloseModifier(this)
    }

}

class Override : Modifier {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenOverride(this)
        visitor.CloseOverride(this)
    }

}

class StaticWord : Modifier {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenStaticWord(this)
        visitor.CloseStaticWord(this)
    }

}

class FunctionName : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenFunctionName(this)
        visitor.CloseFunctionName(this)
    }

}

class IdentifierFunctionName : FunctionName {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenIdentifierFunctionName(this)
        visitor.CloseIdentifierFunctionName(this)
    }

    let name: String?
}

class FunctionSignature : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenFunctionSignature(this)
        parameterClause!.Accept(visitor)
        if result != nil {
            result!.Accept(visitor)
        }
        if throwsClause != nil {
            throwsClause!.Accept(visitor)
        }
        visitor.CloseFunctionSignature(this)
    }

    let parameterClause: ParameterClause?
    let result: FunctionResult?
    let throwsClause: ThrowsClause?
}

class FunctionResult : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenFunctionResult(this)
        resultType!.Accept(visitor)
        visitor.CloseFunctionResult(this)
    }

    let resultType: Type?
}

class ParameterClause : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenParameterClause(this)
        if parameters != nil {
            for node in parameters! {
                node.Accept(visitor)
            }
        }
        visitor.CloseParameterClause(this)
    }

    let parameters: [Parameter]?
}

class Parameter : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenParameter(this)
        visitor.CloseParameter(this)
    }

}

class ConstParameter : Parameter {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenConstParameter(this)
        parameterType!.Accept(visitor)
        visitor.CloseConstParameter(this)
    }

    let parameterName: String?
    let parameterType: Type?
}

class VarParameter : Parameter {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenVarParameter(this)
        parameterType!.Accept(visitor)
        visitor.CloseVarParameter(this)
    }

    let parameterName: String?
    let parameterType: Type?
}

class ThrowsClause : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenThrowsClause(this)
        throwsType!.Accept(visitor)
        visitor.CloseThrowsClause(this)
    }

    let throwsType: Type?
}

class EnumDeclaration : Declaration {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenEnumDeclaration(this)
        for node in members! {
            node.Accept(visitor)
        }
        visitor.CloseEnumDeclaration(this)
    }

    let name: String?
    let members: [EnumMember]?
}

class EnumMember : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenEnumMember(this)
        enumCase!.Accept(visitor)
        if additionalCases != nil {
            for node in additionalCases! {
                node.Accept(visitor)
            }
        }
        if tupleType != nil {
            tupleType!.Accept(visitor)
        }
        visitor.CloseEnumMember(this)
    }

    let enumCase: EnumCase?
    let additionalCases: [AdditionalCase]?
    let tupleType: TupleType?
}

class TupleType : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenTupleType(this)
        tupleType!.Accept(visitor)
        if additionalTypes != nil {
            for node in additionalTypes! {
                node.Accept(visitor)
            }
        }
        visitor.CloseTupleType(this)
    }

    let tupleType: Type?
    let additionalTypes: [AdditionalType]?
}

class AdditionalType : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenAdditionalType(this)
        enumCase!.Accept(visitor)
        visitor.CloseAdditionalType(this)
    }

    let enumCase: Type?
}

class EnumCase : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenEnumCase(this)
        visitor.CloseEnumCase(this)
    }

    let name: String?
}

class AdditionalCase : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenAdditionalCase(this)
        enumCase!.Accept(visitor)
        visitor.CloseAdditionalCase(this)
    }

    let enumCase: EnumCase?
}

class ClassDeclaration : Declaration {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenClassDeclaration(this)
        if genericArgumentClause != nil {
            genericArgumentClause!.Accept(visitor)
        }
        if typeInheritanceClause != nil {
            typeInheritanceClause!.Accept(visitor)
        }
        if members != nil {
            for node in members! {
                node.Accept(visitor)
            }
        }
        visitor.CloseClassDeclaration(this)
    }

    let name: String?
    let genericArgumentClause: GenericArgumentClause?
    let typeInheritanceClause: TypeInheritanceClause?
    let members: [ClassMember]?
}

class GenericArgumentClause : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenGenericArgumentClause(this)
        for node in genericParameters! {
            node.Accept(visitor)
        }
        visitor.CloseGenericArgumentClause(this)
    }

    let genericParameters: [GenericParameter]?
}

class GenericParameter : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenGenericParameter(this)
        visitor.CloseGenericParameter(this)
    }

    let typeName: String?
}

class ClassMember : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenClassMember(this)
        declaration!.Accept(visitor)
        visitor.CloseClassMember(this)
    }

    let declaration: Declaration?
}

class Expression : Statement {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenExpression(this)
        visitor.CloseExpression(this)
    }

}

class CodeBlock : Expression {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenCodeBlock(this)
        for node in statements! {
            node.Accept(visitor)
        }
        visitor.CloseCodeBlock(this)
    }

    let statements: [StatementWithSemicolon]?
}

class SimpleExpression : Expression {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenSimpleExpression(this)
        prefixExpression!.Accept(visitor)
        if binaryOps != nil {
            for node in binaryOps! {
                node.Accept(visitor)
            }
        }
        visitor.CloseSimpleExpression(this)
    }

    let prefixExpression: PrefixExpression?
    let binaryOps: [BinaryOp]?
}

class PrefixExpression : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenPrefixExpression(this)
        expression!.Accept(visitor)
        visitor.ClosePrefixExpression(this)
    }

    let prefixOperator: String?
    let expression: PostfixExpression?
}

class PostfixExpression : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenPostfixExpression(this)
        primaryExpression!.Accept(visitor)
        if postfixes != nil {
            for node in postfixes! {
                node.Accept(visitor)
            }
        }
        visitor.ClosePostfixExpression(this)
    }

    let primaryExpression: PrimaryExpression?
    let postfixes: [Postfix]?
}

class BinaryOp : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenBinaryOp(this)
        visitor.CloseBinaryOp(this)
    }

}

class BinaryOperation : BinaryOp {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenBinaryOperation(this)
        expression!.Accept(visitor)
        visitor.CloseBinaryOperation(this)
    }

    let binaryOperator: String?
    let expression: PrefixExpression?
}

class Assignment : BinaryOp {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenAssignment(this)
        expression!.Accept(visitor)
        visitor.CloseAssignment(this)
    }

    let expression: PrefixExpression?
}

class TypeQuery : BinaryOp {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenTypeQuery(this)
        objectType!.Accept(visitor)
        visitor.CloseTypeQuery(this)
    }

    let objectType: Type?
}

class TypeCast : BinaryOp {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenTypeCast(this)
        objectType!.Accept(visitor)
        visitor.CloseTypeCast(this)
    }

    let objectType: Type?
}

class CatchClause : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenCatchClause(this)
        catchPattern!.Accept(visitor)
        if bindingPattern != nil {
            bindingPattern!.Accept(visitor)
        }
        expression!.Accept(visitor)
        visitor.CloseCatchClause(this)
    }

    let catchPattern: CatchPattern?
    let bindingPattern: TuplePattern?
    let expression: Expression?
}

class CatchPattern : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenCatchPattern(this)
        visitor.CloseCatchPattern(this)
    }

}

class WildCardCatchPattern : CatchPattern {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenWildCardCatchPattern(this)
        pattern!.Accept(visitor)
        visitor.CloseWildCardCatchPattern(this)
    }

    let pattern: WildcardPattern?
}

class PathItemCatchPattern : CatchPattern {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenPathItemCatchPattern(this)
        catchCase!.Accept(visitor)
        if catchCaseExtensions != nil {
            for node in catchCaseExtensions! {
                node.Accept(visitor)
            }
        }
        visitor.ClosePathItemCatchPattern(this)
    }

    let catchCase: PathItem?
    let catchCaseExtensions: [PathIdentifier]?
}

class Postfix : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenPostfix(this)
        visitor.ClosePostfix(this)
    }

}

class OperatorPostfix : Postfix {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenOperatorPostfix(this)
        visitor.CloseOperatorPostfix(this)
    }

    let postfixOperator: String?
}

class FunctionCall : Postfix {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenFunctionCall(this)
        arguments!.Accept(visitor)
        if catchClauses != nil {
            for node in catchClauses! {
                node.Accept(visitor)
            }
        }
        visitor.CloseFunctionCall(this)
    }

    let arguments: ParenthesizedExpression?
    let catchClauses: [CatchClause]?
}

class ExplicitMemberExpression : Postfix {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenExplicitMemberExpression(this)
        memberPostfix!.Accept(visitor)
        visitor.CloseExplicitMemberExpression(this)
    }

    let memberPostfix: MemberPostfix?
}

class Subscript : Postfix {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenSubscript(this)
        for node in expressions! {
            node.Accept(visitor)
        }
        visitor.CloseSubscript(this)
    }

    let expressions: [ExpressionElement]?
}

class ExpressionElement : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenExpressionElement(this)
        expression!.Accept(visitor)
        visitor.CloseExpressionElement(this)
    }

    let expression: Expression?
}

class MemberPostfix : ExplicitMemberExpression {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenMemberPostfix(this)
        visitor.CloseMemberPostfix(this)
    }

}

class NamedMemberPostfix : MemberPostfix {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenNamedMemberPostfix(this)
        identifier!.Accept(visitor)
        visitor.CloseNamedMemberPostfix(this)
    }

    let identifier: IdentifierExpression?
}

class PrimaryExpression : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenPrimaryExpression(this)
        visitor.ClosePrimaryExpression(this)
    }

}

class ParenthesizedExpression : PrimaryExpression {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenParenthesizedExpression(this)
        if expressionElements != nil {
            for node in expressionElements! {
                node.Accept(visitor)
            }
        }
        visitor.CloseParenthesizedExpression(this)
    }

    let expressionElements: [ExpressionElement]?
}

class LiteralExpression : PrimaryExpression {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenLiteralExpression(this)
        visitor.CloseLiteralExpression(this)
    }

    let literal: Literal?
}

class IdentifierExpression : PrimaryExpression {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenIdentifierExpression(this)
        visitor.CloseIdentifierExpression(this)
    }

    let name: String?
}

class IfExpression : PrimaryExpression {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenIfExpression(this)
        condition!.Accept(visitor)
        consequent!.Accept(visitor)
        if elseClause != nil {
            elseClause!.Accept(visitor)
        }
        visitor.CloseIfExpression(this)
    }

    let condition: Expression?
    let consequent: Expression?
    let elseClause: ElseClause?
}

class ElseClause : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenElseClause(this)
        alternative!.Accept(visitor)
        visitor.CloseElseClause(this)
    }

    let alternative: Expression?
}

class SwitchExpression : PrimaryExpression {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenSwitchExpression(this)
        expression!.Accept(visitor)
        body!.Accept(visitor)
        visitor.CloseSwitchExpression(this)
    }

    let expression: Expression?
    let body: SwitchBody?
}

class SwitchBody : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenSwitchBody(this)
        visitor.CloseSwitchBody(this)
    }

}

class CurliedSwitchBody : SwitchBody {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenCurliedSwitchBody(this)
        for node in cases! {
            node.Accept(visitor)
        }
        visitor.CloseCurliedSwitchBody(this)
    }

    let cases: [SwitchCase]?
}

class NakedSwitchBody : SwitchBody {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenNakedSwitchBody(this)
        for node in cases! {
            node.Accept(visitor)
        }
        visitor.CloseNakedSwitchBody(this)
    }

    let cases: [SwitchCase]?
}

class SwitchCase : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenSwitchCase(this)
        label!.Accept(visitor)
        content!.Accept(visitor)
        visitor.CloseSwitchCase(this)
    }

    let label: CaseLabel?
    let content: CaseContent?
}

class CaseLabel : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenCaseLabel(this)
        visitor.CloseCaseLabel(this)
    }

}

class ItemCaseLabel : CaseLabel {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenItemCaseLabel(this)
        pattern!.Accept(visitor)
        if additionalPatterns != nil {
            for node in additionalPatterns! {
                node.Accept(visitor)
            }
        }
        visitor.CloseItemCaseLabel(this)
    }

    let pattern: Pattern?
    let additionalPatterns: [CaseItem]?
}

class CaseItem : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenCaseItem(this)
        pattern!.Accept(visitor)
        visitor.CloseCaseItem(this)
    }

    let pattern: Pattern?
}

class ForExpression : PrimaryExpression {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenForExpression(this)
        loop!.Accept(visitor)
        visitor.CloseForExpression(this)
    }

    let loop: ForLoop?
}

class ForLoop : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenForLoop(this)
        visitor.CloseForLoop(this)
    }

}

class ForEach : ForLoop {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenForEach(this)
        pattern!.Accept(visitor)
        expression!.Accept(visitor)
        code!.Accept(visitor)
        visitor.CloseForEach(this)
    }

    let pattern: Pattern?
    let expression: Expression?
    let code: Expression?
}

class PlainFor : ForLoop {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenPlainFor(this)
        if forInit != nil {
            forInit!.Accept(visitor)
        }
        if forCheck != nil {
            forCheck!.Accept(visitor)
        }
        forNext!.Accept(visitor)
        code!.Accept(visitor)
        visitor.ClosePlainFor(this)
    }

    let forInit: VariableDeclaration?
    let forCheck: Expression?
    let forNext: Expression?
    let code: Expression?
}

class ReturnExpression : PrimaryExpression {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenReturnExpression(this)
        if expression != nil {
            expression!.Accept(visitor)
        }
        visitor.CloseReturnExpression(this)
    }

    let expression: Expression?
}

class ThrowExpression : PrimaryExpression {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenThrowExpression(this)
        if expression != nil {
            expression!.Accept(visitor)
        }
        visitor.CloseThrowExpression(this)
    }

    let expression: Expression?
}

class BreakExpression : PrimaryExpression {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenBreakExpression(this)
        if expression != nil {
            expression!.Accept(visitor)
        }
        visitor.CloseBreakExpression(this)
    }

    let expression: Expression?
}

class Pattern : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenPattern(this)
        visitor.ClosePattern(this)
    }

}

class WildcardPattern : Pattern {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenWildcardPattern(this)
        visitor.CloseWildcardPattern(this)
    }

}

class IdentifierPattern : Pattern {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenIdentifierPattern(this)
        if typeAnnotation != nil {
            typeAnnotation!.Accept(visitor)
        }
        visitor.CloseIdentifierPattern(this)
    }

    let identifier: String?
    let typeAnnotation: TypeAnnotation?
}

class TuplePattern : Pattern {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenTuplePattern(this)
        for node in elements! {
            node.Accept(visitor)
        }
        visitor.CloseTuplePattern(this)
    }

    let elements: [TuplePatternElement]?
}

class TuplePatternElement : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenTuplePatternElement(this)
        pattern!.Accept(visitor)
        visitor.CloseTuplePatternElement(this)
    }

    let pattern: Pattern?
}

class ExpressionPattern : Pattern {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenExpressionPattern(this)
        expression!.Accept(visitor)
        visitor.CloseExpressionPattern(this)
    }

    let expression: Expression?
}

class DefaultCaseLabel : CaseLabel {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenDefaultCaseLabel(this)
        visitor.CloseDefaultCaseLabel(this)
    }

}

class CaseContent : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenCaseContent(this)
        visitor.CloseCaseContent(this)
    }

}

class BlockCaseContent : CaseContent {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenBlockCaseContent(this)
        for node in statements! {
            node.Accept(visitor)
        }
        visitor.CloseBlockCaseContent(this)
    }

    let statements: [StatementWithSemicolon]?
}

class EmptyCaseContent : CaseContent {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenEmptyCaseContent(this)
        visitor.CloseEmptyCaseContent(this)
    }

}

class InitializerCall : PrimaryExpression {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenInitializerCall(this)
        typeToInitialize!.Accept(visitor)
        arguments!.Accept(visitor)
        if catchClauses != nil {
            for node in catchClauses! {
                node.Accept(visitor)
            }
        }
        visitor.CloseInitializerCall(this)
    }

    let typeToInitialize: Type?
    let arguments: ParenthesizedExpression?
    let catchClauses: [CatchClause]?
}

class ThisExpression : PrimaryExpression {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenThisExpression(this)
        visitor.CloseThisExpression(this)
    }

}

class ThisDot : ThisExpression {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenThisDot(this)
        member!.Accept(visitor)
        visitor.CloseThisDot(this)
    }

    let member: CommonThisMember?
}

class ThisSubscript : ThisExpression {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenThisSubscript(this)
        subscript!.Accept(visitor)
        visitor.CloseThisSubscript(this)
    }

    let subscript: Subscript?
}

class ThisWord : ThisExpression {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenThisWord(this)
        visitor.CloseThisWord(this)
    }

}

class CommonThisMember : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenCommonThisMember(this)
        visitor.CloseCommonThisMember(this)
    }

}

class ThisInit : CommonThisMember {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenThisInit(this)
        visitor.CloseThisInit(this)
    }

}

class ThisMember : CommonThisMember {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenThisMember(this)
        visitor.CloseThisMember(this)
    }

    let name: String?
}

class SuperExpression : PrimaryExpression {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenSuperExpression(this)
        visitor.CloseSuperExpression(this)
    }

}

class SuperDot : SuperExpression {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenSuperDot(this)
        member!.Accept(visitor)
        visitor.CloseSuperDot(this)
    }

    let member: CommonSuperMember?
}

class SuperSubscript : SuperExpression {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenSuperSubscript(this)
        subscript!.Accept(visitor)
        visitor.CloseSuperSubscript(this)
    }

    let subscript: Subscript?
}

class CommonSuperMember : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenCommonSuperMember(this)
        visitor.CloseCommonSuperMember(this)
    }

}

class SuperInit : CommonSuperMember {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenSuperInit(this)
        visitor.CloseSuperInit(this)
    }

}

class SuperMember : CommonSuperMember {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenSuperMember(this)
        visitor.CloseSuperMember(this)
    }

    let name: String?
}

class Type : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenType(this)
        visitor.CloseType(this)
    }

}

class TypeAnnotation : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenTypeAnnotation(this)
        typeAnnotation!.Accept(visitor)
        visitor.CloseTypeAnnotation(this)
    }

    let typeAnnotation: Type?
}

class TypeIdentifier : Type {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenTypeIdentifier(this)
        if subType != nil {
            subType!.Accept(visitor)
        }
        if postfixes != nil {
            for node in postfixes! {
                node.Accept(visitor)
            }
        }
        visitor.CloseTypeIdentifier(this)
    }

    let name: String?
    let subType: SubtypeIdentifier?
    let postfixes: [TypePostfix]?
}

class SubtypeIdentifier : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenSubtypeIdentifier(this)
        typeIdentifier!.Accept(visitor)
        visitor.CloseSubtypeIdentifier(this)
    }

    let typeIdentifier: TypeIdentifier?
}

class TypePostfix : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenTypePostfix(this)
        visitor.CloseTypePostfix(this)
    }

}

class ArrayType : Type {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenArrayType(this)
        elementType!.Accept(visitor)
        if postfixes != nil {
            for node in postfixes! {
                node.Accept(visitor)
            }
        }
        visitor.CloseArrayType(this)
    }

    let elementType: Type?
    let postfixes: [TypePostfix]?
}

class OptionalType : TypePostfix {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenOptionalType(this)
        visitor.CloseOptionalType(this)
    }

}

class TypeInheritanceClause : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenTypeInheritanceClause(this)
        if inheritances != nil {
            for node in inheritances! {
                node.Accept(visitor)
            }
        }
        visitor.CloseTypeInheritanceClause(this)
    }

    let inheritances: [Inheritance]?
}

class Inheritance : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function Accept(mutable visitor: SyntaxVisitor) {
        visitor.OpenInheritance(this)
        name!.Accept(visitor)
        visitor.CloseInheritance(this)
    }

    let name: TypeIdentifier?
}
