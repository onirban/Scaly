class SyntaxNode {

    init(start: Position, end: Position) {
        start = start
        end = end
    }

    let start: Position
    let end: Position
}

class Program : SyntaxNode {

    init(name: String, directory: String, compilationUnits: [CompilationUnit]) {
        super.init(Position(0, 0), Position(0, 0))
    }

    function accept(mutable visitor: SyntaxVisitor) {
        visitor.openProgram(this)
        for node in compilationUnits! {
            node.accept(visitor)
        }
        visitor.closeProgram(this)
    }

    let name: String?
    let directory: String?
    let compilationUnits: [CompilationUnit]?
}

class CompilationUnit : SyntaxNode {

    init(statements: [StatementWithSemicolon], start: Position, end: Position) {
        super.init(start, end)
    }

    function accept(mutable visitor: SyntaxVisitor) {
        visitor.openCompilationUnit(this)
        if statements != nil {
            for node in statements! {
                node.accept(visitor)
            }
        }
        visitor.closeCompilationUnit(this)
    }

    let statements: [StatementWithSemicolon]?
    let fileName: String
}

class StatementWithSemicolon : SyntaxNode {

    init(statement: Statement, start: Position, end: Position) {
        super.init(start, end)
    }

    function accept(mutable visitor: SyntaxVisitor) {
        visitor.openStatementWithSemicolon(this)
        statement!.accept(visitor)
        visitor.closeStatementWithSemicolon(this)
    }

    let statement: Statement?
}

class Statement : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function accept(mutable visitor: SyntaxVisitor) {
        visitor.openStatement(this)
        visitor.closeStatement(this)
    }

}

class Declaration : Statement {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openDeclaration(this)
        visitor.closeDeclaration(this)
    }

}

class UseDeclaration : Declaration {

    init(importModule: PathItem, importExtensions: [PathIdentifier], start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openUseDeclaration(this)
        importModule!.accept(visitor)
        if importExtensions != nil {
            for node in importExtensions! {
                node.accept(visitor)
            }
        }
        visitor.closeUseDeclaration(this)
    }

    let importModule: PathItem?
    let importExtensions: [PathIdentifier]?
}

class ConstantDeclaration : Declaration {

    init(initializer: BindingInitializer, start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openConstantDeclaration(this)
        initializer!.accept(visitor)
        visitor.closeConstantDeclaration(this)
    }

    let initializer: BindingInitializer?
}

class VariableDeclaration : Declaration {

    init(initializer: BindingInitializer, start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openVariableDeclaration(this)
        initializer!.accept(visitor)
        visitor.closeVariableDeclaration(this)
    }

    let initializer: BindingInitializer?
}

class FunctionDeclaration : Declaration {

    init(modifiers: [Modifier], name: FunctionName, signature: FunctionSignature, body: Expression, start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openFunctionDeclaration(this)
        if modifiers != nil {
            for node in modifiers! {
                node.accept(visitor)
            }
        }
        name!.accept(visitor)
        signature!.accept(visitor)
        if body != nil {
            body!.accept(visitor)
        }
        visitor.closeFunctionDeclaration(this)
    }

    let modifiers: [Modifier]?
    let name: FunctionName?
    let signature: FunctionSignature?
    let body: Expression?
}

class EnumDeclaration : Declaration {

    init(name: String, members: [EnumMember], start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openEnumDeclaration(this)
        for node in members! {
            node.accept(visitor)
        }
        visitor.closeEnumDeclaration(this)
    }

    let name: String?
    let members: [EnumMember]?
}

class ClassDeclaration : Declaration {

    init(name: String, genericArgumentClause: GenericArgumentClause, typeInheritanceClause: TypeInheritanceClause, body: ClassBody, start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openClassDeclaration(this)
        if genericArgumentClause != nil {
            genericArgumentClause!.accept(visitor)
        }
        if typeInheritanceClause != nil {
            typeInheritanceClause!.accept(visitor)
        }
        if body != nil {
            body!.accept(visitor)
        }
        visitor.closeClassDeclaration(this)
    }

    let name: String?
    let genericArgumentClause: GenericArgumentClause?
    let typeInheritanceClause: TypeInheritanceClause?
    let body: ClassBody?
}

class InitializerDeclaration : Declaration {

    init(modifiers: [Modifier], parameterClause: ParameterClause, throwsClause: ThrowsClause, body: Expression, start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openInitializerDeclaration(this)
        if modifiers != nil {
            for node in modifiers! {
                node.accept(visitor)
            }
        }
        parameterClause!.accept(visitor)
        if throwsClause != nil {
            throwsClause!.accept(visitor)
        }
        body!.accept(visitor)
        visitor.closeInitializerDeclaration(this)
    }

    let modifiers: [Modifier]?
    let parameterClause: ParameterClause?
    let throwsClause: ThrowsClause?
    let body: Expression?
}

class Expression : Statement {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openExpression(this)
        visitor.closeExpression(this)
    }

}

class CodeBlock : Expression {

    init(statements: [StatementWithSemicolon], start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openCodeBlock(this)
        for node in statements! {
            node.accept(visitor)
        }
        visitor.closeCodeBlock(this)
    }

    let statements: [StatementWithSemicolon]?
}

class SimpleExpression : Expression {

    init(prefixExpression: PrefixExpression, binaryOps: [BinaryOp], start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openSimpleExpression(this)
        prefixExpression!.accept(visitor)
        if binaryOps != nil {
            for node in binaryOps! {
                node.accept(visitor)
            }
        }
        visitor.closeSimpleExpression(this)
    }

    let prefixExpression: PrefixExpression?
    let binaryOps: [BinaryOp]?
}

class PathIdentifier : SyntaxNode {

    init(extension: PathItem, start: Position, end: Position) {
        super.init(start, end)
    }

    function accept(mutable visitor: SyntaxVisitor) {
        visitor.openPathIdentifier(this)
        extension!.accept(visitor)
        visitor.closePathIdentifier(this)
    }

    let extension: PathItem?
}

class PathItem : SyntaxNode {

    init(name: String, start: Position, end: Position) {
        super.init(start, end)
    }

    function accept(mutable visitor: SyntaxVisitor) {
        visitor.openPathItem(this)
        visitor.closePathItem(this)
    }

    let name: String?
}

class Initializer : SyntaxNode {

    init(expression: Expression, start: Position, end: Position) {
        super.init(start, end)
    }

    function accept(mutable visitor: SyntaxVisitor) {
        visitor.openInitializer(this)
        expression!.accept(visitor)
        visitor.closeInitializer(this)
    }

    let expression: Expression?
}

class BindingInitializer : SyntaxNode {

    init(initializer: PatternInitializer, additionalInitializers: [AdditionalInitializer], start: Position, end: Position) {
        super.init(start, end)
    }

    function accept(mutable visitor: SyntaxVisitor) {
        visitor.openBindingInitializer(this)
        initializer!.accept(visitor)
        if additionalInitializers != nil {
            for node in additionalInitializers! {
                node.accept(visitor)
            }
        }
        visitor.closeBindingInitializer(this)
    }

    let initializer: PatternInitializer?
    let additionalInitializers: [AdditionalInitializer]?
}

class PatternInitializer : SyntaxNode {

    init(pattern: Pattern, initializer: Initializer, start: Position, end: Position) {
        super.init(start, end)
    }

    function accept(mutable visitor: SyntaxVisitor) {
        visitor.openPatternInitializer(this)
        pattern!.accept(visitor)
        if initializer != nil {
            initializer!.accept(visitor)
        }
        visitor.closePatternInitializer(this)
    }

    let pattern: Pattern?
    let initializer: Initializer?
}

class AdditionalInitializer : SyntaxNode {

    init(pattern: PatternInitializer, start: Position, end: Position) {
        super.init(start, end)
    }

    function accept(mutable visitor: SyntaxVisitor) {
        visitor.openAdditionalInitializer(this)
        pattern!.accept(visitor)
        visitor.closeAdditionalInitializer(this)
    }

    let pattern: PatternInitializer?
}

class Modifier : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function accept(mutable visitor: SyntaxVisitor) {
        visitor.openModifier(this)
        visitor.closeModifier(this)
    }

}

class OverrideWord : Modifier {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openOverrideWord(this)
        visitor.closeOverrideWord(this)
    }

}

class StaticWord : Modifier {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openStaticWord(this)
        visitor.closeStaticWord(this)
    }

}

class FunctionName : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function accept(mutable visitor: SyntaxVisitor) {
        visitor.openFunctionName(this)
        visitor.closeFunctionName(this)
    }

}

class IdentifierFunction : FunctionName {

    init(name: String, start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openIdentifierFunction(this)
        visitor.closeIdentifierFunction(this)
    }

    let name: String?
}

class FunctionSignature : SyntaxNode {

    init(parameterClause: ParameterClause, result: FunctionResult, throwsClause: ThrowsClause, start: Position, end: Position) {
        super.init(start, end)
    }

    function accept(mutable visitor: SyntaxVisitor) {
        visitor.openFunctionSignature(this)
        parameterClause!.accept(visitor)
        if result != nil {
            result!.accept(visitor)
        }
        if throwsClause != nil {
            throwsClause!.accept(visitor)
        }
        visitor.closeFunctionSignature(this)
    }

    let parameterClause: ParameterClause?
    let result: FunctionResult?
    let throwsClause: ThrowsClause?
}

class FunctionResult : SyntaxNode {

    init(resultType: Type, start: Position, end: Position) {
        super.init(start, end)
    }

    function accept(mutable visitor: SyntaxVisitor) {
        visitor.openFunctionResult(this)
        resultType!.accept(visitor)
        visitor.closeFunctionResult(this)
    }

    let resultType: Type?
}

class ParameterClause : SyntaxNode {

    init(parameters: [Parameter], start: Position, end: Position) {
        super.init(start, end)
    }

    function accept(mutable visitor: SyntaxVisitor) {
        visitor.openParameterClause(this)
        if parameters != nil {
            for node in parameters! {
                node.accept(visitor)
            }
        }
        visitor.closeParameterClause(this)
    }

    let parameters: [Parameter]?
}

class Parameter : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function accept(mutable visitor: SyntaxVisitor) {
        visitor.openParameter(this)
        visitor.closeParameter(this)
    }

}

class ConstParameter : Parameter {

    init(name: String, parameterType: Type, start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openConstParameter(this)
        parameterType!.accept(visitor)
        visitor.closeConstParameter(this)
    }

    let name: String?
    let parameterType: Type?
}

class VarParameter : Parameter {

    init(name: String, parameterType: Type, start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openVarParameter(this)
        parameterType!.accept(visitor)
        visitor.closeVarParameter(this)
    }

    let name: String?
    let parameterType: Type?
}

class ThrowsClause : SyntaxNode {

    init(throwsType: Type, start: Position, end: Position) {
        super.init(start, end)
    }

    function accept(mutable visitor: SyntaxVisitor) {
        visitor.openThrowsClause(this)
        throwsType!.accept(visitor)
        visitor.closeThrowsClause(this)
    }

    let throwsType: Type?
}

class EnumMember : SyntaxNode {

    init(enumCase: EnumCase, additionalCases: [AdditionalCase], typeOfTuple: TupleType, start: Position, end: Position) {
        super.init(start, end)
    }

    function accept(mutable visitor: SyntaxVisitor) {
        visitor.openEnumMember(this)
        enumCase!.accept(visitor)
        if additionalCases != nil {
            for node in additionalCases! {
                node.accept(visitor)
            }
        }
        if typeOfTuple != nil {
            typeOfTuple!.accept(visitor)
        }
        visitor.closeEnumMember(this)
    }

    let enumCase: EnumCase?
    let additionalCases: [AdditionalCase]?
    let typeOfTuple: TupleType?
}

class TupleType : SyntaxNode {

    init(typeOfTuple: Type, additionalTypes: [AdditionalType], start: Position, end: Position) {
        super.init(start, end)
    }

    function accept(mutable visitor: SyntaxVisitor) {
        visitor.openTupleType(this)
        typeOfTuple!.accept(visitor)
        if additionalTypes != nil {
            for node in additionalTypes! {
                node.accept(visitor)
            }
        }
        visitor.closeTupleType(this)
    }

    let typeOfTuple: Type?
    let additionalTypes: [AdditionalType]?
}

class AdditionalType : SyntaxNode {

    init(enumCase: Type, start: Position, end: Position) {
        super.init(start, end)
    }

    function accept(mutable visitor: SyntaxVisitor) {
        visitor.openAdditionalType(this)
        enumCase!.accept(visitor)
        visitor.closeAdditionalType(this)
    }

    let enumCase: Type?
}

class EnumCase : SyntaxNode {

    init(name: String, start: Position, end: Position) {
        super.init(start, end)
    }

    function accept(mutable visitor: SyntaxVisitor) {
        visitor.openEnumCase(this)
        visitor.closeEnumCase(this)
    }

    let name: String?
}

class AdditionalCase : SyntaxNode {

    init(enumCase: EnumCase, start: Position, end: Position) {
        super.init(start, end)
    }

    function accept(mutable visitor: SyntaxVisitor) {
        visitor.openAdditionalCase(this)
        enumCase!.accept(visitor)
        visitor.closeAdditionalCase(this)
    }

    let enumCase: EnumCase?
}

class ClassBody : SyntaxNode {

    init(members: [ClassMember], start: Position, end: Position) {
        super.init(start, end)
    }

    function accept(mutable visitor: SyntaxVisitor) {
        visitor.openClassBody(this)
        if members != nil {
            for node in members! {
                node.accept(visitor)
            }
        }
        visitor.closeClassBody(this)
    }

    let members: [ClassMember]?
}

class GenericArgumentClause : SyntaxNode {

    init(genericParameters: [GenericParameter], start: Position, end: Position) {
        super.init(start, end)
    }

    function accept(mutable visitor: SyntaxVisitor) {
        visitor.openGenericArgumentClause(this)
        for node in genericParameters! {
            node.accept(visitor)
        }
        visitor.closeGenericArgumentClause(this)
    }

    let genericParameters: [GenericParameter]?
}

class GenericParameter : SyntaxNode {

    init(typeName: String, start: Position, end: Position) {
        super.init(start, end)
    }

    function accept(mutable visitor: SyntaxVisitor) {
        visitor.openGenericParameter(this)
        visitor.closeGenericParameter(this)
    }

    let typeName: String?
}

class ClassMember : SyntaxNode {

    init(declaration: Declaration, start: Position, end: Position) {
        super.init(start, end)
    }

    function accept(mutable visitor: SyntaxVisitor) {
        visitor.openClassMember(this)
        declaration!.accept(visitor)
        visitor.closeClassMember(this)
    }

    let declaration: Declaration?
}

class PrefixExpression : SyntaxNode {

    init(prefixOperator: String, expression: PostfixExpression, start: Position, end: Position) {
        super.init(start, end)
    }

    function accept(mutable visitor: SyntaxVisitor) {
        visitor.openPrefixExpression(this)
        expression!.accept(visitor)
        visitor.closePrefixExpression(this)
    }

    let prefixOperator: String?
    let expression: PostfixExpression?
}

class PostfixExpression : SyntaxNode {

    init(primaryExpression: PrimaryExpression, postfixes: [Postfix], start: Position, end: Position) {
        super.init(start, end)
    }

    function accept(mutable visitor: SyntaxVisitor) {
        visitor.openPostfixExpression(this)
        primaryExpression!.accept(visitor)
        if postfixes != nil {
            for node in postfixes! {
                node.accept(visitor)
            }
        }
        visitor.closePostfixExpression(this)
    }

    let primaryExpression: PrimaryExpression?
    let postfixes: [Postfix]?
}

class BinaryOp : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function accept(mutable visitor: SyntaxVisitor) {
        visitor.openBinaryOp(this)
        visitor.closeBinaryOp(this)
    }

}

class BinaryOperation : BinaryOp {

    init(binaryOperator: String, expression: PrefixExpression, start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openBinaryOperation(this)
        expression!.accept(visitor)
        visitor.closeBinaryOperation(this)
    }

    let binaryOperator: String?
    let expression: PrefixExpression?
}

class Assignment : BinaryOp {

    init(expression: PrefixExpression, start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openAssignment(this)
        expression!.accept(visitor)
        visitor.closeAssignment(this)
    }

    let expression: PrefixExpression?
}

class TypeQuery : BinaryOp {

    init(objectType: Type, start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openTypeQuery(this)
        objectType!.accept(visitor)
        visitor.closeTypeQuery(this)
    }

    let objectType: Type?
}

class TypeCast : BinaryOp {

    init(objectType: Type, start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openTypeCast(this)
        objectType!.accept(visitor)
        visitor.closeTypeCast(this)
    }

    let objectType: Type?
}

class CatchClause : SyntaxNode {

    init(catchPattern: CatchPattern, bindingPattern: TuplePattern, expression: Expression, start: Position, end: Position) {
        super.init(start, end)
    }

    function accept(mutable visitor: SyntaxVisitor) {
        visitor.openCatchClause(this)
        catchPattern!.accept(visitor)
        if bindingPattern != nil {
            bindingPattern!.accept(visitor)
        }
        expression!.accept(visitor)
        visitor.closeCatchClause(this)
    }

    let catchPattern: CatchPattern?
    let bindingPattern: TuplePattern?
    let expression: Expression?
}

class CatchPattern : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function accept(mutable visitor: SyntaxVisitor) {
        visitor.openCatchPattern(this)
        visitor.closeCatchPattern(this)
    }

}

class WildCardCatchPattern : CatchPattern {

    init(pattern: WildcardPattern, start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openWildCardCatchPattern(this)
        pattern!.accept(visitor)
        visitor.closeWildCardCatchPattern(this)
    }

    let pattern: WildcardPattern?
}

class PathItemCatchPattern : CatchPattern {

    init(catchCase: PathItem, catchCaseExtensions: [PathIdentifier], start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openPathItemCatchPattern(this)
        catchCase!.accept(visitor)
        if catchCaseExtensions != nil {
            for node in catchCaseExtensions! {
                node.accept(visitor)
            }
        }
        visitor.closePathItemCatchPattern(this)
    }

    let catchCase: PathItem?
    let catchCaseExtensions: [PathIdentifier]?
}

class Postfix : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function accept(mutable visitor: SyntaxVisitor) {
        visitor.openPostfix(this)
        visitor.closePostfix(this)
    }

}

class OperatorPostfix : Postfix {

    init(postfixOperator: String, start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openOperatorPostfix(this)
        visitor.closeOperatorPostfix(this)
    }

    let postfixOperator: String?
}

class FunctionCall : Postfix {

    init(arguments: ParenthesizedExpression, catchClauses: [CatchClause], start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openFunctionCall(this)
        arguments!.accept(visitor)
        if catchClauses != nil {
            for node in catchClauses! {
                node.accept(visitor)
            }
        }
        visitor.closeFunctionCall(this)
    }

    let arguments: ParenthesizedExpression?
    let catchClauses: [CatchClause]?
}

class ExplicitMemberExpression : Postfix {

    init(memberPostfix: MemberPostfix, start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openExplicitMemberExpression(this)
        memberPostfix!.accept(visitor)
        visitor.closeExplicitMemberExpression(this)
    }

    let memberPostfix: MemberPostfix?
}

class Subscript : Postfix {

    init(expressions: [ExpressionElement], start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openSubscript(this)
        for node in expressions! {
            node.accept(visitor)
        }
        visitor.closeSubscript(this)
    }

    let expressions: [ExpressionElement]?
}

class ExpressionElement : SyntaxNode {

    init(expression: Expression, start: Position, end: Position) {
        super.init(start, end)
    }

    function accept(mutable visitor: SyntaxVisitor) {
        visitor.openExpressionElement(this)
        expression!.accept(visitor)
        visitor.closeExpressionElement(this)
    }

    let expression: Expression?
}

class MemberPostfix : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function accept(mutable visitor: SyntaxVisitor) {
        visitor.openMemberPostfix(this)
        visitor.closeMemberPostfix(this)
    }

}

class NamedMemberPostfix : MemberPostfix {

    init(identifier: IdentifierExpression, start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openNamedMemberPostfix(this)
        identifier!.accept(visitor)
        visitor.closeNamedMemberPostfix(this)
    }

    let identifier: IdentifierExpression?
}

class PrimaryExpression : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function accept(mutable visitor: SyntaxVisitor) {
        visitor.openPrimaryExpression(this)
        visitor.closePrimaryExpression(this)
    }

}

class ParenthesizedExpression : PrimaryExpression {

    init(expressionElements: [ExpressionElement], start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openParenthesizedExpression(this)
        if expressionElements != nil {
            for node in expressionElements! {
                node.accept(visitor)
            }
        }
        visitor.closeParenthesizedExpression(this)
    }

    let expressionElements: [ExpressionElement]?
}

class LiteralExpression : PrimaryExpression {

    init(literal: Literal, start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openLiteralExpression(this)
        visitor.closeLiteralExpression(this)
    }

    let literal: Literal?
}

class IdentifierExpression : PrimaryExpression {

    init(name: String, start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openIdentifierExpression(this)
        visitor.closeIdentifierExpression(this)
    }

    let name: String?
}

class IfExpression : PrimaryExpression {

    init(condition: Expression, consequent: Expression, elseClause: ElseClause, start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openIfExpression(this)
        condition!.accept(visitor)
        consequent!.accept(visitor)
        if elseClause != nil {
            elseClause!.accept(visitor)
        }
        visitor.closeIfExpression(this)
    }

    let condition: Expression?
    let consequent: Expression?
    let elseClause: ElseClause?
}

class SwitchExpression : PrimaryExpression {

    init(expression: Expression, body: SwitchBody, start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openSwitchExpression(this)
        expression!.accept(visitor)
        body!.accept(visitor)
        visitor.closeSwitchExpression(this)
    }

    let expression: Expression?
    let body: SwitchBody?
}

class ForExpression : PrimaryExpression {

    init(loop: ForLoop, start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openForExpression(this)
        loop!.accept(visitor)
        visitor.closeForExpression(this)
    }

    let loop: ForLoop?
}

class ReturnExpression : PrimaryExpression {

    init(expression: Expression, start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openReturnExpression(this)
        if expression != nil {
            expression!.accept(visitor)
        }
        visitor.closeReturnExpression(this)
    }

    let expression: Expression?
}

class ThrowExpression : PrimaryExpression {

    init(expression: Expression, start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openThrowExpression(this)
        if expression != nil {
            expression!.accept(visitor)
        }
        visitor.closeThrowExpression(this)
    }

    let expression: Expression?
}

class BreakExpression : PrimaryExpression {

    init(expression: Expression, start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openBreakExpression(this)
        if expression != nil {
            expression!.accept(visitor)
        }
        visitor.closeBreakExpression(this)
    }

    let expression: Expression?
}

class InitializerCall : PrimaryExpression {

    init(typeToInitialize: Type, arguments: ParenthesizedExpression, catchClauses: [CatchClause], start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openInitializerCall(this)
        typeToInitialize!.accept(visitor)
        arguments!.accept(visitor)
        if catchClauses != nil {
            for node in catchClauses! {
                node.accept(visitor)
            }
        }
        visitor.closeInitializerCall(this)
    }

    let typeToInitialize: Type?
    let arguments: ParenthesizedExpression?
    let catchClauses: [CatchClause]?
}

class ThisExpression : PrimaryExpression {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openThisExpression(this)
        visitor.closeThisExpression(this)
    }

}

class ThisDot : ThisExpression {

    init(member: CommonThisMember, start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openThisDot(this)
        member!.accept(visitor)
        visitor.closeThisDot(this)
    }

    let member: CommonThisMember?
}

class ThisSubscript : ThisExpression {

    init(subscript: Subscript, start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openThisSubscript(this)
        subscript!.accept(visitor)
        visitor.closeThisSubscript(this)
    }

    let subscript: Subscript?
}

class ThisWord : ThisExpression {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openThisWord(this)
        visitor.closeThisWord(this)
    }

}

class SuperExpression : PrimaryExpression {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openSuperExpression(this)
        visitor.closeSuperExpression(this)
    }

}

class SuperDot : SuperExpression {

    init(member: CommonSuperMember, start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openSuperDot(this)
        member!.accept(visitor)
        visitor.closeSuperDot(this)
    }

    let member: CommonSuperMember?
}

class SuperSubscript : SuperExpression {

    init(subscript: Subscript, start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openSuperSubscript(this)
        subscript!.accept(visitor)
        visitor.closeSuperSubscript(this)
    }

    let subscript: Subscript?
}

class ElseClause : SyntaxNode {

    init(alternative: Expression, start: Position, end: Position) {
        super.init(start, end)
    }

    function accept(mutable visitor: SyntaxVisitor) {
        visitor.openElseClause(this)
        alternative!.accept(visitor)
        visitor.closeElseClause(this)
    }

    let alternative: Expression?
}

class SwitchBody : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function accept(mutable visitor: SyntaxVisitor) {
        visitor.openSwitchBody(this)
        visitor.closeSwitchBody(this)
    }

}

class CurliedSwitchBody : SwitchBody {

    init(cases: [SwitchCase], start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openCurliedSwitchBody(this)
        for node in cases! {
            node.accept(visitor)
        }
        visitor.closeCurliedSwitchBody(this)
    }

    let cases: [SwitchCase]?
}

class NakedSwitchBody : SwitchBody {

    init(cases: [SwitchCase], start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openNakedSwitchBody(this)
        for node in cases! {
            node.accept(visitor)
        }
        visitor.closeNakedSwitchBody(this)
    }

    let cases: [SwitchCase]?
}

class SwitchCase : SyntaxNode {

    init(label: CaseLabel, content: CaseContent, start: Position, end: Position) {
        super.init(start, end)
    }

    function accept(mutable visitor: SyntaxVisitor) {
        visitor.openSwitchCase(this)
        label!.accept(visitor)
        content!.accept(visitor)
        visitor.closeSwitchCase(this)
    }

    let label: CaseLabel?
    let content: CaseContent?
}

class CaseLabel : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function accept(mutable visitor: SyntaxVisitor) {
        visitor.openCaseLabel(this)
        visitor.closeCaseLabel(this)
    }

}

class ItemCaseLabel : CaseLabel {

    init(pattern: Pattern, additionalPatterns: [CaseItem], start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openItemCaseLabel(this)
        pattern!.accept(visitor)
        if additionalPatterns != nil {
            for node in additionalPatterns! {
                node.accept(visitor)
            }
        }
        visitor.closeItemCaseLabel(this)
    }

    let pattern: Pattern?
    let additionalPatterns: [CaseItem]?
}

class DefaultCaseLabel : CaseLabel {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openDefaultCaseLabel(this)
        visitor.closeDefaultCaseLabel(this)
    }

}

class CaseItem : SyntaxNode {

    init(pattern: Pattern, start: Position, end: Position) {
        super.init(start, end)
    }

    function accept(mutable visitor: SyntaxVisitor) {
        visitor.openCaseItem(this)
        pattern!.accept(visitor)
        visitor.closeCaseItem(this)
    }

    let pattern: Pattern?
}

class ForLoop : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function accept(mutable visitor: SyntaxVisitor) {
        visitor.openForLoop(this)
        visitor.closeForLoop(this)
    }

}

class ForEach : ForLoop {

    init(pattern: Pattern, expression: Expression, code: Expression, start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openForEach(this)
        pattern!.accept(visitor)
        expression!.accept(visitor)
        code!.accept(visitor)
        visitor.closeForEach(this)
    }

    let pattern: Pattern?
    let expression: Expression?
    let code: Expression?
}

class PlainFor : ForLoop {

    init(forInit: VariableDeclaration, forCheck: Expression, forNext: Expression, code: Expression, start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openPlainFor(this)
        if forInit != nil {
            forInit!.accept(visitor)
        }
        if forCheck != nil {
            forCheck!.accept(visitor)
        }
        forNext!.accept(visitor)
        code!.accept(visitor)
        visitor.closePlainFor(this)
    }

    let forInit: VariableDeclaration?
    let forCheck: Expression?
    let forNext: Expression?
    let code: Expression?
}

class Pattern : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function accept(mutable visitor: SyntaxVisitor) {
        visitor.openPattern(this)
        visitor.closePattern(this)
    }

}

class WildcardPattern : Pattern {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openWildcardPattern(this)
        visitor.closeWildcardPattern(this)
    }

}

class IdentifierPattern : Pattern {

    init(identifier: String, annotationForType: TypeAnnotation, start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openIdentifierPattern(this)
        if annotationForType != nil {
            annotationForType!.accept(visitor)
        }
        visitor.closeIdentifierPattern(this)
    }

    let identifier: String?
    let annotationForType: TypeAnnotation?
}

class TuplePattern : Pattern {

    init(elements: [TuplePatternElement], start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openTuplePattern(this)
        for node in elements! {
            node.accept(visitor)
        }
        visitor.closeTuplePattern(this)
    }

    let elements: [TuplePatternElement]?
}

class ExpressionPattern : Pattern {

    init(expression: Expression, start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openExpressionPattern(this)
        expression!.accept(visitor)
        visitor.closeExpressionPattern(this)
    }

    let expression: Expression?
}

class TuplePatternElement : SyntaxNode {

    init(pattern: Pattern, start: Position, end: Position) {
        super.init(start, end)
    }

    function accept(mutable visitor: SyntaxVisitor) {
        visitor.openTuplePatternElement(this)
        pattern!.accept(visitor)
        visitor.closeTuplePatternElement(this)
    }

    let pattern: Pattern?
}

class CaseContent : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function accept(mutable visitor: SyntaxVisitor) {
        visitor.openCaseContent(this)
        visitor.closeCaseContent(this)
    }

}

class BlockCaseContent : CaseContent {

    init(statements: [StatementWithSemicolon], start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openBlockCaseContent(this)
        for node in statements! {
            node.accept(visitor)
        }
        visitor.closeBlockCaseContent(this)
    }

    let statements: [StatementWithSemicolon]?
}

class EmptyCaseContent : CaseContent {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openEmptyCaseContent(this)
        visitor.closeEmptyCaseContent(this)
    }

}

class CommonThisMember : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function accept(mutable visitor: SyntaxVisitor) {
        visitor.openCommonThisMember(this)
        visitor.closeCommonThisMember(this)
    }

}

class ThisInit : CommonThisMember {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openThisInit(this)
        visitor.closeThisInit(this)
    }

}

class ThisMember : CommonThisMember {

    init(name: String, start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openThisMember(this)
        visitor.closeThisMember(this)
    }

    let name: String?
}

class CommonSuperMember : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function accept(mutable visitor: SyntaxVisitor) {
        visitor.openCommonSuperMember(this)
        visitor.closeCommonSuperMember(this)
    }

}

class SuperInit : CommonSuperMember {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openSuperInit(this)
        visitor.closeSuperInit(this)
    }

}

class SuperMember : CommonSuperMember {

    init(name: String, start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openSuperMember(this)
        visitor.closeSuperMember(this)
    }

    let name: String?
}

class Type : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function accept(mutable visitor: SyntaxVisitor) {
        visitor.openType(this)
        visitor.closeType(this)
    }

}

class TypeIdentifier : Type {

    init(name: String, subType: SubtypeIdentifier, postfixes: [TypePostfix], start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openTypeIdentifier(this)
        if subType != nil {
            subType!.accept(visitor)
        }
        if postfixes != nil {
            for node in postfixes! {
                node.accept(visitor)
            }
        }
        visitor.closeTypeIdentifier(this)
    }

    let name: String?
    let subType: SubtypeIdentifier?
    let postfixes: [TypePostfix]?
}

class ArrayType : Type {

    init(elementType: Type, postfixes: [TypePostfix], start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openArrayType(this)
        elementType!.accept(visitor)
        if postfixes != nil {
            for node in postfixes! {
                node.accept(visitor)
            }
        }
        visitor.closeArrayType(this)
    }

    let elementType: Type?
    let postfixes: [TypePostfix]?
}

class TypeAnnotation : SyntaxNode {

    init(annotationForType: Type, start: Position, end: Position) {
        super.init(start, end)
    }

    function accept(mutable visitor: SyntaxVisitor) {
        visitor.openTypeAnnotation(this)
        annotationForType!.accept(visitor)
        visitor.closeTypeAnnotation(this)
    }

    let annotationForType: Type?
}

class SubtypeIdentifier : SyntaxNode {

    init(typeIdentifier: TypeIdentifier, start: Position, end: Position) {
        super.init(start, end)
    }

    function accept(mutable visitor: SyntaxVisitor) {
        visitor.openSubtypeIdentifier(this)
        typeIdentifier!.accept(visitor)
        visitor.closeSubtypeIdentifier(this)
    }

    let typeIdentifier: TypeIdentifier?
}

class TypePostfix : SyntaxNode {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    function accept(mutable visitor: SyntaxVisitor) {
        visitor.openTypePostfix(this)
        visitor.closeTypePostfix(this)
    }

}

class OptionalType : TypePostfix {

    init(start: Position, end: Position) {
        super.init(start, end)
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.openOptionalType(this)
        visitor.closeOptionalType(this)
    }

}

class TypeInheritanceClause : SyntaxNode {

    init(inheritances: [Inheritance], start: Position, end: Position) {
        super.init(start, end)
    }

    function accept(mutable visitor: SyntaxVisitor) {
        visitor.openTypeInheritanceClause(this)
        if inheritances != nil {
            for node in inheritances! {
                node.accept(visitor)
            }
        }
        visitor.closeTypeInheritanceClause(this)
    }

    let inheritances: [Inheritance]?
}

class Inheritance : SyntaxNode {

    init(typeIdentifier: TypeIdentifier, start: Position, end: Position) {
        super.init(start, end)
    }

    function accept(mutable visitor: SyntaxVisitor) {
        visitor.openInheritance(this)
        typeIdentifier!.accept(visitor)
        visitor.closeInheritance(this)
    }

    let typeIdentifier: TypeIdentifier?
}
