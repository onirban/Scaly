class SyntaxNode {
    let start: Position
    let end: Position
    var parent: SyntaxNode
}

class Program : SyntaxNode {

    init(name: String, directory: String, compilationUnits: [CompilationUnit]) {
        start = Position(0, 0)
        end = Position(0, 0)
        this.name = name
        this.directory = directory
        this.compilationUnits = compilationUnits
        this.parent = null
    }

    function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openProgram(this)
            return;
        if compilationUnits != null {
            for node: CompilationUnit in compilationUnits
                node.accept(visitor)
        }
        visitor.closeProgram(this)
    }

    let name: String?
    let directory: String?
    let compilationUnits: [CompilationUnit]?
}

class CompilationUnit : SyntaxNode {

    init(statements: [TerminatedStatement], start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.statements = statements;
    }

    function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openCompilationUnit(this)
            return;
        if statements != null {
            for node: TerminatedStatement in statements
                node.accept(visitor)
        }
        visitor.closeCompilationUnit(this)
    }

    let statements: [TerminatedStatement]?
    let fileName: String
}

class TerminatedStatement : SyntaxNode {

    init(statement: Statement, start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.statement = statement;
    }

    function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openTerminatedStatement(this)
            return;
        statement.accept(visitor)
        visitor.closeTerminatedStatement(this)
    }

    let statement: Statement?
}

class Statement : SyntaxNode {

    function accept(mutable visitor: SyntaxVisitor) {
    }

}

class Declaration : Statement {

    override function accept(mutable visitor: SyntaxVisitor) {
    }

}

class Expression : Statement {

    override function accept(mutable visitor: SyntaxVisitor) {
    }

}

class UseDeclaration : Declaration {

    init(importModule: PathItem, importExtensions: [PathIdentifier], start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.importModule = importModule;
        this.importExtensions = importExtensions;
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openUseDeclaration(this)
            return;
        importModule.accept(visitor)
        if importExtensions != null {
            for node: PathIdentifier in importExtensions
                node.accept(visitor)
        }
        visitor.closeUseDeclaration(this)
    }

    let importModule: PathItem?
    let importExtensions: [PathIdentifier]?
}

class ConstantDeclaration : Declaration {

    init(initializer: BindingInitializer, start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.initializer = initializer;
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openConstantDeclaration(this)
            return;
        initializer.accept(visitor)
        visitor.closeConstantDeclaration(this)
    }

    let initializer: BindingInitializer?
}

class VariableDeclaration : Declaration {

    init(initializer: BindingInitializer, start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.initializer = initializer;
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openVariableDeclaration(this)
            return;
        initializer.accept(visitor)
        visitor.closeVariableDeclaration(this)
    }

    let initializer: BindingInitializer?
}

class MutableDeclaration : Declaration {

    init(initializer: BindingInitializer, start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.initializer = initializer;
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openMutableDeclaration(this)
            return;
        initializer.accept(visitor)
        visitor.closeMutableDeclaration(this)
    }

    let initializer: BindingInitializer?
}

class FunctionDeclaration : Declaration {

    init(modifiers: [Modifier], name: FunctionName, signature: FunctionSignature, body: Expression, start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.modifiers = modifiers;
        this.name = name;
        this.signature = signature;
        this.body = body;
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openFunctionDeclaration(this)
            return;
        if modifiers != null {
            for node: Modifier in modifiers
                node.accept(visitor)
        }
        name.accept(visitor)
        signature.accept(visitor)
        if body != null
            body.accept(visitor)
        visitor.closeFunctionDeclaration(this)
    }

    let modifiers: [Modifier]?
    let name: FunctionName?
    let signature: FunctionSignature?
    let body: Expression?
}

class EnumDeclaration : Declaration {

    init(name: String, members: [EnumMember], start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.name = name;
        this.members = members;
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openEnumDeclaration(this)
            return;
        if members != null {
            for node: EnumMember in members
                node.accept(visitor)
        }
        visitor.closeEnumDeclaration(this)
    }

    let name: String?
    let members: [EnumMember]?
}

class ClassDeclaration : Declaration {

    init(name: String, genericArgumentClause: GenericArgumentClause, typeInheritanceClause: TypeInheritanceClause, body: ClassBody, start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.name = name;
        this.genericArgumentClause = genericArgumentClause;
        this.typeInheritanceClause = typeInheritanceClause;
        this.body = body;
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openClassDeclaration(this)
            return;
        if genericArgumentClause != null
            genericArgumentClause.accept(visitor)
        if typeInheritanceClause != null
            typeInheritanceClause.accept(visitor)
        if body != null
            body.accept(visitor)
        visitor.closeClassDeclaration(this)
    }

    let name: String?
    let genericArgumentClause: GenericArgumentClause?
    let typeInheritanceClause: TypeInheritanceClause?
    let body: ClassBody?
}

class InitializerDeclaration : Declaration {

    init(modifiers: [Modifier], parameterClause: ParameterClause, throwsClause: ThrowsClause, body: Expression, start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.modifiers = modifiers;
        this.parameterClause = parameterClause;
        this.throwsClause = throwsClause;
        this.body = body;
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openInitializerDeclaration(this)
            return;
        if modifiers != null {
            for node: Modifier in modifiers
                node.accept(visitor)
        }
        parameterClause.accept(visitor)
        if throwsClause != null
            throwsClause.accept(visitor)
        body.accept(visitor)
        visitor.closeInitializerDeclaration(this)
    }

    let modifiers: [Modifier]?
    let parameterClause: ParameterClause?
    let throwsClause: ThrowsClause?
    let body: Expression?
}

class CodeBlock : Expression {

    init(statements: [TerminatedStatement], start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.statements = statements;
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openCodeBlock(this)
            return;
        if statements != null {
            for node: TerminatedStatement in statements
                node.accept(visitor)
        }
        visitor.closeCodeBlock(this)
    }

    let statements: [TerminatedStatement]?
}

class SimpleExpression : Expression {

    init(prefixExpression: PrefixExpression, binaryOps: [BinaryOp], start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.prefixExpression = prefixExpression;
        this.binaryOps = binaryOps;
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openSimpleExpression(this)
            return;
        prefixExpression.accept(visitor)
        if binaryOps != null {
            for node: BinaryOp in binaryOps
                node.accept(visitor)
        }
        visitor.closeSimpleExpression(this)
    }

    let prefixExpression: PrefixExpression?
    let binaryOps: [BinaryOp]?
}

class PathIdentifier : SyntaxNode {

    init(extension: PathItem, start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.extension = extension;
    }

    function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openPathIdentifier(this)
            return;
        extension.accept(visitor)
        visitor.closePathIdentifier(this)
    }

    let extension: PathItem?
}

class PathItem : SyntaxNode {

    init(name: String, start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.name = name;
    }

    function accept(mutable visitor: SyntaxVisitor) {
        visitor.visitPathItem(this)
    }

    let name: String?
}

class Initializer : SyntaxNode {

    init(expression: Expression, start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.expression = expression;
    }

    function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openInitializer(this)
            return;
        expression.accept(visitor)
        visitor.closeInitializer(this)
    }

    let expression: Expression?
}

class BindingInitializer : SyntaxNode {

    init(initializer: PatternInitializer, additionalInitializers: [AdditionalInitializer], start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.initializer = initializer;
        this.additionalInitializers = additionalInitializers;
    }

    function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openBindingInitializer(this)
            return;
        initializer.accept(visitor)
        if additionalInitializers != null {
            for node: AdditionalInitializer in additionalInitializers
                node.accept(visitor)
        }
        visitor.closeBindingInitializer(this)
    }

    let initializer: PatternInitializer?
    let additionalInitializers: [AdditionalInitializer]?
}

class PatternInitializer : SyntaxNode {

    init(pattern: Pattern, initializer: Initializer, start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.pattern = pattern;
        this.initializer = initializer;
    }

    function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openPatternInitializer(this)
            return;
        pattern.accept(visitor)
        if initializer != null
            initializer.accept(visitor)
        visitor.closePatternInitializer(this)
    }

    let pattern: Pattern?
    let initializer: Initializer?
}

class AdditionalInitializer : SyntaxNode {

    init(pattern: PatternInitializer, start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.pattern = pattern;
    }

    function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openAdditionalInitializer(this)
            return;
        pattern.accept(visitor)
        visitor.closeAdditionalInitializer(this)
    }

    let pattern: PatternInitializer?
}

class Modifier : SyntaxNode {

    function accept(mutable visitor: SyntaxVisitor) {
    }

}

class OverrideWord : Modifier {

    init(start: Position, end: Position) {
        this.start = start;
        this.end = end;
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.visitOverrideWord(this)
    }

}

class StaticWord : Modifier {

    init(start: Position, end: Position) {
        this.start = start;
        this.end = end;
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.visitStaticWord(this)
    }

}

class FunctionName : SyntaxNode {

    function accept(mutable visitor: SyntaxVisitor) {
    }

}

class IdentifierFunction : FunctionName {

    init(name: String, start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.name = name;
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.visitIdentifierFunction(this)
    }

    let name: String?
}

class FunctionSignature : SyntaxNode {

    init(parameterClause: ParameterClause, result: FunctionResult, throwsClause: ThrowsClause, start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.parameterClause = parameterClause;
        this.result = result;
        this.throwsClause = throwsClause;
    }

    function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openFunctionSignature(this)
            return;
        parameterClause.accept(visitor)
        if result != null
            result.accept(visitor)
        if throwsClause != null
            throwsClause.accept(visitor)
        visitor.closeFunctionSignature(this)
    }

    let parameterClause: ParameterClause?
    let result: FunctionResult?
    let throwsClause: ThrowsClause?
}

class FunctionResult : SyntaxNode {

    init(existingObject: ExistingClause, resultType: Type, start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.existingObject = existingObject;
        this.resultType = resultType;
    }

    function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openFunctionResult(this)
            return;
        if existingObject != null
            existingObject.accept(visitor)
        resultType.accept(visitor)
        visitor.closeFunctionResult(this)
    }

    let existingObject: ExistingClause?
    let resultType: Type?
}

class ExistingClause : SyntaxNode {

    init(start: Position, end: Position) {
        this.start = start;
        this.end = end;
    }

    function accept(mutable visitor: SyntaxVisitor) {
        visitor.visitExistingClause(this)
    }

}

class ParameterClause : SyntaxNode {

    init(parameters: [Parameter], start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.parameters = parameters;
    }

    function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openParameterClause(this)
            return;
        if parameters != null {
            for node: Parameter in parameters
                node.accept(visitor)
        }
        visitor.closeParameterClause(this)
    }

    let parameters: [Parameter]?
}

class Parameter : SyntaxNode {

    function accept(mutable visitor: SyntaxVisitor) {
    }

}

class ConstParameter : Parameter {

    init(name: String, parameterType: Type, start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.name = name;
        this.parameterType = parameterType;
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openConstParameter(this)
            return;
        parameterType.accept(visitor)
        visitor.closeConstParameter(this)
    }

    let name: String?
    let parameterType: Type?
}

class VarParameter : Parameter {

    init(name: String, parameterType: Type, start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.name = name;
        this.parameterType = parameterType;
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openVarParameter(this)
            return;
        parameterType.accept(visitor)
        visitor.closeVarParameter(this)
    }

    let name: String?
    let parameterType: Type?
}

class ThrowsClause : SyntaxNode {

    init(throwsType: Type, start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.throwsType = throwsType;
    }

    function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openThrowsClause(this)
            return;
        throwsType.accept(visitor)
        visitor.closeThrowsClause(this)
    }

    let throwsType: Type?
}

class EnumMember : SyntaxNode {

    init(enumCase: EnumCase, additionalCases: [AdditionalCase], parameterClause: ParameterClause, start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.enumCase = enumCase;
        this.additionalCases = additionalCases;
        this.parameterClause = parameterClause;
    }

    function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openEnumMember(this)
            return;
        enumCase.accept(visitor)
        if additionalCases != null {
            for node: AdditionalCase in additionalCases
                node.accept(visitor)
        }
        if parameterClause != null
            parameterClause.accept(visitor)
        visitor.closeEnumMember(this)
    }

    let enumCase: EnumCase?
    let additionalCases: [AdditionalCase]?
    let parameterClause: ParameterClause?
}

class EnumCase : SyntaxNode {

    init(name: String, start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.name = name;
    }

    function accept(mutable visitor: SyntaxVisitor) {
        visitor.visitEnumCase(this)
    }

    let name: String?
}

class AdditionalCase : SyntaxNode {

    init(enumCase: EnumCase, start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.enumCase = enumCase;
    }

    function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openAdditionalCase(this)
            return;
        enumCase.accept(visitor)
        visitor.closeAdditionalCase(this)
    }

    let enumCase: EnumCase?
}

class ClassBody : SyntaxNode {

    init(members: [ClassMember], start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.members = members;
    }

    function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openClassBody(this)
            return;
        if members != null {
            for node: ClassMember in members
                node.accept(visitor)
        }
        visitor.closeClassBody(this)
    }

    let members: [ClassMember]?
}

class GenericArgumentClause : SyntaxNode {

    init(genericParameters: [GenericParameter], start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.genericParameters = genericParameters;
    }

    function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openGenericArgumentClause(this)
            return;
        if genericParameters != null {
            for node: GenericParameter in genericParameters
                node.accept(visitor)
        }
        visitor.closeGenericArgumentClause(this)
    }

    let genericParameters: [GenericParameter]?
}

class GenericParameter : SyntaxNode {

    init(typeName: String, start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.typeName = typeName;
    }

    function accept(mutable visitor: SyntaxVisitor) {
        visitor.visitGenericParameter(this)
    }

    let typeName: String?
}

class ClassMember : SyntaxNode {

    init(declaration: Declaration, start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.declaration = declaration;
    }

    function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openClassMember(this)
            return;
        declaration.accept(visitor)
        visitor.closeClassMember(this)
    }

    let declaration: Declaration?
}

class PrefixExpression : SyntaxNode {

    init(prefixOperator: String, expression: PostfixExpression, start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.prefixOperator = prefixOperator;
        this.expression = expression;
    }

    function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openPrefixExpression(this)
            return;
        expression.accept(visitor)
        visitor.closePrefixExpression(this)
    }

    let prefixOperator: String?
    let expression: PostfixExpression?
}

class PostfixExpression : SyntaxNode {

    init(primaryExpression: PrimaryExpression, postfixes: [Postfix], start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.primaryExpression = primaryExpression;
        this.postfixes = postfixes;
    }

    function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openPostfixExpression(this)
            return;
        primaryExpression.accept(visitor)
        if postfixes != null {
            for node: Postfix in postfixes
                node.accept(visitor)
        }
        visitor.closePostfixExpression(this)
    }

    let primaryExpression: PrimaryExpression?
    let postfixes: [Postfix]?
}

class BinaryOp : SyntaxNode {

    function accept(mutable visitor: SyntaxVisitor) {
    }

}

class BinaryOperation : BinaryOp {

    init(binaryOperator: String, expression: PrefixExpression, start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.binaryOperator = binaryOperator;
        this.expression = expression;
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openBinaryOperation(this)
            return;
        expression.accept(visitor)
        visitor.closeBinaryOperation(this)
    }

    let binaryOperator: String?
    let expression: PrefixExpression?
}

class Assignment : BinaryOp {

    init(expression: Expression, start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.expression = expression;
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openAssignment(this)
            return;
        expression.accept(visitor)
        visitor.closeAssignment(this)
    }

    let expression: Expression?
}

class TypeQuery : BinaryOp {

    init(objectType: Type, start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.objectType = objectType;
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openTypeQuery(this)
            return;
        objectType.accept(visitor)
        visitor.closeTypeQuery(this)
    }

    let objectType: Type?
}

class TypeCast : BinaryOp {

    init(objectType: Type, start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.objectType = objectType;
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openTypeCast(this)
            return;
        objectType.accept(visitor)
        visitor.closeTypeCast(this)
    }

    let objectType: Type?
}

class CatchClause : SyntaxNode {

    init(catchPattern: CatchPattern, bindingPattern: TuplePattern, expression: Expression, start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.catchPattern = catchPattern;
        this.bindingPattern = bindingPattern;
        this.expression = expression;
    }

    function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openCatchClause(this)
            return;
        catchPattern.accept(visitor)
        if bindingPattern != null
            bindingPattern.accept(visitor)
        expression.accept(visitor)
        visitor.closeCatchClause(this)
    }

    let catchPattern: CatchPattern?
    let bindingPattern: TuplePattern?
    let expression: Expression?
}

class CatchPattern : SyntaxNode {

    function accept(mutable visitor: SyntaxVisitor) {
    }

}

class WildCardCatchPattern : CatchPattern {

    init(pattern: WildcardPattern, start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.pattern = pattern;
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openWildCardCatchPattern(this)
            return;
        pattern.accept(visitor)
        visitor.closeWildCardCatchPattern(this)
    }

    let pattern: WildcardPattern?
}

class IdentifierCatchPattern : CatchPattern {

    init(name: String, member: ExplicitMemberExpression, start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.name = name;
        this.member = member;
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openIdentifierCatchPattern(this)
            return;
        if member != null
            member.accept(visitor)
        visitor.closeIdentifierCatchPattern(this)
    }

    let name: String?
    let member: ExplicitMemberExpression?
}

class Postfix : SyntaxNode {

    function accept(mutable visitor: SyntaxVisitor) {
    }

}

class OperatorPostfix : Postfix {

    init(postfixOperator: String, start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.postfixOperator = postfixOperator;
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.visitOperatorPostfix(this)
    }

    let postfixOperator: String?
}

class FunctionCall : Postfix {

    init(arguments: ParenthesizedExpression, catchClauses: [CatchClause], start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.arguments = arguments;
        this.catchClauses = catchClauses;
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openFunctionCall(this)
            return;
        arguments.accept(visitor)
        if catchClauses != null {
            for node: CatchClause in catchClauses
                node.accept(visitor)
        }
        visitor.closeFunctionCall(this)
    }

    let arguments: ParenthesizedExpression?
    let catchClauses: [CatchClause]?
}

class ExplicitMemberExpression : Postfix {

    init(memberPostfix: MemberPostfix, start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.memberPostfix = memberPostfix;
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openExplicitMemberExpression(this)
            return;
        memberPostfix.accept(visitor)
        visitor.closeExplicitMemberExpression(this)
    }

    let memberPostfix: MemberPostfix?
}

class Subscript : Postfix {

    init(expressions: [ExpressionElement], start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.expressions = expressions;
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openSubscript(this)
            return;
        if expressions != null {
            for node: ExpressionElement in expressions
                node.accept(visitor)
        }
        visitor.closeSubscript(this)
    }

    let expressions: [ExpressionElement]?
}

class ExpressionElement : SyntaxNode {

    init(expression: Expression, start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.expression = expression;
    }

    function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openExpressionElement(this)
            return;
        expression.accept(visitor)
        visitor.closeExpressionElement(this)
    }

    let expression: Expression?
}

class MemberPostfix : SyntaxNode {

    function accept(mutable visitor: SyntaxVisitor) {
    }

}

class NamedMemberPostfix : MemberPostfix {

    init(identifier: IdentifierExpression, start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.identifier = identifier;
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openNamedMemberPostfix(this)
            return;
        identifier.accept(visitor)
        visitor.closeNamedMemberPostfix(this)
    }

    let identifier: IdentifierExpression?
}

class PrimaryExpression : SyntaxNode {

    function accept(mutable visitor: SyntaxVisitor) {
    }

}

class IdentifierExpression : PrimaryExpression {

    init(name: String, start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.name = name;
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.visitIdentifierExpression(this)
    }

    let name: String?
}

class LiteralExpression : PrimaryExpression {

    init(literal: Literal, start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.literal = literal;
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.visitLiteralExpression(this)
    }

    let literal: Literal?
}

class IfExpression : PrimaryExpression {

    init(condition: Expression, consequent: Expression, elseClause: ElseClause, start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.condition = condition;
        this.consequent = consequent;
        this.elseClause = elseClause;
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openIfExpression(this)
            return;
        condition.accept(visitor)
        consequent.accept(visitor)
        if elseClause != null
            elseClause.accept(visitor)
        visitor.closeIfExpression(this)
    }

    let condition: Expression?
    let consequent: Expression?
    let elseClause: ElseClause?
}

class SwitchExpression : PrimaryExpression {

    init(expression: Expression, body: SwitchBody, start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.expression = expression;
        this.body = body;
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openSwitchExpression(this)
            return;
        expression.accept(visitor)
        body.accept(visitor)
        visitor.closeSwitchExpression(this)
    }

    let expression: Expression?
    let body: SwitchBody?
}

class ForExpression : PrimaryExpression {

    init(pattern: Pattern, expression: Expression, code: Expression, start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.pattern = pattern;
        this.expression = expression;
        this.code = code;
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openForExpression(this)
            return;
        pattern.accept(visitor)
        expression.accept(visitor)
        code.accept(visitor)
        visitor.closeForExpression(this)
    }

    let pattern: Pattern?
    let expression: Expression?
    let code: Expression?
}

class WhileExpression : PrimaryExpression {

    init(condition: Expression, code: Expression, start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.condition = condition;
        this.code = code;
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openWhileExpression(this)
            return;
        condition.accept(visitor)
        code.accept(visitor)
        visitor.closeWhileExpression(this)
    }

    let condition: Expression?
    let code: Expression?
}

class RepeatExpression : PrimaryExpression {

    init(code: Expression, condition: Expression, start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.code = code;
        this.condition = condition;
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openRepeatExpression(this)
            return;
        code.accept(visitor)
        condition.accept(visitor)
        visitor.closeRepeatExpression(this)
    }

    let code: Expression?
    let condition: Expression?
}

class ParenthesizedExpression : PrimaryExpression {

    init(expressionElements: [ExpressionElement], start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.expressionElements = expressionElements;
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openParenthesizedExpression(this)
            return;
        if expressionElements != null {
            for node: ExpressionElement in expressionElements
                node.accept(visitor)
        }
        visitor.closeParenthesizedExpression(this)
    }

    let expressionElements: [ExpressionElement]?
}

class ReturnExpression : PrimaryExpression {

    init(expression: Expression, start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.expression = expression;
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openReturnExpression(this)
            return;
        if expression != null
            expression.accept(visitor)
        visitor.closeReturnExpression(this)
    }

    let expression: Expression?
}

class ThrowExpression : PrimaryExpression {

    init(error: IdentifierExpression, arguments: ParenthesizedExpression, start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.error = error;
        this.arguments = arguments;
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openThrowExpression(this)
            return;
        if error != null
            error.accept(visitor)
        if arguments != null
            arguments.accept(visitor)
        visitor.closeThrowExpression(this)
    }

    let error: IdentifierExpression?
    let arguments: ParenthesizedExpression?
}

class BreakExpression : PrimaryExpression {

    init(expression: Expression, start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.expression = expression;
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openBreakExpression(this)
            return;
        if expression != null
            expression.accept(visitor)
        visitor.closeBreakExpression(this)
    }

    let expression: Expression?
}

class InitializerCall : PrimaryExpression {

    init(typeToInitialize: Type, arguments: ParenthesizedExpression, catchClauses: [CatchClause], start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.typeToInitialize = typeToInitialize;
        this.arguments = arguments;
        this.catchClauses = catchClauses;
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openInitializerCall(this)
            return;
        typeToInitialize.accept(visitor)
        arguments.accept(visitor)
        if catchClauses != null {
            for node: CatchClause in catchClauses
                node.accept(visitor)
        }
        visitor.closeInitializerCall(this)
    }

    let typeToInitialize: Type?
    let arguments: ParenthesizedExpression?
    let catchClauses: [CatchClause]?
}

class ThisExpression : PrimaryExpression {

    init(start: Position, end: Position) {
        this.start = start;
        this.end = end;
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.visitThisExpression(this)
    }

}

class SuperExpression : PrimaryExpression {

    override function accept(mutable visitor: SyntaxVisitor) {
    }

}

class SuperDot : SuperExpression {

    init(member: CommonSuperMember, start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.member = member;
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openSuperDot(this)
            return;
        member.accept(visitor)
        visitor.closeSuperDot(this)
    }

    let member: CommonSuperMember?
}

class SuperSubscript : SuperExpression {

    init(subscript: Subscript, start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.subscript = subscript;
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openSuperSubscript(this)
            return;
        subscript.accept(visitor)
        visitor.closeSuperSubscript(this)
    }

    let subscript: Subscript?
}

class NullExpression : PrimaryExpression {

    init(start: Position, end: Position) {
        this.start = start;
        this.end = end;
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.visitNullExpression(this)
    }

}

class ElseClause : SyntaxNode {

    init(alternative: Expression, start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.alternative = alternative;
    }

    function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openElseClause(this)
            return;
        alternative.accept(visitor)
        visitor.closeElseClause(this)
    }

    let alternative: Expression?
}

class SwitchBody : SyntaxNode {

    function accept(mutable visitor: SyntaxVisitor) {
    }

}

class CurliedSwitchBody : SwitchBody {

    init(cases: [SwitchCase], start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.cases = cases;
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openCurliedSwitchBody(this)
            return;
        if cases != null {
            for node: SwitchCase in cases
                node.accept(visitor)
        }
        visitor.closeCurliedSwitchBody(this)
    }

    let cases: [SwitchCase]?
}

class NakedSwitchBody : SwitchBody {

    init(cases: [SwitchCase], start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.cases = cases;
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openNakedSwitchBody(this)
            return;
        if cases != null {
            for node: SwitchCase in cases
                node.accept(visitor)
        }
        visitor.closeNakedSwitchBody(this)
    }

    let cases: [SwitchCase]?
}

class SwitchCase : SyntaxNode {

    init(label: CaseLabel, content: CaseContent, start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.label = label;
        this.content = content;
    }

    function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openSwitchCase(this)
            return;
        label.accept(visitor)
        content.accept(visitor)
        visitor.closeSwitchCase(this)
    }

    let label: CaseLabel?
    let content: CaseContent?
}

class CaseLabel : SyntaxNode {

    function accept(mutable visitor: SyntaxVisitor) {
    }

}

class ItemCaseLabel : CaseLabel {

    init(pattern: Pattern, additionalPatterns: [CaseItem], start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.pattern = pattern;
        this.additionalPatterns = additionalPatterns;
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openItemCaseLabel(this)
            return;
        pattern.accept(visitor)
        if additionalPatterns != null {
            for node: CaseItem in additionalPatterns
                node.accept(visitor)
        }
        visitor.closeItemCaseLabel(this)
    }

    let pattern: Pattern?
    let additionalPatterns: [CaseItem]?
}

class DefaultCaseLabel : CaseLabel {

    init(start: Position, end: Position) {
        this.start = start;
        this.end = end;
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.visitDefaultCaseLabel(this)
    }

}

class CaseItem : SyntaxNode {

    init(pattern: Pattern, start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.pattern = pattern;
    }

    function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openCaseItem(this)
            return;
        pattern.accept(visitor)
        visitor.closeCaseItem(this)
    }

    let pattern: Pattern?
}

class Pattern : SyntaxNode {

    function accept(mutable visitor: SyntaxVisitor) {
    }

}

class WildcardPattern : Pattern {

    init(start: Position, end: Position) {
        this.start = start;
        this.end = end;
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.visitWildcardPattern(this)
    }

}

class IdentifierPattern : Pattern {

    init(identifier: String, annotationForType: TypeAnnotation, start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.identifier = identifier;
        this.annotationForType = annotationForType;
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openIdentifierPattern(this)
            return;
        if annotationForType != null
            annotationForType.accept(visitor)
        visitor.closeIdentifierPattern(this)
    }

    let identifier: String?
    let annotationForType: TypeAnnotation?
}

class TuplePattern : Pattern {

    init(elements: [TuplePatternElement], start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.elements = elements;
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openTuplePattern(this)
            return;
        if elements != null {
            for node: TuplePatternElement in elements
                node.accept(visitor)
        }
        visitor.closeTuplePattern(this)
    }

    let elements: [TuplePatternElement]?
}

class ExpressionPattern : Pattern {

    init(expression: Expression, start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.expression = expression;
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openExpressionPattern(this)
            return;
        expression.accept(visitor)
        visitor.closeExpressionPattern(this)
    }

    let expression: Expression?
}

class TuplePatternElement : SyntaxNode {

    init(pattern: Pattern, start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.pattern = pattern;
    }

    function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openTuplePatternElement(this)
            return;
        pattern.accept(visitor)
        visitor.closeTuplePatternElement(this)
    }

    let pattern: Pattern?
}

class CaseContent : SyntaxNode {

    function accept(mutable visitor: SyntaxVisitor) {
    }

}

class BlockCaseContent : CaseContent {

    init(statements: [TerminatedStatement], start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.statements = statements;
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openBlockCaseContent(this)
            return;
        if statements != null {
            for node: TerminatedStatement in statements
                node.accept(visitor)
        }
        visitor.closeBlockCaseContent(this)
    }

    let statements: [TerminatedStatement]?
}

class EmptyCaseContent : CaseContent {

    init(start: Position, end: Position) {
        this.start = start;
        this.end = end;
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.visitEmptyCaseContent(this)
    }

}

class CommonSuperMember : SyntaxNode {

    function accept(mutable visitor: SyntaxVisitor) {
    }

}

class SuperInit : CommonSuperMember {

    init(start: Position, end: Position) {
        this.start = start;
        this.end = end;
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.visitSuperInit(this)
    }

}

class SuperMember : CommonSuperMember {

    init(name: String, start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.name = name;
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.visitSuperMember(this)
    }

    let name: String?
}

class Type : SyntaxNode {

    function accept(mutable visitor: SyntaxVisitor) {
    }

}

class TypeIdentifier : Type {

    init(name: String, subType: SubtypeIdentifier, postfixes: [TypePostfix], start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.name = name;
        this.subType = subType;
        this.postfixes = postfixes;
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openTypeIdentifier(this)
            return;
        if subType != null
            subType.accept(visitor)
        if postfixes != null {
            for node: TypePostfix in postfixes
                node.accept(visitor)
        }
        visitor.closeTypeIdentifier(this)
    }

    let name: String?
    let subType: SubtypeIdentifier?
    let postfixes: [TypePostfix]?
}

class ArrayType : Type {

    init(elementType: Type, postfixes: [TypePostfix], start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.elementType = elementType;
        this.postfixes = postfixes;
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openArrayType(this)
            return;
        elementType.accept(visitor)
        if postfixes != null {
            for node: TypePostfix in postfixes
                node.accept(visitor)
        }
        visitor.closeArrayType(this)
    }

    let elementType: Type?
    let postfixes: [TypePostfix]?
}

class TypeAnnotation : SyntaxNode {

    init(annotationForType: Type, start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.annotationForType = annotationForType;
    }

    function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openTypeAnnotation(this)
            return;
        annotationForType.accept(visitor)
        visitor.closeTypeAnnotation(this)
    }

    let annotationForType: Type?
}

class SubtypeIdentifier : SyntaxNode {

    init(typeIdentifier: TypeIdentifier, start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.typeIdentifier = typeIdentifier;
    }

    function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openSubtypeIdentifier(this)
            return;
        typeIdentifier.accept(visitor)
        visitor.closeSubtypeIdentifier(this)
    }

    let typeIdentifier: TypeIdentifier?
}

class TypePostfix : SyntaxNode {

    function accept(mutable visitor: SyntaxVisitor) {
    }

}

class OptionalType : TypePostfix {

    init(start: Position, end: Position) {
        this.start = start;
        this.end = end;
    }

    override function accept(mutable visitor: SyntaxVisitor) {
        visitor.visitOptionalType(this)
    }

}

class TypeInheritanceClause : SyntaxNode {

    init(inheritances: [Inheritance], start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.inheritances = inheritances;
    }

    function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openTypeInheritanceClause(this)
            return;
        if inheritances != null {
            for node: Inheritance in inheritances
                node.accept(visitor)
        }
        visitor.closeTypeInheritanceClause(this)
    }

    let inheritances: [Inheritance]?
}

class Inheritance : SyntaxNode {

    init(typeIdentifier: TypeIdentifier, start: Position, end: Position) {
        this.start = start;
        this.end = end;
        this.typeIdentifier = typeIdentifier;
    }

    function accept(mutable visitor: SyntaxVisitor) {
        if !visitor.openInheritance(this)
            return;
        typeIdentifier.accept(visitor)
        visitor.closeInheritance(this)
    }

    let typeIdentifier: TypeIdentifier?
}
