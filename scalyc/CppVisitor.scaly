class CppVisitor : SyntaxVisitor {

    // Needed during building one module
    mutable moduleName: String
    mutable sourceFile: VarString
    mutable headerFile: VarString

    // Some rudimentary semantics cache
    mutable inherits: [Inherits]
    mutable classes: [String]

    // indent level
    mutable headerIndentLevel: unsigned
    mutable sourceIndentLevel: unsigned

    // Some state during building some constructs
    mutable firstParameter: bool
    mutable firstBindingInitializer: bool
    mutable declaringClassMember: bool
    mutable inParameterClause: bool
    mutable abstractFunction: bool
    mutable staticFunction: bool
    mutable inEnumMember: bool
    mutable inFunctionReturn: bool
    mutable constDeclaration: bool
    mutable suppressSource: bool
    mutable suppressHeader: bool

    init() {

        // null init of mutable members does not work yet
        moduleName = String("")
        sourceFile = VarString("")
        headerFile = VarString("")
        inherits = [Inherits]()
        classes = [String]()
    }

    function execute(program: Program) {
        program.accept(this)
    }

    function openProgram(program: Program) -> bool {
        mutable programDirectory: String = String(program.directory)

        if programDirectory == null || programDirectory.equals("") {
            programDirectory = String(".")
        }

        if !Directory.exists(programDirectory) {
            Directory.create(programDirectory)
                catch _ (error: dirError())
                    return false
        }

        {
            mutable outputFilePath: VarString = VarString(programDirectory)
            outputFilePath.append("/")
            outputFilePath.append(program.name)

            // Build and write the project file
            {
                mutable projectFile: VarString = VarString()
                buildProjectFileString(projectFile, program)
                {
                    mutable projectFilePath: VarString  = VarString(outputFilePath)
                    projectFilePath.append(".project")
                    File.writeFromString(projectFilePath , projectFile)
                        catch _ (error: fileError)
                            return false
                }
            }

            // Build and write the main header file
            {
                mutable headerFile: VarString = VarString()
                buildMainHeaderFileString(headerFile, program)
                {
                    mutable headerFilePath: VarString  = VarString(outputFilePath)
                    headerFilePath.append(".h")
                    File.writeFromString(headerFilePath, headerFile)
                        catch _ (error: fileError)
                            return false
                }
            }

            collectInheritances(program)
        }

        return true
    }

    function collectInheritances(program: Program) {
        let compilationUnits: [CompilationUnit] = program.compilationUnits
        for compilationUnit: CompilationUnit in compilationUnits
            collectInheritancesInCompilationUnit(compilationUnit)
    }

    function collectInheritancesInCompilationUnit(compilationUnit: CompilationUnit) {
        if compilationUnit.statements != null {
            let statements: [TerminatedStatement] = compilationUnit.statements
            for terminatedStatement: TerminatedStatement in statements {
                if terminatedStatement.statement != null {
                    if terminatedStatement.statement is ClassDeclaration {
                        let classDeclaration: ClassDeclaration = terminatedStatement.statement as ClassDeclaration
                        classes.push(classDeclaration.name)
                        if classDeclaration.typeInheritanceClause != null {
                            let inheritanceClause: TypeInheritanceClause  = classDeclaration.typeInheritanceClause
                            let inheritances: [Inheritance] = inheritanceClause.inheritances
                            for inheritance: Inheritance in inheritances {
                                registerInheritance(classDeclaration.name, inheritance.typeIdentifier.name)
                            }
                        }
                    }
                }
            }
        }
    }

    function registerInheritance(className: String, baseName: String) {
        mutable inherit: Inherits = null
        for inh: Inherits in inherits {
            if inh.name.equals(baseName)
             inherit = inh
        }

        if inherit == null {
            inherit = Inherits(baseName)
            inherits.push(inherit)
        }
        inherit.inheritors.push(className)
    }
    
    function closeProgram(program: Program) {
    }

    function openCompilationUnit(compilationUnit: CompilationUnit) -> bool {
        moduleName = compilationUnit.fileName
        headerIndentLevel = 0
        sourceIndentLevel = 0
        declaringClassMember = false
        inParameterClause = false

        if !(compilationUnit.parent is Program)
            return false

        let programName: String = ((compilationUnit.parent) as Program).name

        // Build and write the header file
        if !moduleName.equals(programName) {
            headerFile = VarString()
            headerFile.append("#ifndef __")
            headerFile.append(programName)
            headerFile.append("__")
            headerFile.append(moduleName)
            headerFile.append("__\n")
            headerFile.append("#define __")
            headerFile.append(programName)
            headerFile.append("__")
            headerFile.append(moduleName)
            headerFile.append("__\n#include \"")
            headerFile.append(programName)
            headerFile.append(".h\"\nusing namespace scaly;\nnamespace ")
            headerFile.append(programName)
            headerFile.append(" {")
        }

        // Begin cpp file
        sourceFile = VarString(0, 4096)
        sourceFile.append("#include \"")
        sourceFile.append(programName)
        sourceFile.append(".h\"\nusing namespace scaly;\nnamespace ")
        sourceFile.append(programName)
        sourceFile.append(" {\n\n")
        
        if isTopLevelFile(compilationUnit)
            sourceFile.append("int _main(_Vector<String>* args) {\n_Region _rp; _Page* _p = _rp.get();\n\n")

        return true
    }
    
    function isTopLevelFile(compilationUnit: CompilationUnit) -> bool {
        let statements: [TerminatedStatement] = compilationUnit.statements
        for statement: TerminatedStatement in statements {
            if statement.statement is Expression
                return true
        }
            
        return false
    }

    function closeCompilationUnit(compilationUnit: CompilationUnit) {
        if !(compilationUnit.parent) is Program
            return

        let programName: String = ((compilationUnit.parent) as Program).name
        let programDirectory: String = ((compilationUnit.parent) as Program).directory

        // Close and write cpp file

        mutable outputFilePath: VarString  = VarString(programDirectory)
        outputFilePath.append('/')
        let fileNameWithoutExtension: String = Path.getFileNameWithoutExtension(compilationUnit.fileName)
        outputFilePath.append(fileNameWithoutExtension)

        if !moduleName.equals(programName) {
            headerFile.append("\n\n}\n#endif // __scalyc__")
            headerFile.append(moduleName)
            headerFile.append("__\n")
            let headerFilePath: VarString = VarString(outputFilePath)
            headerFilePath.append(".h")
            File.writeFromString(headerFilePath, headerFile)
                catch _ (error: fileError)
                    return
        }

        if isTopLevelFile(compilationUnit)
            sourceFile.append("\nreturn 0;\n")

        sourceFile.append("\n}\n")
        if isTopLevelFile(compilationUnit)
            sourceFile.append("\n}\n")

        mutable sourceFilePath: VarString = VarString(outputFilePath)
        sourceFilePath.append(".cpp")
        File.writeFromString(sourceFilePath, sourceFile)
            catch _ (error: fileError)
                return
    }

    function openTerminatedStatement(terminatedStatement: TerminatedStatement) -> bool {
        indentSource()
        if terminatedStatement.statement is SimpleExpression {
            let simpleExpression: SimpleExpression = terminatedStatement.statement as SimpleExpression
            if simpleExpression.prefixExpression.expression.primaryExpression is IdentifierExpression {
                let binaryOps: [BinaryOp] = simpleExpression.binaryOps
                if binaryOps != null {
                    if binaryOps.length() == 1 {
                        let binaryOp: BinaryOp = binaryOps[0]
                        if binaryOp is Assignment {
                            let assignment: Assignment = binaryOp as Assignment
                            mutable memberName: String = getMemberIfCreatingObject(assignment)
                            if (memberName != null) && (!inInitializer(assignment)) {
                                sourceFile.append("if (")
                                sourceFile.append(memberName)
                                sourceFile.append(" != nullptr)\n")
                                sourceIndentLevel++
                                this.indentSource()
                                sourceFile.append(memberName)
                                sourceFile.append("->getPage()->clear();\n")
                                sourceIndentLevel--
                                this.indentSource()
                            }
                        }
                    }
                }
                let postfixes: [Postfix] postfixes = simpleExpression.prefixExpression.expression.postfixes
                if postfixes != null {
                    for postfix: Postfix in postfixes {
                        if postfix is FunctionCall {
                            let functionCall: FunctionCall = postfix as FunctionCall
                            if functionCall.catchClauses != null {
                                let identifierExpression: IdentifierExpression = simpleExpression.prefixExpression.expression.primaryExpression as IdentifierExpression
                                sourceFile.append("auto _")
                                sourceFile.append(identifierExpression.name)
                                sourceFile.append("_error = ")
                            }
                        }
                    }
                }
            }
        }
        return true
    }

    function closeTerminatedStatement(terminatedStatement: TerminatedStatement) {

        if terminatedStatement.statement is ClassDeclaration
            return;

        if terminatedStatement.statement is EnumDeclaration
            return;

        {
            let bindingInitializer: BindingInitializer = null
            if terminatedStatement.statement is ConstantDeclaration {
                {
                    let constantDeclaration: ConstantDeclaration = terminatedStatement.statement as ConstantDeclaration
                    if constantDeclaration.initializer is BindingInitializer {
                        bindingInitializer = constantDeclaration.initializer
                    }
                }
                {
                    let variableDeclaration: VariableDeclaration = terminatedStatement.statement as VariableDeclaration
                    if variableDeclaration.initializer is BindingInitializer {
                        bindingInitializer = variableDeclaration.initializer
                    }
                }
                {
                    let mutableDeclaration: MutableDeclaration = terminatedStatement.statement as MutableDeclaration
                    if mutableDeclaration.initializer is BindingInitializer {
                        bindingInitializer = mutableDeclaration.initializer
                    }
                }
            }
            if bindingInitializer != null {
                if bindingInitializer.initializer is PatternInitializer {
                    let patternInitializer: PatternInitializer = bindingInitializer.initializer as PatternInitializer
                    if isCatchingFunctionCall(patternInitializer)
                        return
                }
            }
        }

        if terminatedStatement.statement is SimpleExpression {
            let expression: SimpleExpression = terminatedStatement.statement as SimpleExpression
            let primaryExpression: PrimaryExpression = expression.prefixExpression.expression.primaryExpression

            if primaryExpression is IfExpression
                return;

            if primaryExpression is SwitchExpression
                return;

            if primaryExpression is ForExpression
                return;

            if primaryExpression is WhileExpression
                return;

            if primaryExpression is IdentifierExpression {
                let postfixExpression: PostfixExpression = expression.prefixExpression.expression
                if postfixExpression.postfixes != null {
                    let postfixes: [Postfix] = postfixExpression.postfixes
                    for postfix: Postfix in postfixes {
                        if postfix is FunctionCall {
                            let functionCall: FunctionCall = postfix as FunctionCall
                            if catchesError(functionCall)
                                return
                        }
                    }
                }
            }
        }

        if terminatedStatement.statement is CodeBlock
            return;
            
        sourceFile.append(";\n")
    }

    function openUseDeclaration(useDeclaration: UseDeclaration) -> bool {
        return true
    }

    function closeUseDeclaration(useDeclaration: UseDeclaration) {
    }

    function openConstantDeclaration(constantDeclaration: ConstantDeclaration) -> bool {
        constDeclaration = true

        if constantDeclaration.parent.parent.parent is ClassDeclaration
            suppressSource = true
            
        return true
    }

    function closeConstantDeclaration(constantDeclaration: ConstantDeclaration) {
        constDeclaration = false
        suppressSource = false
    }

    function openVariableDeclaration(variableDeclaration: VariableDeclaration) -> bool {

        if variableDeclaration.parent.parent.parent is ClassDeclaration
            suppressSource = true

        return true
    }

    function closeVariableDeclaration(variableDeclaration: VariableDeclaration) {
        suppressSource = false
    }

    function openMutableDeclaration(mutableDeclaration: MutableDeclaration) -> bool {

        if mutableDeclaration.parent.parent.parent is ClassDeclaration
            suppressSource = true

        return true
    }

    function closeMutableDeclaration(mutableDeclaration: MutableDeclaration) {
        suppressSource = false
    }

    function openFunctionDeclaration(functionDeclaration: FunctionDeclaration) -> bool {

        if functionDeclaration.body == null {
            abstractFunction = true
            suppressSource = true
        }
        else {
            abstractFunction = false
            suppressSource = false
        }

        if functionDeclaration.modifiers != null {
            let modifiers: [Modifier] = functionDeclaration.modifiers
            for modifier: Modifier in modifiers {
                if modifier is StaticWord
                    staticFunction = true
            }
        }

        return true
    }

    function closeFunctionDeclaration(functionDeclaration: FunctionDeclaration) {

        if abstractFunction {
            headerFile.append(" = 0")
            abstractFunction = false
        }

        staticFunction = false
        suppressHeader = false
        suppressSource = false
    }

    function openEnumDeclaration(enumDeclaration: EnumDeclaration) -> bool {
        let enumDeclarationName: String = enumDeclaration.name

        headerFile.append("\n\nclass ")
        headerFile.append(enumDeclarationName)
        headerFile.append(";\n")
        sourceFile.append("long ")
        sourceFile.append(enumDeclarationName)
        sourceFile.append("::getErrorCode() {\n    return (long)errorCode;\n}\n\nvoid* ")
        sourceFile.append(enumDeclarationName)
        sourceFile.append("::getErrorInfo() {\n    return errorInfo;\n}\n\n")

        return true
    }

    function closeEnumDeclaration(enumDeclaration: EnumDeclaration) {
        let enumDeclarationName: String = enumDeclaration.name
        let members: [EnumMember] = enumDeclaration.members

        if members != null {
            headerFile.append("enum _")
            headerFile.append(enumDeclarationName)
            headerFile.append("Code {\n")
            var i: int = 0
            for member: EnumMember in members {
                headerFile.append("    _")
                headerFile.append(enumDeclarationName)
                headerFile.append("Code_")
                headerFile.append(member.enumCase.name)
                if i == 0
                    headerFile.append(" = 1")
                headerFile.append(",\n")
                i++
            }
            headerFile.append("};\n\n")
        }

        headerFile.append("class ")
        headerFile.append(enumDeclarationName)
        headerFile.append(" : public Object {\npublic:\n    ")
        headerFile.append(enumDeclarationName)
        headerFile.append("(_")
        headerFile.append(enumDeclarationName)
        headerFile.append("Code errorCode)\n    : errorCode(errorCode), errorInfo(0) {}\n\n")

        if members != null {
            for member: EnumMember in members {
                if member.parameterClause {
                    headerFile.append("    ")
                    headerFile.append(enumDeclarationName)
                    headerFile.append("(_")
                    headerFile.append(enumDeclarationName)
                    headerFile.append("_")
                    headerFile.append(member.enumCase.name)
                    headerFile.append("* ")
                    headerFile.append(member.enumCase.name)
                    headerFile.append(")\n    : errorCode(_")
                    headerFile.append(enumDeclarationName)
                    headerFile.append("Code_")
                    headerFile.append(member.enumCase.name)
                    headerFile.append("), errorInfo(")
                    headerFile.append(member.enumCase.name)
                    headerFile.append(") {}\n\n")
                }
            }
        }

        headerFile.append("    long getErrorCode();\n    void* getErrorInfo();\n\n")

        if members != null {
            for member: EnumMember in members {
                if member.parameterClause {
                    headerFile.append("    _")
                    headerFile.append(enumDeclarationName)
                    headerFile.append("_")
                    headerFile.append(member.enumCase.name)
                    headerFile.append("* get_")
                    headerFile.append(member.enumCase.name)
                    headerFile.append("();\n")
                }
            }
        }
        headerFile.append("\nprivate:\n    _")
        headerFile.append(enumDeclarationName)
        headerFile.append("Code errorCode;\n    void* errorInfo;\n};")
    }

    function openClassDeclaration(classDeclaration: ClassDeclaration) -> bool {
        headerFile.append("\n\nclass ")
        headerFile.append(classDeclaration.name)
        if classDeclaration.body == null {
            headerFile.append(";")
            return false
        }

        headerFile.append(" : public ")
        if classDeclaration.typeInheritanceClause != null {
            let inheritances: [Inheritance] = classDeclaration.typeInheritanceClause.inheritances
            var i: int = 0
            for inheritance: Inheritance in inheritances {
                if i > 0
                    headerFile.append(", ");
                    var typeIdentifier: TypeIdentifier = inheritance.typeIdentifier
                headerFile.append(typeIdentifier.name)
                i++
            }
        }
        else {
            headerFile.append("Object")
        }
        headerFile.append(" {\n")
        headerFile.append("public:")
        headerIndentLevel++
        return true
    }

    function closeClassDeclaration(classDeclaration: ClassDeclaration) {
        headerFile.append("\n")
        if classDeclaration.typeInheritanceClause != null {
            headerFile.append("\n")
            indentHeader()
            headerFile.append("virtual bool _is")
            headerFile.append(classDeclaration.name)
            headerFile.append("();")
            sourceFile.append("bool ")
            sourceFile.append(classDeclaration.name)
            sourceFile.append("::_is")
            sourceFile.append(classDeclaration.name)
            sourceFile.append("() { return true; }\n\n")
        }
        {
            mutable derivedClasses: [String] = [String]()
            collectDerivedClasses(derivedClasses, String(classDeclaration.name))
            for derivedClass: String in derivedClasses {
                headerFile.append("\n")
                indentHeader()
                headerFile.append("virtual bool _is")
                headerFile.append(derivedClass)
                headerFile.append("();")
                sourceFile.append("bool ");
                sourceFile.append(classDeclaration.name);
                sourceFile.append("::_is");
                sourceFile.append(derivedClass)
                sourceFile.append("() { return false; }\n")
            }
            if derivedClasses.length() > 0
                sourceFile.append("\n")
        }
        headerIndentLevel--
        headerFile.append("\n};")
    }

    function openInitializerDeclaration(initializerDeclaration: InitializerDeclaration) -> bool {

        if !initializerDeclaration.parent.parent.parent is ClassDeclaration
            return false

        let classDeclarationName: String = ((initializerDeclaration.parent.parent.parent) as Program).name

        headerFile.append(classDeclarationName)
        headerFile.append("(")
        
        sourceFile.append(classDeclarationName)
        sourceFile.append("::")
        sourceFile.append(classDeclarationName)
        sourceFile.append("(")
        
        return true
    }

    function closeInitializerDeclaration(initializerDeclaration: InitializerDeclaration) {
        sourceFile.append("\n")
        suppressHeader = false
    }

    function openCodeBlock(codeBlock: CodeBlock) -> bool {
        sourceFile.append("{\n")
        sourceIndentLevel++

        if localAllocations(codeBlock) {
            indentSource()
            sourceFile.append("_Region _region; _Page* _p = _region.get();\n")
        }

        suppressHeader = true
        return true
    }

    function localAllocations(codeBlock: CodeBlock) -> bool {
        let terminatedStatements: [TerminatedStatement] = codeBlock.statements
        if terminatedStatements != null {
            for terminatedStatement: TerminatedStatement in terminatedStatements {
                let bindingInitializer: BindingInitializer = null            
                let statement: Statement = terminatedStatement.statement
                if statement is MutableDeclaration {
                    let mutableDeclaration: MutableDeclaration = statement as MutableDeclaration
                    bindingInitializer = mutableDeclaration.initializer
                }
                if bindingInitializer != null {
                    if bindingInitializer.initializer != null {
                        let patternInitializer: PatternInitializer = bindingInitializer.initializer
                        if patternInitializer.pattern is IdentifierPattern {
                            let identifierPattern: IdentifierPattern = patternInitializer.pattern as IdentifierPattern
                            if identifierPattern.annotationForType != null {
                                let type: Type = identifierPattern.annotationForType.annotationForType
                                if type is ArrayType
                                    return true
                                if type is TypeIdentifier {
                                    let typeIdentifier: TypeIdentifier = type as TypeIdentifier
                                    if isClass(typeIdentifier.name) {
                                        if getFunctionCall(patternInitializer) != null
                                            return true
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return false
    }

    function getFunctionCall(patternInitializer: PatternInitializer) -> existing FunctionCall {
        if patternInitializer.initializer != null {
            let expression: Expression = patternInitializer.initializer.expression
            if expression is SimpleExpression {
                let simpleExpression: SimpleExpression = expression as SimpleExpression
                let prefixExpression: PrefixExpression = simpleExpression.prefixExpression
                let postfixExpression: PostfixExpression = prefixExpression.expression
                if postfixExpression.primaryExpression is IdentifierExpression {
                    if postfixExpression.postfixes != null {
                        let postfixes: [Postfix] = postfixExpression.postfixes
                        for postfix: Postfix in postfixes {
                            if postfix is FunctionCall {
                                return postfix as FunctionCall
                            }
                        }
                    }
                }
            }
        }
        return null
    }

    function isCatchingFunctionCall(patternInitializer: PatternInitializer) -> bool {
        if catchesError(getFunctionCall(patternInitializer))
            return true

        return false
    }

    function closeCodeBlock(codeBlock: CodeBlock) {
        if codeBlock.parent is FunctionDeclaration {
            let functionDeclaration: FunctionDeclaration = codeBlock.parent as FunctionDeclaration
            if (functionDeclaration.signature.throwsClause != null) && (functionDeclaration.signature.result == null) {
                indentSource()
                sourceFile.append("return nullptr;\n")
            }
        }
 
        sourceIndentLevel--
        indentSource()
        sourceFile.append("}\n")
        if codeBlock.parent is FunctionDeclaration
            sourceFile.append("\n")
    }

    function openSimpleExpression(simpleExpression: SimpleExpression) -> bool {
        if simpleExpression.binaryOps != null {
            let binaryOps: [BinaryOp] = simpleExpression.binaryOps
            for binaryOp: BinaryOp in binaryOps {
                if binaryOp is TypeCast {
                    let typeCast: TypeCast = binaryOp as TypeCast
                    if  typeCast.objectType is TypeIdentifier {
                        let typeIdentifier: TypeIdentifier = typeCast.objectType as TypeIdentifier
                        sourceFile.append("(")
                        sourceFile.append(typeIdentifier.name)
                        sourceFile.append("*)")
                        simpleExpression.prefixExpression.accept(this)
                        return false
                    }
                }
            }
        }
        return true
    }

    function closeSimpleExpression(simpleExpression: SimpleExpression) {
    }

    function openPathIdentifier(pathIdentifier: PathIdentifier) -> bool {
        return true
    }

    function closePathIdentifier(pathIdentifier: PathIdentifier) {
    }

    function visitPathItem(pathItem: PathItem) {
    }

    function openInitializer(initializer: Initializer) -> bool {
        sourceFile.append(" = ")
        return true
    }

    function closeInitializer(initializer: Initializer) {
    }

    function openBindingInitializer(bindingInitializer: BindingInitializer) -> bool {
        firstBindingInitializer = true
        return true
    }

    function closeBindingInitializer(bindingInitializer: BindingInitializer) {
    }

    function openPatternInitializer(patternInitializer: PatternInitializer) -> bool {
        if !firstBindingInitializer
            headerFile.append(", ")
        else
            firstBindingInitializer = false

        return true
    }

    function closePatternInitializer(patternInitializer: PatternInitializer) {
    }

    function openAdditionalInitializer(additionalInitializer: AdditionalInitializer) -> bool {
        return true
    }

    function closeAdditionalInitializer(additionalInitializer: AdditionalInitializer) {
    }

    function visitOverrideWord(overrideWord: OverrideWord) {
    }

    function visitStaticWord(staticWord: StaticWord) {
    }

    function visitIdentifierFunction(identifierFunction: IdentifierFunction) {
    }

    function openFunctionSignature(functionSignature: FunctionSignature) -> bool {

        if !functionSignature.parent is FunctionDeclaration
            return false

        let functionName: FunctionName = (functionSignature.parent as FunctionDeclaration).name
        if !functionName is IdentifierFunction
            return false

        let identifierFunctionName: String = (functionName as IdentifierFunction).name

        if staticFunction
            headerFile.append("static ")
        else
            headerFile.append("virtual ")

        inFunctionReturn = true

        if functionSignature.result == null {
            if functionSignature.throwsClause == null {
                headerFile.append("void")
                if !suppressSource
                    sourceFile.append("void")
            }
            else {
                appendCppType(headerFile, functionSignature.throwsClause.throwsType)
                if !suppressSource
                    appendCppType(sourceFile, functionSignature.throwsClause.throwsType)
            }
        }
        else {
            if functionSignature.throwsClause != null {
                headerFile.append("_Result<")

                if !suppressSource
                    sourceFile.append("_Result<");

                if functionSignature.result.resultType is TypeIdentifier {
                    let typeId: TypeIdentifier = functionSignature.result.resultType as TypeIdentifier
                    appendCppTypeName(headerFile, typeId)
                    if !suppressSource
                        appendCppTypeName(sourceFile, typeId)
                }
                else { 
                    if functionSignature.result.resultType is ArrayType {
                        let arrayType: ArrayType = functionSignature.result.resultType as ArrayType
                        if arrayType.elementType is TypeIdentifier {
                            headerFile.append("_Vector<")
                            let typeId: TypeIdentifier = arrayType.elementType as TypeIdentifier
                            appendCppTypeName(headerFile, typeId)
                            headerFile.append(">")
                            if !suppressSource {
                                sourceFile.append("_Vector<")
                                appendCppTypeName(sourceFile, typeId)
                                sourceFile.append(">")
                            }
                        }
                    }
                }
                headerFile.append(", ")
                appendCppTypeName(headerFile, (functionSignature.throwsClause.throwsType) as TypeIdentifier)
                headerFile.append(">")
                if !suppressSource {
                    sourceFile.append(", ")
                    appendCppTypeName(sourceFile, (functionSignature.throwsClause.throwsType) as TypeIdentifier)
                    sourceFile.append(">")
                }
            }
            else {
                if functionSignature.result.resultType is TypeIdentifier {
                    let typeId: TypeIdentifier = functionSignature.result.resultType as TypeIdentifier
                    appendCppTypeName(headerFile, typeId)
                    if !suppressSource
                        appendCppTypeName(sourceFile, typeId)
                    if isClass(typeId.name) {
                        headerFile.append("*")
                        if !suppressSource
                            sourceFile.append("*")
                    }
                }
                else {
                    if functionSignature.result.resultType is ArrayType {
                        let arrayType: ArrayType = functionSignature.result.resultType as ArrayType
                        if arrayType.elementType is TypeIdentifier {
                            headerFile.append("_Vector<")
                            let typeId: TypeIdentifier = arrayType.elementType as TypeIdentifier
                            appendCppTypeName(headerFile, typeId)
                            headerFile.append(">")
                            if !suppressSource {
                                sourceFile.append("_Vector<")
                                appendCppTypeName(sourceFile, typeId)
                                sourceFile.append(">")
                            }
                        }
                    }
                }
            }
        }

        inFunctionReturn = false
        headerFile.append(" ")
        if !suppressSource {
            sourceFile.append(" ")    
            if functionSignature.parent.parent.parent.parent is ClassDeclaration {
                let classDeclaration: ClassDeclaration = functionSignature.parent.parent.parent.parent as ClassDeclaration
                sourceFile.append(classDeclaration.name)
                sourceFile.append("::")
            }
        }
        headerFile.append(identifierFunctionName)
        headerFile.append("(")
        if !suppressSource {
            sourceFile.append(identifierFunctionName)
            sourceFile.append("(")
        }
        if functionSignature.result != null {
            if functionSignature.result.resultType is TypeIdentifier {
                let typeId: TypeIdentifier = functionSignature.result.resultType as TypeIdentifier
                if isClass(typeId.name) {
                    if functionSignature.result.existingObject == null {
                        headerFile.append("_Page* _rp")
                        if !suppressSource
                            sourceFile.append("_Page* _rp")
                        if (functionSignature.parameterClause.parameters) || (functionSignature.throwsClause) {
                            headerFile.append(", ")
                            if !suppressSource
                                sourceFile.append(", ")
                        }
                    }
                }
            }
            else {
                if functionSignature.result.resultType is ArrayType {
                    if functionSignature.result.existingObject == null {
                        headerFile.append("_Page* _rp")
                        if !suppressSource
                            sourceFile.append("_Page* _rp")
                        if (functionSignature.parameterClause.parameters != null) || (functionSignature.throwsClause != null) {
                            headerFile.append(", ")
                            if !suppressSource
                                sourceFile.append(", ")
                        }
                    }
                }
            }
        }
        if functionSignature.throwsClause != null {
            headerFile.append("_Page* _ep")
            if !suppressSource
                sourceFile.append("_Page* _ep")
            if functionSignature.parameterClause.parameters {
                headerFile.append(", ")
                if !suppressSource
                    sourceFile.append(", ")
            }
        }

        return true
    }

    function closeFunctionSignature(functionSignature: FunctionSignature) {
        suppressHeader = true
    }

    function openFunctionResult(functionResult: FunctionResult) -> bool {
        return false
    }

    function closeFunctionResult(functionResult: FunctionResult) {
    }

    function visitExistingClause(existingClause: ExistingClause) {
    }

    function openParameterClause(parameterClause: ParameterClause) -> bool {
        firstParameter = true
        inParameterClause = true

        return true
    }

    function closeParameterClause(parameterClause: ParameterClause) {
        headerFile.append(")")

        if !suppressSource
            sourceFile.append(") ")

        inParameterClause = false
    }

    function openConstParameter(constParameter: ConstParameter) -> bool {
        let constParameterName: String = constParameter.name
        constDeclaration = true
        writeParameter(constParameterName, constParameter.parameterType)
        constDeclaration = false

        return false
    }

    function writeParameter(name: String, parameterType: Type) {
        if !firstParameter {
            headerFile.append(", ")
            if !suppressSource
                sourceFile.append(", ")
        }
        else {
            firstParameter = false
        }

        parameterType.accept(this)
        headerFile.append(" ");
        headerFile.append(name);
        if !suppressSource {
            sourceFile.append(" ");
            sourceFile.append(name)
        }
    }

    function isClass(name: String) -> bool {
        if (    name.equals("String")
            ||  name.equals("VarString")
            ||  name.equals("File")
            ||  name.equals("Directory")
            ||  name.equals("Path")
            ||  name.equals("DirectoryError")
            ||  name.equals("FileError")
            ||  name.equals("ParserError")
            ||  name.equals("CppError")
            ||  name.equals("CompilerError")
           )
        {
            return true
        }

        for className: String in classes {
            if className.equals(name) {
                return true
            }
        }

        return false
    }

    function closeConstParameter(constParameter: ConstParameter) {
        headerFile.append(constParameter.name)
    }

    function openVarParameter(varParameter: VarParameter) -> bool {
        writeParameter(varParameter.name, varParameter.parameterType)
        return false
    }

    function closeVarParameter(varParameter: VarParameter) {
        let varParameterName: String = varParameter.name
        headerFile.append(varParameterName)
    }

    function openThrowsClause(throwsClause: ThrowsClause) -> bool {
        return false
    }

    function closeThrowsClause(throwsClause: ThrowsClause) {
    }

    function openEnumMember(enumMember: EnumMember) -> bool {
        if !enumMember.parent is EnumDeclaration
            return false

        let enumDeclarationName: String = ((enumMember.parent) as EnumDeclaration).name
        if enumMember.parameterClause {
            headerFile.append("\nclass _")
            headerFile.append(enumDeclarationName)
            headerFile.append("_")
            headerFile.append(enumMember.enumCase.name);
            headerFile.append(" : public Object {\npublic:\n    _")
            headerFile.append(enumDeclarationName)
            headerFile.append("_")
            headerFile.append(enumMember.enumCase.name);
            headerFile.append("(")
            sourceFile.append("_")
            sourceFile.append(enumDeclarationName)
            sourceFile.append("_")
            sourceFile.append(enumMember.enumCase.name)
            sourceFile.append("::_")
            sourceFile.append(enumDeclarationName)
            sourceFile.append("_")
            sourceFile.append(enumMember.enumCase.name)
            sourceFile.append("(")
        }

        inEnumMember = true
        return true
    }

    function closeEnumMember(enumMember: EnumMember) {
        if enumMember.parameterClause != null {
            sourceFile.append("\n")
            headerFile.append(";\n\n")

            let parameters: [Parameter] = enumMember.parameterClause.parameters
            if parameters != null {
                sourceFile.append(": ")
                var pos: unsigned = 0
                for parameter: Parameter in parameters {
                    if parameter is ConstParameter {
                        let constParameter: ConstParameter = parameter as ConstParameter
                        headerFile.append("    ")
                        appendCppType(headerFile, constParameter.parameterType)
                        headerFile.append(" ")
                        headerFile.append(constParameter.name)
                        headerFile.append(";\n")
                        if pos != 0
                            sourceFile.append(", ")
                        sourceFile.append(constParameter.name)
                        sourceFile.append("(")
                        sourceFile.append(constParameter.name)
                        sourceFile.append(")")
                    }
                    pos++
                }
            }

            headerFile.append("};\n")
            sourceFile.append(" { }\n\n_")
            let enumDeclarationName: String = ((enumMember.parent) as EnumDeclaration).name
            sourceFile.append(enumDeclarationName)
            sourceFile.append("_")
            sourceFile.append(enumMember.enumCase.name)
            sourceFile.append("* ")
            sourceFile.append(enumDeclarationName)
            sourceFile.append("::get_")
            sourceFile.append(enumMember.enumCase.name)
            sourceFile.append("() {\n    return (_")
            sourceFile.append(enumDeclarationName)
            sourceFile.append("_")
            sourceFile.append(enumMember.enumCase.name)
            sourceFile.append("*)errorInfo;\n}\n\n")
        }

        inEnumMember = false
    }

    function appendCppType(mutable s: VarString, type: Type) {
        if type is TypeIdentifier {
            let typeId: TypeIdentifier = type as TypeIdentifier
            appendCppTypeName(s, typeId)
            if isClass(typeId.name) {
                s.append("*")
            }
        }
        else {
            if type is ArrayType {
                var arrayType: ArrayType = type as ArrayType
                var type: Type = arrayType.elementType
                if type is TypeIdentifier {
                    var typeId: TypeIdentifier = type as TypeIdentifier
                    s.append("_Vector<")
                    appendCppTypeName(s, typeId)
                    s.append(">*")
                }
            }
        }
    }

    function visitEnumCase(enumCase: EnumCase) {
    }

    function openAdditionalCase(additionalCase: AdditionalCase) -> bool {
        return true
    }

    function closeAdditionalCase(additionalCase: AdditionalCase) {
    }

    function openClassBody(classBody: ClassBody) -> bool {
        return true
    }

    function closeClassBody(classBody: ClassBody) {
    }

    function indentHeader() {
        var i: unsigned = 0
        while i < headerIndentLevel {
            headerFile.append("    ")
            i++
        }
    }

    function indentSource() {
        var i: unsigned = 0
        while i < sourceIndentLevel {
            sourceFile.append("    ")
            i++
        }
    }

    function collectDerivedClasses(mutable derivedClasses: [String], className: String) {
        for inherit: Inherits in inherits {
            if inherit.name.equals(className)
                appendDerivedClasses(derivedClasses, inherit.inheritors)
        }
    }

    function appendDerivedClasses(mutable derivedClasses: [String], mutable inheritors: [String]) {
        for inheritor: String in inheritors {
            derivedClasses.push(inheritor)
            collectDerivedClasses(derivedClasses, inheritor)
        }
    }

    function openGenericArgumentClause(genericArgumentClause: GenericArgumentClause) -> bool {
        return true
    }

    function closeGenericArgumentClause(genericArgumentClause: GenericArgumentClause) {
    }

    function visitGenericParameter(genericParameter: GenericParameter) {
    }

    function openClassMember(classMember: ClassMember) -> bool {
        headerFile.append("\n")
        indentHeader()
        declaringClassMember = true

        return true
    }

    function closeClassMember(classMember: ClassMember) {
        headerFile.append(";")
        declaringClassMember = false
    }

    function openPrefixExpression(prefixExpression: PrefixExpression) -> bool {
        if prefixExpression.prefixOperator != null
            sourceFile.append(prefixExpression.prefixOperator)

        return true
    }

    function closePrefixExpression(prefixExpression: PrefixExpression) {
    }

    function openPostfixExpression(postfixExpression: PostfixExpression) -> bool {
        if postfixExpression.postfixes != null {
            let postfixes: [Postfix] = postfixExpression.postfixes
            if (postfixes[0]) is Subscript {
                sourceFile.append("*(*")
            }
        }

        return true
    }

    function closePostfixExpression(postfixExpression: PostfixExpression) {
    }

    function openBinaryOperation(binaryOperation: BinaryOperation) -> bool {
        sourceFile.append(" ")
        sourceFile.append(binaryOperation.binaryOperator)
        sourceFile.append(" ")

        return true
    }

    function closeBinaryOperation(binaryOperation: BinaryOperation) {
    }

    function openAssignment(assignment: Assignment) -> bool {
        sourceFile.append(" = ")

        return true
    }

    function inInitializer(node: SyntaxNode) -> bool {
        if node is InitializerDeclaration
            return true

        if node.parent == null
            return false

        return inInitializer(node.parent)
    }

    function inReturn(node: SyntaxNode) -> bool {
        if node is ReturnExpression
            return true

        if node.parent == null
            return false

        return inReturn(node.parent)
    }

    function inThrow(node: SyntaxNode) -> bool {
        if node is ThrowExpression
            return true

        if node.parent == null
            return false

        return inThrow(node.parent)
    }

    function getMemberIfCreatingObject(assignment: Assignment) -> String {
        let functionName: String = getFunctionName(assignment)
        if functionName == null {
            return null
        }

        if assignment.expression is SimpleExpression {
            if isClass(functionName) || isCreatingObject(functionName, assignment) {
                if assignment.parent is SimpleExpression {
                    let simpleExpression: SimpleExpression = (assignment.parent) as SimpleExpression
                    if simpleExpression.prefixExpression.prefixOperator == 0 {
                        let leftSide: PostfixExpression = simpleExpression.prefixExpression.expression
                        if (leftSide.postfixes == 0) && (leftSide.primaryExpression is IdentifierExpression) {
                            let memberExpression: IdentifierExpression = (leftSide.primaryExpression) as IdentifierExpression
                            mutable memberName: String = String(memberExpression.name)
                            var classDeclaration: ClassDeclaration = getClassDeclaration(assignment)
                            if classDeclaration != null {
                                return String(memberName)
                            }
                        }
                    }
                }
            }
        }
        
        return null
    }

    function getFunctionName(assignment: Assignment) -> String {
        if assignment.expression is SimpleExpression {
            let simpleExpression: SimpleExpression = (assignment.expression) as SimpleExpression
            let prefixExpression: PrefixExpression = simpleExpression.prefixExpression
            if prefixExpression.prefixOperator == null {
                let rightSide: PostfixExpression = prefixExpression.expression
                if rightSide.primaryExpression is IdentifierExpression {
                    let classExpression: IdentifierExpression = (rightSide.primaryExpression) as IdentifierExpression
                    return String(classExpression.name)
                }
                else {
                    if rightSide.primaryExpression is InitializerCall {
                        let initializerCall: InitializerCall = (rightSide.primaryExpression) as InitializerCall
                        if initializerCall.typeToInitialize is ArrayType {
                            let arrayType: ArrayType = (initializerCall.typeToInitialize) as ArrayType
                            if arrayType.elementType is TypeIdentifier {
                                let typeIdentifier: TypeIdentifier = (arrayType.elementType) as TypeIdentifier
                                return String(typeIdentifier.name)
                            }
                        }
                    }
                }
            }
        }

        return null
    }
    
    function isCreatingObject(functionName: String, node: SyntaxNode) -> bool {
        var classDeclaration: ClassDeclaration = getClassDeclaration(node)
        if classDeclaration == null
            return false

        let members: [ClassMember] = classDeclaration.body.members
        if members == null
            return false

        for member: ClassMember in members {
            if member.declaration is FunctionDeclaration {
                let functionDeclaration: FunctionDeclaration = (member.declaration) as FunctionDeclaration
                if functionDeclaration.name is IdentifierFunction {
                    let identifierFunction: IdentifierFunction = (functionDeclaration.name) as IdentifierFunction
                    if identifierFunction.name.equals(functionName)
                        return true
                }
            } 
        }

        return false
    }

    function getClassDeclaration(node: SyntaxNode) -> existing ClassDeclaration {
        if node is ClassDeclaration
            return node as ClassDeclaration

        if node.parent != null
            return getClassDeclaration(node.parent)
        
        return null
    }
    
    function isVariableMember(memberName: String, classDeclaration: ClassDeclaration) -> bool {
        let classMembers: [ClassMember] = classDeclaration.body.members
        for member: ClassMember in classMembers {
            mutable bindingInitializer: BindingInitializer = null
            if member.declaration is MutableDeclaration {
                let mutableDeclaration: MutableDeclaration = (member.declaration) as MutableDeclaration
                bindingInitializer = mutableDeclaration.initializer
            }
            if member.declaration is VariableDeclaration {
                let variableDeclaration: VariableDeclaration = (member.declaration) as VariableDeclaration
                bindingInitializer = variableDeclaration.initializer
            }
            
            if bindingInitializer == null
                continue
                
            let patternInitializer: PatternInitializer = bindingInitializer.initializer
            if patternInitializer.pattern is IdentifierPattern {
                let identifierPattern: IdentifierPattern = (patternInitializer.pattern) as IdentifierPattern
                if identifierPattern.identifier.equals(memberName)
                    return true
            }
        }

        return false
    }

    function closeAssignment(assignment: Assignment) {
    }

    function openTypeQuery(typeQuery: TypeQuery) -> bool {
        sourceFile.append("->_is")

        return true
    }

    function closeTypeQuery(typeQuery: TypeQuery) {
    }

    function openTypeCast(typeCast: TypeCast) -> bool {
        return true
    }

    function closeTypeCast(typeCast: TypeCast) {
    }

    function openCatchClause(catchClause: CatchClause) -> bool {
        if catchClause.parent is FunctionCall {
            let functionCall: FunctionCall = (catchClause.parent) as FunctionCall
            {
                var bindingInitializer: BindingInitializer = getBindingInitializer(functionCall)
                if bindingInitializer != null {
                    let patternInitializer: PatternInitializer = bindingInitializer.initializer
                    if patternInitializer.pattern is IdentifierPattern {
                        let identifierPattern: IdentifierPattern = (patternInitializer.pattern) as IdentifierPattern
                        let catchClauses: [CatchClause] = functionCall.catchClauses
                        if catchClauses[0] == catchClause {
                            sourceFile.append(";\n")
                            indentSource()
                            identifierPattern.annotationForType.accept(this)
                            sourceFile.append(" ")
                            sourceFile.append(identifierPattern.identifier)
                            sourceFile.append(" = nullptr;\n")
                            indentSource()
                            sourceFile.append("if (_")
                            sourceFile.append(identifierPattern.identifier)
                            sourceFile.append("_result.succeeded()) {\n")
                            sourceIndentLevel++
                            indentSource()
                            sourceFile.append(identifierPattern.identifier)
                            sourceFile.append(" = _")
                            sourceFile.append(identifierPattern.identifier)                    
                            sourceFile.append("_result.getResult();\n")
                            sourceIndentLevel--
                            indentSource()
                            sourceFile.append("}\n")
                        }
                        indentSource()
                        sourceFile.append("else")
                        if catchClause.catchPattern is IdentifierCatchPattern {
                            let identifierCatchPattern: IdentifierCatchPattern = (catchClause.catchPattern) as IdentifierCatchPattern
                            sourceFile.append(" if (_")
                            sourceFile.append(identifierPattern.identifier)
                            sourceFile.append("_result.getErrorCode() == _")
                            sourceFile.append(identifierCatchPattern.name)
                            sourceFile.append("Code_")
                            var errorType: String = getErrorType(catchClause)
                            if errorType != null
                                sourceFile.append(errorType)
                            sourceFile.append(")")
                        }
                        sourceFile.append(" {\n")

                        if catchClause.catchPattern is WildCardCatchPattern {
                            if catchClause.bindingPattern != null {
                                let bindingPattern: TuplePattern = catchClause.bindingPattern
                                if bindingPattern.elements != null {
                                    if bindingPattern.elements.length() > 0 {
                                        let elements: [TuplePatternElement] = bindingPattern.elements
                                        let element: TuplePatternElement = elements[0]
                                        if element.pattern is IdentifierPattern {
                                            let pattern: IdentifierPattern = (element.pattern) as IdentifierPattern
                                            sourceIndentLevel++
                                            indentSource()
                                            sourceFile.append("auto ")
                                            sourceFile.append(pattern.identifier)                    
                                            sourceFile.append(" = _")
                                            sourceFile.append(identifierPattern.identifier)
                                            sourceFile.append("_result.getError();\n")
                                            sourceIndentLevel--
                                        }
                                    }
                                }
                            }
                        }
                        
                        sourceIndentLevel++
                        indentSource()
                        if catchClause.expression is SimpleExpression {
                            let simpleExpression: SimpleExpression = (catchClause.expression) as SimpleExpression
                            let primaryExpression: PrimaryExpression = simpleExpression.prefixExpression.expression.primaryExpression
                            if (!primaryExpression is ReturnExpression) && (!primaryExpression is BreakExpression) && (!primaryExpression is ThrowExpression) {
                                sourceFile.append(identifierPattern.identifier)
                                sourceFile.append(" = ")
                            }
                        }
                        catchClause.expression.accept(this)
                        if catchClause.expression is SimpleExpression
                            sourceFile.append(";\n")
                        sourceIndentLevel--
                        indentSource()
                        sourceFile.append("}\n")
                    }
                }
            }
            {
                var identifierExpression: IdentifierExpression = getIdentifierExpression((functionCall.parent) as PostfixExpression)
                if identifierExpression != null {
                    let catchClauses: [CatchClause] = functionCall.catchClauses
                    if catchClauses[0] == catchClause {
                        sourceFile.append(";\n")
                        indentSource()
                        sourceFile.append("if (_")
                        sourceFile.append(identifierExpression.name)
                        sourceFile.append("_error) {\n")
                        sourceIndentLevel++
                        indentSource()
                        sourceFile.append("switch (_")
                        sourceFile.append(identifierExpression.name)
                        sourceFile.append("_error->getErrorCode()) {\n")
                        sourceIndentLevel++
                    }
                    indentSource()
                    if catchClause.catchPattern is IdentifierCatchPattern {
                        sourceFile.append("case _")
                        let identifierCatchPattern: IdentifierCatchPattern = (catchClause.catchPattern) as IdentifierCatchPattern
                        sourceFile.append(identifierCatchPattern.name)
                        sourceFile.append("Code_")
                        if identifierCatchPattern.member != null {
                            if identifierCatchPattern.member.memberPostfix is NamedMemberPostfix {
                                let namedMemberPostfix: NamedMemberPostfix = (identifierCatchPattern.member.memberPostfix) as NamedMemberPostfix
                                sourceFile.append(namedMemberPostfix.identifier.name)
                                sourceFile.append(":\n")
                                sourceIndentLevel++
                                indentSource()
                                sourceFile.append("_")
                                sourceFile.append(identifierCatchPattern.name)
                                sourceFile.append("_")
                                sourceFile.append(namedMemberPostfix.identifier.name)                            
                                sourceFile.append("* ")
                                if catchClause.bindingPattern != null {
                                    let bindingPattern: TuplePattern = catchClause.bindingPattern
                                    if bindingPattern.elements != null {
                                        if bindingPattern.elements.length() > 0 {
                                            let elements: [TuplePatternElement] = bindingPattern.elements
                                            let element: TuplePatternElement = elements[0]
                                            if element.pattern is IdentifierPattern {
                                                let pattern: IdentifierPattern = (element.pattern) as IdentifierPattern
                                                sourceFile.append(pattern.identifier)                    
                                                sourceFile.append(" = _")
                                                sourceFile.append(identifierExpression.name)
                                                sourceFile.append("_error.get_")
                                                sourceFile.append(namedMemberPostfix.identifier.name)                            
                                                sourceFile.append("();")
                                            }
                                        }
                                    }
                                }
                                sourceFile.append("\n")
                                sourceIndentLevel--
                            }
                        }
                    }
                    if catchClause.catchPattern is WildCardCatchPattern {
                        sourceFile.append("default:\n")
                    }
                    
                    sourceIndentLevel++
                    indentSource()
                    catchClause.expression.accept(this)
                    if catchClause.expression is SimpleExpression
                        sourceFile.append(";\n")
                    sourceIndentLevel--
                    
                    let clauses: [CatchClause] = functionCall.catchClauses
                    if clauses[functionCall.catchClauses.length() - 1] == catchClause {
                        sourceIndentLevel--
                        indentSource()
                        sourceFile.append("}\n")
                        sourceIndentLevel--
                        indentSource()
                        sourceFile.append("}\n")
                    }
                }
            }
        }
        return false
    }

    function getIdentifierExpression(postfixExpression: PostfixExpression) -> existing IdentifierExpression {
        if postfixExpression.parent.parent.parent.parent is CodeBlock {
            if postfixExpression.parent is PrefixExpression {
                let prefixExpression: PrefixExpression = (postfixExpression.parent) as PrefixExpression
                if prefixExpression.expression.primaryExpression is IdentifierExpression {
                    return (prefixExpression.expression.primaryExpression) as IdentifierExpression
                }
            }
        }

        return null
    }

    function getErrorType(catchClause: CatchClause) -> existing String {
        if catchClause.bindingPattern != null {
            if catchClause.bindingPattern.elements != null {
                if catchClause.bindingPattern.elements.length() == 1 {
                    let elements: [TuplePatternElement] = catchClause.bindingPattern.elements
                    let element: TuplePatternElement = elements[0]
                    if element.pattern is IdentifierPattern {
                        let pattern: IdentifierPattern = (element.pattern) as IdentifierPattern
                        if pattern.annotationForType != null {
                            if pattern.annotationForType.annotationForType is TypeIdentifier {
                                let typeIdentifier: TypeIdentifier = (pattern.annotationForType.annotationForType) as TypeIdentifier
                                return typeIdentifier.name
                            }
                        }
                    }
                }
            }
        }

        return null
    }

    function closeCatchClause(catchClause: CatchClause) {
    }

    function openWildCardCatchPattern(wildCardCatchPattern: WildCardCatchPattern) -> bool {
        return true
    }

    function closeWildCardCatchPattern(wildCardCatchPattern: WildCardCatchPattern) {
    }

    function openIdentifierCatchPattern(identifierCatchPattern: IdentifierCatchPattern) -> bool {
        return true
    }

    function closeIdentifierCatchPattern(identifierCatchPattern: IdentifierCatchPattern) {
    }

    function visitOperatorPostfix(operatorPostfix: OperatorPostfix) {
        sourceFile.append(operatorPostfix.postfixOperator)
    }

    function openFunctionCall(functionCall: FunctionCall) -> bool {
        return true
    }

    function closeFunctionCall(functionCall: FunctionCall) {
    }

    function openExplicitMemberExpression(explicitMemberExpression: ExplicitMemberExpression) -> bool {
        if explicitMemberExpression.parent is PostfixExpression {
            let postfixExpression: PostfixExpression = (explicitMemberExpression.parent) as PostfixExpression
            if postfixExpression.primaryExpression is IdentifierExpression {
                let identifierExpression: IdentifierExpression = (postfixExpression.primaryExpression) as IdentifierExpression
                if postfixExpression.postfixes.length() > 1 {
                    let postfixes: [Postfix] = postfixExpression.postfixes
                    if (postfixes[0] == explicitMemberExpression as Postfix) && ((postfixes[1]) is FunctionCall) {
                        if isClass(identifierExpression.name) {
                            sourceFile.append("::")
                            return true
                        }
                    }
                }
            }
        }
        sourceFile.append("->")

        return true
    }

    function closeExplicitMemberExpression(explicitMemberExpression: ExplicitMemberExpression) {
    }

    function openSubscript(subscript: Subscript) -> bool {
        sourceFile.append("[")

        return true
    }

    function closeSubscript(subscript: Subscript) {
        sourceFile.append("]")
    }

    function openExpressionElement(expressionElement: ExpressionElement) -> bool {
        return true
    }

    function closeExpressionElement(expressionElement: ExpressionElement) {
        if !isLastExpressionElement(expressionElement)
            sourceFile.append(", ")
    }

    function isLastExpressionElement(expressionElement: ExpressionElement) -> bool {
        if expressionElement.parent is ParenthesizedExpression {
            let parenthesizedExpression: ParenthesizedExpression = (expressionElement.parent) as ParenthesizedExpression
            let expressionElements: [ExpressionElement] = parenthesizedExpression.expressionElements
            let length: unsigned = expressionElements.length() - 1
            let i: unsigned = 0
            for element: ExpressionElement in expressionElements {
                if (element == expressionElement) && (i == length)
                    return true
                i++
            }
        }

        if expressionElement.parent is Subscript {
            let subscript: Subscript = (expressionElement.parent) as Subscript
            let expressions: [ExpressionElement] = subscript.expressions
            let length: unsigned = expressions.length() - 1
            let i: unsigned = 0
            for element: ExpressionElement in expressions {
                if (element == expressionElement) && (i == length)
                    return true
                i++
            }
        }

        return false
    }

    function openNamedMemberPostfix(namedMemberPostfix: NamedMemberPostfix) -> bool {
        return true
    }

    function closeNamedMemberPostfix(namedMemberPostfix: NamedMemberPostfix) {
    }

    function visitIdentifierExpression(identifierExpression: IdentifierExpression) {
        if identifierExpression.parent is PostfixExpression {
            var postfixExpression: PostfixExpression = (identifierExpression.parent) as PostfixExpression
            if postfixExpression.postfixes != null {
                if postfixExpression.postfixes.length() > 0 {
                    let postfixes: [Postfix] = postfixExpression.postfixes
                    if (isClass(identifierExpression.name)) && ((postfixes[0]) is FunctionCall) {
                        sourceFile.append("new(")
                        if (inReturn(identifierExpression)) || (inRetDeclaration(identifierExpression)) {
                            sourceFile.append("_rp")
                        }
                        else {
                            if inThrow(identifierExpression) {
                                sourceFile.append("_ep")
                            }
                            else {
                                if inAssignment(identifierExpression) {
                                    var assignment: Assignment = getAssignment(identifierExpression)
                                    if assignment != null {
                                        var classDeclaration: ClassDeclaration = getClassDeclaration(assignment)
                                        mutable memberName: String = getMemberIfCreatingObject(assignment)
                                        if memberName != null {
                                            if isVariableMember(memberName, classDeclaration) {
                                                if !inInitializer(assignment) {
                                                    sourceFile.append(memberName)
                                                    sourceFile.append("->")
                                                }
                                                sourceFile.append("getPage()")
                                                if inInitializer(assignment) {
                                                    sourceFile.append("->allocateExclusivePage()")
                                                }
                                            }
                                            else {
                                                sourceFile.append("getPage()")
                                            }
                                        }
                                    }
                                }
                                else {
                                    sourceFile.append("_p")
                                }
                            }
                        }
                        sourceFile.append(") ")
                        sourceFile.append(identifierExpression.name)
                    }
                    else {
                        sourceFile.append(identifierExpression.name)
                    }
                }
                else {
                    sourceFile.append(identifierExpression.name)
                }
            }
            else {
                sourceFile.append(identifierExpression.name)
            }
        }
        else {
            sourceFile.append(identifierExpression.name)
        }
        if identifierExpression.parent is PostfixExpression {
            let postfixExpression: PostfixExpression = (identifierExpression.parent) as PostfixExpression
            if postfixExpression.postfixes != null {
                let postfixes: [Postfix] = postfixExpression.postfixes
                if (postfixes[0]) is Subscript {
                    sourceFile.append(")")
                }
            }
        }
    }

    function inAssignment(syntaxNode: SyntaxNode) -> bool {
        if syntaxNode is Assignment
            return true

        let parentNode: SyntaxNode = syntaxNode.parent
        if parentNode == null
            return false

        return inAssignment(parentNode)
    }

    function getAssignment(syntaxNode: SyntaxNode) -> existing Assignment {
        if syntaxNode is Assignment
            return syntaxNode as Assignment

        let parentNode: SyntaxNode = syntaxNode.parent
        if parentNode == null
            return null

        return getAssignment(parentNode)
    }

    function inRetDeclaration(syntaxNode: SyntaxNode) -> bool {
        if syntaxNode == null
            return false

        var bindingInitializer: BindingInitializer = null

        repeat {
            if syntaxNode is BindingInitializer {
                bindingInitializer = (syntaxNode as BindingInitializer)
                break
            }
            syntaxNode = syntaxNode.parent
        } 
        while syntaxNode != null

        if bindingInitializer == null
            return false

        if bindingInitializer.initializer != null {
            let patternInitializer: PatternInitializer = bindingInitializer.initializer
            if patternInitializer.pattern is IdentifierPattern {
                let identifierPattern: IdentifierPattern = (patternInitializer.pattern) as IdentifierPattern
                return identifierPattern.identifier.equals("ret")
            }
        }

        return false
    }

    function visitLiteralExpression(literalExpression: LiteralExpression) {
        let literal: Literal = literalExpression.literal
        if literal is NumericLiteral {
            let numericLiteral: NumericLiteral = literal as NumericLiteral
            sourceFile.append(numericLiteral.value)
        }
        else {
            if literal is StringLiteral {
                let stringLiteral: StringLiteral = literal as StringLiteral
                sourceFile.append("\"")
                sourceFile.append(stringLiteral.string)
                sourceFile.append("\"")
            }
            else {
                if literal is CharacterLiteral {
                    let characterLiteral: CharacterLiteral = literal as CharacterLiteral
                    sourceFile.append("\'")
                    if characterLiteral.value.getLength() > 0 {
                        if (characterLiteral.value.charAt(0) == '"') || (characterLiteral.value.charAt(0) == '\'') {
                            sourceFile.append("\\")
                            sourceFile.append(characterLiteral.value)
                        }
                        else {                        
                            switch characterLiteral.value.charAt(0) {                            
                                case '\r': sourceFile.append("\\r")
                                case '\n': sourceFile.append("\\n")
                                case '\t': sourceFile.append("\\t")
                                case '\0': sourceFile.append("\\0")
                                case '\\': sourceFile.append("\\\\")
                                default:   sourceFile.append(characterLiteral.value);                                    
                            }
                        }
                    }
                    sourceFile.append("\'");
                }
            }
        }
    }

    function openIfExpression(ifExpression: IfExpression) -> bool {
        sourceFile.append("if (")
        ifExpression.condition.accept(this)
        sourceFile.append(")")
        if ifExpression.consequent is SimpleExpression {
            sourceFile.append("\n")
            sourceIndentLevel++
            indentSource()
            ifExpression.consequent.accept(this)
            sourceFile.append(";\n")
            sourceIndentLevel--
        }
        else {
            sourceFile.append(" ")
            ifExpression.consequent.accept(this)
        }
        if ifExpression.elseClause != null {
            if ifExpression.elseClause.alternative is SimpleExpression {
                ifExpression.elseClause.accept(this)
                sourceFile.append(";\n")
            }
            else {
                ifExpression.elseClause.accept(this)
            }
        }

        return false
    }

    function closeIfExpression(ifExpression: IfExpression) {
    }

    function openSwitchExpression(switchExpression: SwitchExpression) -> bool {
        sourceFile.append("switch (")

        return true
    }

    function closeSwitchExpression(switchExpression: SwitchExpression) {
    }

    function openForExpression(forExpression: ForExpression) -> bool {
        let pattern: Pattern = forExpression.pattern
        pattern.accept(this)    
        if pattern is IdentifierPattern {
            sourceFile.append(" = nullptr;\n")
            indentSource()
            sourceFile.append("size_t _")
            let expression: Expression = forExpression.expression
            if expression is SimpleExpression {
                let simpleExpression: SimpleExpression = expression as SimpleExpression
                if simpleExpression.prefixExpression.expression.primaryExpression is IdentifierExpression {
                    let identifierExpression: IdentifierExpression = (simpleExpression.prefixExpression.expression.primaryExpression) as IdentifierExpression
                    let collectionName: String = identifierExpression.name
                    sourceFile.append(collectionName)
                    sourceFile.append("_length = ")
                    sourceFile.append(collectionName)
                    sourceFile.append("->length();\n")
                    indentSource()
                    sourceFile.append("for (size_t _i = 0; _i < _")
                    sourceFile.append(collectionName)
                    sourceFile.append("_length; _i++) {\n")
                    sourceIndentLevel++
                    indentSource()
                    if forExpression.pattern is IdentifierPattern {
                        let identifierPattern: IdentifierPattern = (forExpression.pattern) as IdentifierPattern
                        sourceFile.append(identifierPattern.identifier)
                        sourceFile.append(" = *(*")
                        sourceFile.append(collectionName)
                        sourceFile.append(")[_i];\n")
                        indentSource()
                        forExpression.code.accept(this)
                        if forExpression.code is SimpleExpression
                            sourceFile.append(";\n")
                        sourceIndentLevel--
                        indentSource()
                        sourceFile.append("}\n")
                    }
                }
            }
        }
        return false
    }

    function closeForExpression(forExpression: ForExpression) {
    }

    function openWhileExpression(whileExpression: WhileExpression) -> bool {
        sourceFile.append("while (")
        whileExpression.condition.accept(this)
        sourceFile.append(")")
        if whileExpression.code is SimpleExpression {
            sourceFile.append("\n")
            sourceIndentLevel++
            indentSource()
            whileExpression.code.accept(this)
            sourceFile.append(";\n")
            sourceIndentLevel--
        }
        else {
            sourceFile.append(" ")
            whileExpression.code.accept(this)
        }

        return false
    }

    function closeWhileExpression(whileExpression: WhileExpression) {
    }

    function openRepeatExpression(repeatExpression: RepeatExpression) -> bool {
        sourceFile.append("do")
        if repeatExpression.code is SimpleExpression {
            sourceFile.append("\n")
            sourceIndentLevel++
            indentSource()
            repeatExpression.code.accept(this)
            sourceFile.append(";")
            sourceIndentLevel--
        }
        else {
            sourceFile.append(" ")
            repeatExpression.code.accept(this)
        }
        indentSource()
        sourceFile.append("while (")
        repeatExpression.condition.accept(this)
        sourceFile.append(")")

        return false
    }

    function closeRepeatExpression(repeatExpression: RepeatExpression) {
    }

    function openParenthesizedExpression(parenthesizedExpression: ParenthesizedExpression) -> bool {
        sourceFile.append("(")
        if parenthesizedExpression.parent is FunctionCall {
            let functionCall: FunctionCall = (parenthesizedExpression.parent) as FunctionCall
            if functionCall.parent is PostfixExpression {
                let postfixExpression: PostfixExpression = (functionCall.parent) as PostfixExpression
                if postfixExpression.primaryExpression is IdentifierExpression {
                    let identifierExpression: IdentifierExpression = (postfixExpression.primaryExpression) as IdentifierExpression
                    if !isClass(identifierExpression.name) {
                        if postfixExpression.parent.parent.parent is Assignment {
                            let assignment: Assignment = (postfixExpression.parent.parent.parent) as Assignment
                            mutable member: String = getMemberIfCreatingObject(assignment)
                            if member != null {
                                var classDeclaration: ClassDeclaration = getClassDeclaration(assignment)
                                if isVariableMember(member, classDeclaration) {
                                    sourceFile.append(member)
                                    sourceFile.append("->getPage()")
                                    if functionCall.arguments != null && functionCall.arguments.expressionElements != null
                                        sourceFile.append(", ")
                                }
                            }
                        }
                    }
                }
            }

            let parameterInserted: bool = false
            if !callsInitializer(functionCall) {
                if assignedToMutableObject(functionCall) {
                    sourceFile.append("_p")
                    parameterInserted = true
                }
                if assignedToConstantObject(functionCall) {
                    mutable returnType: String = getReturnType(functionCall)
                    if returnType != null
                        sourceFile.append("_rp")
                    else
                        sourceFile.append("_p")
                    parameterInserted = true
                }
            }
            if catchesError(functionCall) {
                if !inThrow(functionCall) {
                    if parameterInserted
                        sourceFile.append(", ")
                    mutable thrownType: String = getThrownType(functionCall)
                    if thrownType == null
                        sourceFile.append("_p")
                    else
                        sourceFile.append("_ep")
                    parameterInserted = true
                }
            }
            if parameterInserted && (parenthesizedExpression.expressionElements != null)
                sourceFile.append(", ")
        }
        return true
    }

    function assignedToMutableObject(functionCall: FunctionCall) -> bool {
        var bindingInitializer: BindingInitializer = getBindingInitializer(functionCall)
        if bindingInitializer == null
            return false

        if bindingInitializer.parent is MutableDeclaration {
            if boundToObject(bindingInitializer)
                return true
        }

        return false
    }

    function assignedToConstantObject(functionCall: FunctionCall) -> bool {
        var bindingInitializer: BindingInitializer = getBindingInitializer(functionCall)
        if bindingInitializer == null
            return false

        if bindingInitializer.parent is ConstantDeclaration {
            if boundToObject(bindingInitializer)
                return true
        }

        return false
    }

    function boundToObject(bindingInitializer: BindingInitializer) -> bool {
        let patternInitializer: PatternInitializer = bindingInitializer.initializer
        if patternInitializer.pattern is IdentifierPattern {
            let identifierPattern: IdentifierPattern = (patternInitializer.pattern) as IdentifierPattern
            let type: Type = identifierPattern.annotationForType.annotationForType
            if type is ArrayType
                return true

            if type is TypeIdentifier {
                let typeIdentifier: TypeIdentifier = type as TypeIdentifier
                if isClass(typeIdentifier.name) {
                    if getFunctionCall(patternInitializer) != null
                        return true;
                }
            }
        }
        return false
    }

    function getBindingInitializer(functionCall: FunctionCall) -> existing BindingInitializer {
        if functionCall.parent is PostfixExpression {
            let postfixExpression: PostfixExpression = (functionCall.parent) as PostfixExpression
            if postfixExpression.parent.parent.parent is Initializer {
                let initializer: Initializer = (postfixExpression.parent.parent.parent) as Initializer
                if initializer.parent is PatternInitializer {
                    let patternInitializer: PatternInitializer = (initializer.parent) as PatternInitializer
                    if patternInitializer.parent is BindingInitializer {
                        return (patternInitializer.parent) as BindingInitializer
                    }
                }
            }
        }

        return null
    }

    function callsInitializer(functionCall: FunctionCall) -> bool {
        if functionCall.parent is PostfixExpression {
            let postfixExpression: PostfixExpression = (functionCall.parent) as PostfixExpression
            if postfixExpression.postfixes.length() == 1 {
                if postfixExpression.primaryExpression is IdentifierExpression {
                    let identifierExpression: IdentifierExpression = (postfixExpression.primaryExpression) as IdentifierExpression
                    if isClass(identifierExpression.name) {
                        return true
                    }
                }
            }
        }

        return false
    }

    function catchesError(functionCall: FunctionCall) -> bool {
        if functionCall == null
            return false

        if functionCall.catchClauses != null
            return true

        return false
    }

    function closeParenthesizedExpression(parenthesizedExpression: ParenthesizedExpression) {
        sourceFile.append(")")
    }

    function openReturnExpression(returnExpression: ReturnExpression) -> bool {
        sourceFile.append("return")
        if returnExpression.expression != null {
            sourceFile.append(" ")
            mutable returnType: String = getReturnType(returnExpression)
            mutable thrownType: String = getThrownType(returnExpression)
            if thrownType != null {
                sourceFile.append("_Result<")
                if returnType != null
                    sourceFile.append(returnType)
                sourceFile.append(", ")
                sourceFile.append(thrownType)
                sourceFile.append(">(")
            }
            returnExpression.expression.accept(this)
            if returnsArray(returnExpression) {
                sourceFile.append(" ? &")
                sourceFile.append(returnType)
                sourceFile.append("::create(_rp, *")
                returnExpression.expression.accept(this)
                sourceFile.append(") : 0")
            }
            if thrownType != null
                sourceFile.append(")")
        }
        return false
    }

    function closeReturnExpression(returnExpression: ReturnExpression) {
        mutable returnType: String = getReturnType(returnExpression)
        if returnType != null {
            sourceFile.append(")")
        }
    }

    function openThrowExpression(throwExpression: ThrowExpression) -> bool {
        mutable thrownType: String = getThrownType(throwExpression)
        if thrownType == null
            return false

        sourceFile.append("return ")
        mutable returnType: String = getReturnType(throwExpression)
        if returnType != null {
            sourceFile.append("_Result<")
            sourceFile.append(returnType)
            sourceFile.append(", ")
            sourceFile.append(thrownType)
            sourceFile.append(">(")
        }
        {
            let buildError: bool = true
            if throwExpression.arguments == null {
                if throwExpression.error is IdentifierExpression {
                    let errorExpression: IdentifierExpression = (throwExpression.error) as IdentifierExpression
                    let errorName: String = errorExpression.name
                    var catchClause: CatchClause = getCatchClause(throwExpression)
                    if catchClause != null {
                        if catchClause.catchPattern != null {
                            if catchClause.catchPattern is WildCardCatchPattern {
                                if catchClause.bindingPattern != null {
                                    let bindingPattern: TuplePattern bindingPattern = catchClause.bindingPattern
                                    if bindingPattern.elements != null {
                                        if bindingPattern.elements.length() > 0 {
                                            let elements: [TuplePatternElement] = bindingPattern.elements
                                            let element: TuplePatternElement = elements[0]
                                            if element.pattern is IdentifierPattern {
                                                let pattern: IdentifierPattern = (element.pattern) as IdentifierPattern
                                                if pattern.identifier.equals(errorName)
                                                    buildError = false
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if buildError {
                sourceFile.append("new(_ep) ")
                sourceFile.append(thrownType)
                sourceFile.append("(")
                if throwExpression.arguments != null
                    sourceFile.append("new(_ep) ")
                sourceFile.append("_")
                sourceFile.append(thrownType)
                if throwExpression.arguments == null
                    sourceFile.append("Code")
                sourceFile.append("_")
            }
            if throwExpression.error != null
                throwExpression.error.accept(this)
            if throwExpression.arguments != null
                throwExpression.arguments.accept(this)
            if buildError
                sourceFile.append(")")
        }
        if returnType != null
            sourceFile.append(")")
        return false
    }

    function inWildcardCatchClause(throwExpression: ThrowExpression) -> bool {
        var catchClause: CatchClause = getCatchClause(throwExpression)
        if (catchClause != null) && (catchClause.catchPattern is WildCardCatchPattern)
            return true

        return false
    }

    function getCatchClause(syntaxNode: SyntaxNode) -> existing CatchClause {
        if syntaxNode is CatchClause
            return syntaxNode as CatchClause

        if syntaxNode.parent == null
            return null

        return getCatchClause(syntaxNode.parent)
    }

    function getReturnType(syntaxNode: SyntaxNode) -> String {
        var functionDeclaration: FunctionDeclaration = getFunctionDeclaration(syntaxNode)
        if functionDeclaration != null {
            let functionResult: FunctionResult = functionDeclaration.signature.result
            if functionResult != null {
                let ret: VarString = VarString()
                if functionResult.resultType is TypeIdentifier {
                    let typeIdentifier: TypeIdentifier = (functionResult.resultType) as TypeIdentifier
                    appendCppTypeName(ret, typeIdentifier)
                    return String(ret)
                }
                else {
                    if functionResult.resultType is ArrayType {
                        let arrayType: ArrayType = (functionResult.resultType) as ArrayType
                        if arrayType.elementType is TypeIdentifier {
                            let typeIdentifier: TypeIdentifier = (arrayType.elementType) as TypeIdentifier
                            ret.append("_Vector<")
                            appendCppTypeName(ret, typeIdentifier)
                            ret.append(">")
                            return String(ret)
                        }
                    }
                }
            }
        }
        
        return null
    }
    
    function getThrownType(syntaxNode: SyntaxNode) -> String {
        var functionDeclaration: FunctionDeclaration = getFunctionDeclaration(syntaxNode)
        if functionDeclaration != null {
            let throwsClause: ThrowsClause = functionDeclaration.signature.throwsClause
            if throwsClause != null {
                let ret: VarString = VarString()
                if throwsClause.throwsType is TypeIdentifier {
                    let typeIdentifier: TypeIdentifier = (throwsClause.throwsType) as TypeIdentifier
                    appendCppTypeName(ret, typeIdentifier)
                    return String(ret)
                }
                else {
                    if throwsClause.throwsType is ArrayType {
                        let arrayType: ArrayType = (throwsClause.throwsType) as ArrayType
                        if arrayType.elementType is TypeIdentifier {
                            let typeIdentifier: TypeIdentifier = (arrayType.elementType) as TypeIdentifier
                            ret.append("_Vector<")
                            appendCppTypeName(ret, typeIdentifier)
                            ret.append(">")
                            return String(ret)
                        }
                    }
                }
            }
        }
        
        return nullptr
    }

    function returnsArray(syntaxNode: SyntaxNode) -> bool {
        var functionDeclaration: FunctionDeclaration = getFunctionDeclaration(syntaxNode)
        if functionDeclaration != null {
            let functionResult: FunctionResult = functionDeclaration.signature.result
            if functionResult != null {
                if functionResult.resultType is ArrayType
                    return true
            }
        }    

        return false
    }

    function getFunctionDeclaration(syntaxNode: SyntaxNode) -> existing FunctionDeclaration {
        if syntaxNode is FunctionDeclaration
            return syntaxNode as FunctionDeclaration

        if syntaxNode.parent == null
            return null

        return getFunctionDeclaration(syntaxNode.parent)
    }

    function closeThrowExpression(throwExpression: ThrowExpression) {
    }

    function openBreakExpression(breakExpression: BreakExpression) -> bool {
        sourceFile.append("break")

        return true
    }

    function closeBreakExpression(breakExpression: BreakExpression) {
    }

    function openInitializerCall(initializerCall: InitializerCall) -> bool {
        if initializerCall.typeToInitialize is ArrayType {
            if !initializerIsBoundOrAssigned(initializerCall) {
                let arrayType: ArrayType = (initializerCall.typeToInitialize) as ArrayType
                if arrayType.elementType is TypeIdentifier {
                    let typeId: TypeIdentifier = (arrayType.elementType) as TypeIdentifier
                    sourceFile.append("&_Vector<")
                    sourceFile.append(typeId.name)
                    sourceFile.append(">::create(")
                    if inThrow(initializerCall) {
                        sourceFile.append("_ep")
                    }
                    else {
                        if inReturn(initializerCall)
                            sourceFile.append("_rp")
                        else
                            sourceFile.append("_p")
                    }
                    sourceFile.append(", *")
                    initializerCall.arguments.accept(this)
                    sourceFile.append(")")
                    return false
                }
            }
            else {
                sourceFile.append("new(")
                if inInitializer(initializerCall) {
                    sourceFile.append("getPage()")
                    if initializerCall.parent.parent.parent.parent is Assignment {
                        let assignment: Assignment = (initializerCall.parent.parent.parent.parent) as Assignment
                        if inInitializer(assignment) {
                            sourceFile.append("->allocateExclusivePage()")
                        }
                    }
                }
                else {
                    if initializerCall.parent.parent.parent.parent is Assignment {
                        let assignment: Assignment = (initializerCall.parent.parent.parent.parent) as Assignment
                        let simpleExpression: SimpleExpression = (assignment.parent) as SimpleExpression
                        if simpleExpression.prefixExpression.prefixOperator == null {
                            let leftSide: PostfixExpression = simpleExpression.prefixExpression.expression
                            if (leftSide.postfixes == null) && (leftSide.primaryExpression is IdentifierExpression) {
                                let memberExpression: IdentifierExpression = (leftSide.primaryExpression) as IdentifierExpression
                                let memberName: String = memberExpression.name
                                var classDeclaration: ClassDeclaration = getClassDeclaration(assignment)
                                if (classDeclaration != null) && (memberName != null) && (isVariableMember(memberName, classDeclaration)) {
                                    sourceFile.append(memberName)
                                    sourceFile.append("->getPage()")
                                }
                                else {
                                    sourceFile.append("_p")
                                }
                            }
                            else {
                                sourceFile.append("_p")
                            }
                        }
                        else {
                            sourceFile.append("_p")
                        }
                    }
                    else {
                        sourceFile.append("_p")
                    }
                }
                sourceFile.append(") ")
            }
        }
        return true
    }

    function initializerIsBoundOrAssigned(initializerCall: InitializerCall) -> bool {
        if initializerCall.parent is PostfixExpression {
            let postfixExpression: PostfixExpression = (initializerCall.parent) as PostfixExpression
            if (postfixExpression.parent.parent.parent is Assignment) || (postfixExpression.parent.parent.parent is Initializer)
                return true
        }

        return false
    }

    function closeInitializerCall(initializerCall: InitializerCall) {
    }

    function visitThisExpression(thisExpression: ThisExpression) {
        sourceFile.append("this")
    }

    function openSuperDot(superDot: SuperDot) -> bool {
        return true
    }

    function closeSuperDot(superDot: SuperDot) {
    }

    function openSuperSubscript(superSubscript: SuperSubscript) -> bool {
        return true
    }

    function closeSuperSubscript(superSubscript: SuperSubscript) {
    }

    function visitNullExpression(nullExpression: NullExpression) {
        sourceFile.append("nullptr")
    }

    function openElseClause(elseClause: ElseClause) -> bool {
        indentSource();
        sourceFile.append("else")
        if elseClause.alternative is SimpleExpression {
            sourceFile.append("\n")
            sourceIndentLevel++
            indentSource()
            elseClause.alternative.accept(this)
            sourceIndentLevel--
        }
        else {
            sourceFile.append(" ")
            elseClause.alternative.accept(this)
        }
        
        return false
    }

    function closeElseClause(elseClause: ElseClause) {
    }

    function openCurliedSwitchBody(curliedSwitchBody: CurliedSwitchBody) -> bool {
        sourceFile.append(") {\n")
        sourceIndentLevel++

        return true
    }

    function closeCurliedSwitchBody(curliedSwitchBody: CurliedSwitchBody) {
        sourceIndentLevel--
        indentSource()
        sourceFile.append("}\n")
    }

    function openNakedSwitchBody(nakedSwitchBody: NakedSwitchBody) -> bool {
        return true
    }

    function closeNakedSwitchBody(nakedSwitchBody: NakedSwitchBody) {
    }

    function openSwitchCase(switchCase: SwitchCase) -> bool {
        indentSource()
        return true
    }

    function closeSwitchCase(switchCase: SwitchCase) {
    }

    function openItemCaseLabel(itemCaseLabel: ItemCaseLabel) -> bool {
        sourceFile.append("case ")
        return true
    }

    function closeItemCaseLabel(itemCaseLabel: ItemCaseLabel) {
    }

    function visitDefaultCaseLabel(defaultCaseLabel: DefaultCaseLabel) {
        sourceFile.append("default: ")
    }

    function openCaseItem(caseItem: CaseItem) -> bool {
        sourceFile.append("case ")

        return true
    }

    function closeCaseItem(caseItem: CaseItem) {
        sourceFile.append(": ")
    }

    function visitWildcardPattern(wildcardPattern: WildcardPattern) {
    }

    function openIdentifierPattern(identifierPattern: IdentifierPattern) -> bool {
        if identifierPattern.parent is PatternInitializer {
            let patternInitializer: PatternInitializer = (identifierPattern.parent) as PatternInitializer
            if isCatchingPatternInitializer(patternInitializer)
            {
                sourceFile.append("auto _")
                sourceFile.append(identifierPattern.identifier)
                sourceFile.append("_result")
                return false
            }
        }

        if identifierPattern.annotationForType != null {
            identifierPattern.annotationForType.accept(this)

            if !suppressHeader
                headerFile.append(" ")

            if !suppressSource
                sourceFile.append(" ")
        }

        if !suppressHeader
            headerFile.append(identifierPattern.identifier)

        if !suppressSource
            sourceFile.append(identifierPattern.identifier)

        return false
    }

    function isCatchingPatternInitializer(patternInitializer: PatternInitializer) -> bool {
        if patternInitializer.initializer != null {
            if patternInitializer.initializer.expression is SimpleExpression {
                let simpleExpression: SimpleExpression = (patternInitializer.initializer.expression) as SimpleExpression
                let postfixExpression: PostfixExpression = simpleExpression.prefixExpression.expression
                if postfixExpression.postfixes != null {
                    let functionCall: FunctionCall =  null
                    if postfixExpression.postfixes.length() > 0 {
                        let postfixes: [Postfix] = postfixExpression.postfixes
                        let postfix: Postfix = postfixes[0]
                        if postfix is FunctionCall {
                            functionCall = postfix as FunctionCall
                        }
                        else {
                            if postfix is ExplicitMemberExpression {
                                if postfixExpression.postfixes.length() > 1 {
                                    let postfix: Postfix = postfixes[1]
                                    if postfix is FunctionCall {
                                        functionCall = postfix as FunctionCall
                                    }
                                }
                            }
                        }
                    }
                    if functionCall != null {
                        if functionCall.catchClauses != null
                            return true
                    }
                }
            }
        }

        return false
    }

    function closeIdentifierPattern(identifierPattern: IdentifierPattern) {
    }

    function openTuplePattern(tuplePattern: TuplePattern) -> bool {
        return true
    }

    function closeTuplePattern(tuplePattern: TuplePattern) {
    }

    function openExpressionPattern(expressionPattern: ExpressionPattern) -> bool {
        return true
    }

    function closeExpressionPattern(expressionPattern: ExpressionPattern) {
        if expressionPattern.parent is ItemCaseLabel
            sourceFile.append(": ")
    }

    function openTuplePatternElement(tuplePatternElement: TuplePatternElement) -> bool {
        return true
    }

    function closeTuplePatternElement(tuplePatternElement: TuplePatternElement) {
    }

    function openBlockCaseContent(blockCaseContent: BlockCaseContent) -> bool {
        sourceFile.append("{\n")
        sourceIndentLevel++

        return true
    }

    function closeBlockCaseContent(blockCaseContent: BlockCaseContent) {
        var additionalLineFeed: bool = true
        if blockCaseContent.parent is SwitchCase {
            let switchCase: SwitchCase = blockCaseContent.parent as SwitchCase
            if !switchCase.label is DefaultCaseLabel {
                indentSource()
                sourceFile.append("break;\n")
            }
            else
                additionalLineFeed = false
        }
        sourceIndentLevel--
        indentSource()
        sourceFile.append("}\n")
        if additionalLineFeed
            sourceFile.append("\n")
    }

    function visitEmptyCaseContent(emptyCaseContent: EmptyCaseContent) {
    }

    function visitSuperInit(superInit: SuperInit) {
    }

    function visitSuperMember(superMember: SuperMember) {
    }

    function openTypeIdentifier(typeIdentifier: TypeIdentifier) -> bool {
        if !suppressHeader
            appendCppTypeName(headerFile, typeIdentifier)

        if !suppressSource
            appendCppTypeName(sourceFile, typeIdentifier)

        if isClass(typeIdentifier.name) && !inArrayType(typeIdentifier) && !inTypeQuery(typeIdentifier) {
            if !suppressHeader
                headerFile.append("*")

            if !suppressSource
                sourceFile.append("*")
        }

        if inTypeQuery(typeIdentifier)
            sourceFile.append("()")
            
        return true
    }

    function inArrayType(typeIdentifier: TypeIdentifier) -> bool {
        if typeIdentifier.parent is ArrayType
            return true

        return false
    }

    function inTypeQuery(typeIdentifier: TypeIdentifier) -> bool {
        if typeIdentifier.parent is TypeQuery
            return true

        return false
    }

    function appendCppTypeName(mutable s: VarString, typeIdentifier: TypeIdentifier) {
        let typeIdentifierName: String = typeIdentifier.name
        if typeIdentifierName.equals("unsigned") {
            s.append("size_t")
            return
        }
        else {
            if typeIdentifierName.equals("character") {
                s.append("char")
                return
            }
        }

        s.append(typeIdentifierName)
    }

    function closeTypeIdentifier(typeIdentifier: TypeIdentifier) {
    }

    function openArrayType(arrayType: ArrayType) -> bool {
        if !sourceIndentLevel {
            if constDeclaration {
                headerFile.append("_Vector<")
                if !suppressSource
                    sourceFile.append("_Vector<")
            }
            else {
                headerFile.append("_Array<")
                if !suppressSource
                    sourceFile.append("_Array<")
            }
            arrayType.elementType.accept(this)
            headerFile.append(">*")
            if !suppressSource {
                sourceFile.append(">")
                if !arrayType.parent is InitializerCall
                    sourceFile.append("*")
            }
        }
        else {
            if constDeclaration {
                sourceFile.append("_Vector<")
            }
            else {
                if !inThrow(arrayType)
                    sourceFile.append("_Array<")
            }
            arrayType.elementType.accept(this)
            sourceFile.append(">")
            if !arrayType.parent is InitializerCall
                sourceFile.append("*")
        }

        return false
    }

    function closeArrayType(arrayType: ArrayType) {
    }

    function openTypeAnnotation(typeAnnotation: TypeAnnotation) -> bool {
        return true
    }

    function closeTypeAnnotation(typeAnnotation: TypeAnnotation) {
    }

    function openSubtypeIdentifier(subtypeIdentifier: SubtypeIdentifier) -> bool {
        return true
    }

    function closeSubtypeIdentifier(subtypeIdentifier: SubtypeIdentifier) {
    }

    function visitOptionalType(optionalType: OptionalType) {
    }

    function openTypeInheritanceClause(typeInheritanceClause: TypeInheritanceClause) -> bool {
        return true
    }

    function closeTypeInheritanceClause(typeInheritanceClause: TypeInheritanceClause) {
    }

    function openInheritance(inheritance: Inheritance) -> bool {
        return false
    }

    function closeInheritance(inheritance: Inheritance) {
    }

    function buildMainHeaderFileString(mutable mainHeaderFile: VarString, program: Program) {
        mainHeaderFile.append("#ifndef __scaly__")
        mainHeaderFile.append(program.name)
        mainHeaderFile.append("__\n#define __scaly__")
        mainHeaderFile.append(program.name)
        mainHeaderFile.append("__\n\n#include \"Scaly.h\"\n")
        let compilationUnits: [CompilationUnit] = program.compilationUnits
        for compilationUnit: CompilationUnit in compilationUnits {
            mainHeaderFile.append("#include \"")
            mutable fileName: String = Path.getFileNameWithoutExtension(compilationUnit.fileName)
            mainHeaderFile.append(fileName)
            mainHeaderFile.append(".h\"\n")
        }
        mainHeaderFile.append("\nusing namespace scaly;\nnamespace ")
        mainHeaderFile.append(program.name)
        mainHeaderFile.append(" {\nint _main(_Vector<String>* arguments);\n}\n\n#endif // __scaly__scalyc__\n")
    }
    
    function buildProjectFileString(mutable projectFile: VarString, program: Program) {
        projectFile.append("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n")
        projectFile.append("<CodeLite_Project Name=\"")
        projectFile.append(program.name)
        projectFile.append("\" InternalType=\"Console\">\n  <Plugins>\n    <Plugin Name=\"qmake\">\n")
        projectFile.append("      <![CDATA[00020001N0005Debug0000000000000001N0007Release000000000000]]>\n    </Plugin>\n")
        projectFile.append("    <Plugin Name=\"CMakePlugin\">\n      <![CDATA[[{\n")
        projectFile.append("  \"name\": \"Debug\",\n  \"enabled\": false,\n  \"buildDirectory\": \"build\",\n")
        projectFile.append("  \"sourceDirectory\": \"$(ProjectPath)\",\n  \"generator\": \"\",\n  \"buildType\": \"\",\n")
        projectFile.append("  \"arguments\": [],\n  \"parentProject\": \"\"\n")
        projectFile.append(" }, {\n")
        projectFile.append("  \"name\": \"Release\",\n")
        projectFile.append("  \"enabled\": false,\n")
        projectFile.append("  \"buildDirectory\": \"build\",\n")
        projectFile.append("  \"sourceDirectory\": \"$(ProjectPath)\",\n")
        projectFile.append("  \"generator\": \"\",\n")
        projectFile.append("  \"buildType\": \"\",\n")
        projectFile.append("  \"arguments\": [],\n")
        projectFile.append("  \"parentProject\": \"\"\n")
        projectFile.append(" }]]]>\n    </Plugin>\n  </Plugins>\n")
        projectFile.append("  <Description/>\n  <Dependencies/>\n")
        projectFile.append("  <VirtualDirectory Name=\"src\">\n    <File Name=\"main.cpp\"/>\n")
        {
            let compilationUnits: [CompilationUnit] = program.compilationUnits
            for compilationUnit: CompilationUnit in compilationUnits {
                projectFile.append("    <File Name=\"")
                mutable fileName: String = Path.getFileNameWithoutExtension(compilationUnit.fileName)
                projectFile.append(fileName)
                projectFile.append(".cpp\"/>\n");
            }
        }
        projectFile.append("  </VirtualDirectory>\n  <VirtualDirectory Name=\"include\">\n")
        {
            let compilationUnits: [CompilationUnit] = program.compilationUnits
            for compilationUnit: CompilationUnit in compilationUnits {
                projectFile.append("    <File Name=\"")
                mutable fileName: String = Path.getFileNameWithoutExtension(compilationUnit.fileName)
                projectFile.append(fileName)
                projectFile.append(".h\"/>\n");
            }
        }
        projectFile.append("  </VirtualDirectory>\n  <Settings Type=\"Executable\">\n    <GlobalSettings>\n")
        projectFile.append("      <Compiler Options=\"\" C_Options=\"\" Assembler=\"\">\n")
        projectFile.append("        <IncludePath Value=\".\"/>\n      </Compiler>\n      <Linker Options=\"\">\n")
        projectFile.append("        <LibraryPath Value=\".\"/>\n      </Linker>\n      <ResourceCompiler Options=\"\"/>\n")
        projectFile.append("    </GlobalSettings>\n")
        projectFile.append("    <Configuration Name=\"Debug\" CompilerType=\"GCC\" DebuggerType=\"GNU gdb debugger\"")
        projectFile.append(" Type=\"Executable\" BuildCmpWithGlobalSettings=\"append\" BuildLnkWithGlobalSettings=\"append\"")
        projectFile.append(" BuildResWithGlobalSettings=\"append\">\n")
        projectFile.append("      <Compiler Options=\"-g;-O0;-std=c++11;-Wall\" C_Options=\"-g;-O0;-Wall\" Assembler=\"\"")
        projectFile.append(" Required=\"yes\" PreCompiledHeader=\"\" PCHInCommandLine=\"no\" PCHFlags=\"\" PCHFlagsPolicy=\"0\">\n")
        projectFile.append("        <IncludePath Value=\".\"/>\n        <IncludePath Value=\"../scaly\"/>\n      </Compiler>\n")
        projectFile.append("      <Linker Options=\"\" Required=\"yes\">\n        <LibraryPath Value=\"../Debug\"/>\n")
        projectFile.append("        <Library Value=\"libscaly\"/>\n      </Linker>\n      <ResourceCompiler Options=\"\" Required=\"no\"/>\n")
        projectFile.append("      <General OutputFile=\"$(IntermediateDirectory)/$(ProjectName)\" IntermediateDirectory=\"../Debug\" ")
        projectFile.append("Command=\"./$(ProjectName)\" CommandArguments=\"-o ")
        projectFile.append(program.name)
        projectFile.append(" -d ../scalyc")
        {
            let compilationUnits: [CompilationUnit] = program.compilationUnits
            for compilationUnit: CompilationUnit in compilationUnits {
                projectFile.append(" ../")
                projectFile.append(program.name)
                projectFile.append("/")
                mutable fileName: String = Path.getFileNameWithoutExtension(compilationUnit.fileName)
                projectFile.append(fileName)
                projectFile.append(".scaly")
            }
        }
        projectFile.append("\" UseSeparateDebugArgs=\"no\" DebugArguments=\"\" WorkingDirectory=\"$(IntermediateDirectory)\"")
        projectFile.append(" PauseExecWhenProcTerminates=\"yes\" IsGUIProgram=\"no\" IsEnabled=\"yes\"/>\n")
        projectFile.append("      <Environment EnvVarSetName=\"&lt;Use Defaults&gt;\" DbgSetName=\"&lt;Use Defaults&gt;\">\n")
        projectFile.append("        <![CDATA[]]>\n      </Environment>\n")
        projectFile.append("      <Debugger IsRemote=\"no\" RemoteHostName=\"\" RemoteHostPort=\"\" DebuggerPath=\"\" IsExtended=\"yes\">\n")
        projectFile.append("        <DebuggerSearchPaths/>\n        <PostConnectCommands/>\n        <StartupCommands/>\n      </Debugger>\n")
        projectFile.append("      <PreBuild/>\n      <PostBuild/>\n      <CustomBuild Enabled=\"no\">\n        <RebuildCommand/>\n")
        projectFile.append("        <CleanCommand/>\n        <BuildCommand/>\n        <PreprocessFileCommand/>\n        <SingleFileCommand/>\n")
        projectFile.append("        <MakefileGenerationCommand/>\n        <ThirdPartyToolName>None</ThirdPartyToolName>\n")
        projectFile.append("        <WorkingDirectory/>\n      </CustomBuild>\n      <AdditionalRules>\n")
        projectFile.append("        <CustomPostBuild/>\n        <CustomPreBuild/>\n      </AdditionalRules>\n")
        projectFile.append("      <Completion EnableCpp11=\"no\" EnableCpp14=\"no\">\n        <ClangCmpFlagsC/>\n        <ClangCmpFlags/>\n")
        projectFile.append("        <ClangPP/>\n        <SearchPaths/>\n      </Completion>\n")
        projectFile.append("    </Configuration>\n")
        projectFile.append("    <Configuration Name=\"Release\" CompilerType=\"GCC\" DebuggerType=\"GNU gdb debugger\" Type=\"Executable\"")
        projectFile.append(" BuildCmpWithGlobalSettings=\"append\" BuildLnkWithGlobalSettings=\"append\" BuildResWithGlobalSettings=\"append\">\n")
        projectFile.append("      <Compiler Options=\"-O2;-Wall\" C_Options=\"-O2;-Wall\" Assembler=\"\" Required=\"yes\" PreCompiledHeader=\"\"")
        projectFile.append(" PCHInCommandLine=\"no\" PCHFlags=\"\" PCHFlagsPolicy=\"0\">\n")
        projectFile.append("        <IncludePath Value=\".\"/>\n        <Preprocessor Value=\"NDEBUG\"/>\n")
        projectFile.append("      </Compiler>\n      <Linker Options=\"\" Required=\"yes\">\n")
        projectFile.append("        <LibraryPath Value=\"../Release\"/>\n        <Library Value=\"libscaly\"/>\n      </Linker>\n")
        projectFile.append("      <ResourceCompiler Options=\"\" Required=\"no\"/>\n")
        projectFile.append("      <General OutputFile=\"$(IntermediateDirectory)/$(ProjectName)\" IntermediateDirectory=\"../Release\"")
        projectFile.append(" Command=\"./$(ProjectName)\" CommandArguments=\"\" UseSeparateDebugArgs=\"no\" DebugArguments=\"\"")
        projectFile.append(" WorkingDirectory=\"$(IntermediateDirectory)\" PauseExecWhenProcTerminates=\"yes\" IsGUIProgram=\"no\" IsEnabled=\"yes\"/>\n")
        projectFile.append("      <Environment EnvVarSetName=\"&lt;Use Defaults&gt;\" DbgSetName=\"&lt;Use Defaults&gt;\">\n")
        projectFile.append("        <![CDATA[]]>\n      </Environment>\n")
        projectFile.append("      <Debugger IsRemote=\"no\" RemoteHostName=\"\" RemoteHostPort=\"\" DebuggerPath=\"\" IsExtended=\"yes\">\n")
        projectFile.append("        <DebuggerSearchPaths/>\n        <PostConnectCommands/>\n        <StartupCommands/>\n")
        projectFile.append("      </Debugger>\n      <PreBuild/>\n      <PostBuild/>\n      <CustomBuild Enabled=\"no\">\n")
        projectFile.append("        <RebuildCommand/>\n        <CleanCommand/>\n        <BuildCommand/>\n        <PreprocessFileCommand/>\n")
        projectFile.append("        <SingleFileCommand/>\n        <MakefileGenerationCommand/>\n")
        projectFile.append("        <ThirdPartyToolName>None</ThirdPartyToolName>\n        <WorkingDirectory/>\n")
        projectFile.append("      </CustomBuild>\n      <AdditionalRules>\n        <CustomPostBuild/>\n")
        projectFile.append("        <CustomPreBuild/>\n      </AdditionalRules>\n      <Completion EnableCpp11=\"no\" EnableCpp14=\"no\">\n")
        projectFile.append("        <ClangCmpFlagsC/>\n        <ClangCmpFlags/>\n        <ClangPP/>\n")
        projectFile.append("        <SearchPaths/>\n      </Completion>\n    </Configuration>\n  </Settings>\n</CodeLite_Project>\n")
    }
}
