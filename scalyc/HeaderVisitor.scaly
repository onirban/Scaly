class HeaderVisitor extends CppVisitor {
    
    let directory: string
    mutable headerFile: VarString
    mutable mainHeaderFile: VarString

    constructor(outputDirectory: string) {
        directory = outputDirectory
        headerFile = null
        mainHeaderFile = null
        inherits = new Inherits[]()
        classes = new string[]()
    }

    function openProgram(program: Program): bool {
        mutable programDirectory: string$ = new string(directory)

        if programDirectory == null || programDirectory.equals("") {
            programDirectory = new string(".")
        }

        if !Directory.exists(programDirectory) {
            Directory.create(programDirectory)
                catch _ (error: dirError())
                    return(false)
        }

        {
            mutable outputFilePath: VarString$ = new VarString(programDirectory)
            outputFilePath.append("/")
            outputFilePath.append(program.name)

            // Build and write the main header file
            {
                buildMainHeaderFileString(program)
                {
                    mutable headerFilePath: VarString$  = new VarString(outputFilePath)
                    headerFilePath.append(".h")
                    File.writeFromString(headerFilePath, mainHeaderFile)
                        catch _ (error: fileError)
                            return(false)
                }
            }

            collectInheritances(program)
        }

        true
    }

    function openCompilationUnit(compilationUnit: CompilationUnit): bool {

        if !(compilationUnit.parent is Program)
            return(false)

        let programName: string = (compilationUnit.parent as Program).name
        let fileName: string$ = getFileName(compilationUnit)

        if !fileName.equals(programName) {
            headerFile = new VarString()
            headerFile.append("#ifndef __")
            headerFile.append(programName)
            headerFile.append("__")
            headerFile.append(fileName)
            headerFile.append("__\n")
            headerFile.append("#define __")
            headerFile.append(programName)
            headerFile.append("__")
            headerFile.append(fileName)
            headerFile.append("__\n#include \"")
            headerFile.append(programName)
            headerFile.append(".h\"\nusing namespace scaly;\nnamespace ")
            headerFile.append(programName)
            headerFile.append(" {")
        }

        true
    }

    function closeCompilationUnit(compilationUnit: CompilationUnit) {

        if !(compilationUnit.parent) is Program
            return

        let programName: string = (compilationUnit.parent as Program).name
        mutable outputFilePath: VarString$  = new VarString(directory)
        outputFilePath.append('/')

        let fileName: string$ = Path.getFileNameWithoutExtension(getFileName(compilationUnit))
        outputFilePath.append(fileName)

        if !fileName.equals(programName) {
            headerFile.append("\n\n}\n#endif // __")
            headerFile.append(programName)
            headerFile.append("__")
            headerFile.append(fileName)
            headerFile.append("__\n")
            let headerFilePath: VarString$ = new VarString(outputFilePath)
            headerFilePath.append(".h")
            File.writeFromString(headerFilePath, headerFile)
                catch _ (error: fileError)
                    return
        }
    }

    function openConstantDeclaration(constantDeclaration: ConstantDeclaration): bool {

        if constantDeclaration.parent.parent.parent == null
            return(false)

        if constantDeclaration.parent.parent.parent is ClassDeclaration
            return(true)

        false
    }

    function openMutableDeclaration(mutableDeclaration: MutableDeclaration): bool {

        if mutableDeclaration.parent.parent.parent == null
            return(false)

        if mutableDeclaration.parent.parent.parent is ClassDeclaration
            return(true)

        false
    }

    function closeFunctionDeclaration(functionDeclaration: FunctionDeclaration) {

        if functionDeclaration.body == null
            headerFile.append(" = 0")
    }

    function openEnumDeclaration(enumDeclaration: EnumDeclaration): bool {
        let enumDeclarationName: string = enumDeclaration.name

        headerFile.append("\n\nclass ")
        headerFile.append(enumDeclarationName)
        headerFile.append(";\n")

        true
    }

    function closeEnumDeclaration(enumDeclaration: EnumDeclaration) {
        let enumDeclarationName: string = enumDeclaration.name
        let members: EnumMember[] = enumDeclaration.members

        if members != null {
            headerFile.append("enum _")
            headerFile.append(enumDeclarationName)
            headerFile.append("Code {\n")
            mutable i: int = 0
            for member: EnumMember in members {
                headerFile.append("    _")
                headerFile.append(enumDeclarationName)
                headerFile.append("Code_")
                headerFile.append(member.enumCase.name)
                if i == 0
                    headerFile.append(" = 1")
                headerFile.append(",\n")
                i++
            }
            headerFile.append("};\n\n")
        }

        headerFile.append("class ")
        headerFile.append(enumDeclarationName)
        headerFile.append(" : public Object {\npublic:\n    ")
        headerFile.append(enumDeclarationName)
        headerFile.append("(_")
        headerFile.append(enumDeclarationName)
        headerFile.append("Code errorCode)\n    : errorCode(errorCode), errorInfo(0) {}\n\n")

        if members != null {
            for member: EnumMember in members {
                if member.parameterClause {
                    headerFile.append("    ")
                    headerFile.append(enumDeclarationName)
                    headerFile.append("(_")
                    headerFile.append(enumDeclarationName)
                    headerFile.append("_")
                    headerFile.append(member.enumCase.name)
                    headerFile.append("* ")
                    headerFile.append(member.enumCase.name)
                    headerFile.append(")\n    : errorCode(_")
                    headerFile.append(enumDeclarationName)
                    headerFile.append("Code_")
                    headerFile.append(member.enumCase.name)
                    headerFile.append("), errorInfo(")
                    headerFile.append(member.enumCase.name)
                    headerFile.append(") {}\n\n")
                }
            }
        }

        headerFile.append("    long _getErrorCode();\n    void* _getErrorInfo();\n\n")

        if members != null {
            for member: EnumMember in members {
                if member.parameterClause {
                    headerFile.append("    _")
                    headerFile.append(enumDeclarationName)
                    headerFile.append("_")
                    headerFile.append(member.enumCase.name)
                    headerFile.append("* get_")
                    headerFile.append(member.enumCase.name)
                    headerFile.append("();\n")
                }
            }
        }
        headerFile.append("\nprivate:\n    _")
        headerFile.append(enumDeclarationName)
        headerFile.append("Code errorCode;\n    void* errorInfo;\n};")
    }

    function openClassDeclaration(classDeclaration: ClassDeclaration): bool {
        headerFile.append("\n\nclass ")
        headerFile.append(classDeclaration.name)
        if classDeclaration.body == null {
            headerFile.append(";")
            return(false)
        }

        headerFile.append(" : public ")
        if classDeclaration.typeInheritanceClause != null {
            let inheritances: Inheritance[] = classDeclaration.typeInheritanceClause.inheritances
            mutable i: int = 0
            for inheritance: Inheritance in inheritances {

                if i > 0
                    headerFile.append(", ")

                headerFile.append(inheritance.type.name)

                i++
            }
        }
        else {
            headerFile.append("Object")
        }
        headerFile.append(" {\n")
        headerFile.append("public:")

        true
    }

    function closeClassDeclaration(classDeclaration: ClassDeclaration) {

        headerFile.append("\n")

        if classDeclaration.typeInheritanceClause != null {
            headerFile.append("\n    virtual bool _is")
            headerFile.append(classDeclaration.name)
            headerFile.append("();")
        }

        {
            mutable derivedClasses: string[]$ = new string[]()
            collectDerivedClasses(derivedClasses, classDeclaration.name)
            for derivedClass: string in derivedClasses {
                headerFile.append("\n    virtual bool _is")
                headerFile.append(derivedClass)
                headerFile.append("();")
            }
        }

        headerFile.append("\n};")
    }

    function openConstructorDeclaration(constructorDeclaration: ConstructorDeclaration): bool {

        if !constructorDeclaration.parent.parent.parent is ClassDeclaration
            return(false)

        let classDeclarationName: string = (constructorDeclaration.parent.parent.parent as ClassDeclaration).name

        headerFile.append(classDeclarationName)
        headerFile.append("(")

        true
    }

    function openCodeBlock(codeBlock: CodeBlock): bool {
        false
    }

    function openPatternInitializer(patternInitializer: PatternInitializer): bool {
        if patternInitializer.parent is AdditionalInitializer
            headerFile.append(", ")

        true
    }

    function openFunctionSignature(functionSignature: FunctionSignature): bool {
        let functionName: string = (functionSignature.parent as FunctionDeclaration).name

        let functionDeclaration: FunctionDeclaration = functionSignature.parent as FunctionDeclaration
        if functionDeclaration.modifiers != null {
            for modifier: Modifier in functionDeclaration.modifiers {
                if modifier is StaticWord
                    headerFile.append("static ")
                else
                    headerFile.append("virtual ")
            }
        }
        else {
            headerFile.append("virtual ")
        }

        if functionSignature.result == null {
            if functionSignature.throwsClause == null {
                headerFile.append("void")
            }
            else {
                appendCppType(headerFile, functionSignature.throwsClause.throwsType)
            }
        }
        else {
            if functionSignature.throwsClause != null {
                headerFile.append("_Result<")

                if hasArrayPostfix(functionSignature.result.resultType) {
                    headerFile.append("_Array<")
                    appendCppTypeName(headerFile, functionSignature.result.resultType)
                    headerFile.append(">")
                }
                else {
                    appendCppTypeName(headerFile, functionSignature.result.resultType)
                }
                headerFile.append(", ")
                appendCppTypeName(headerFile, functionSignature.throwsClause.throwsType)
                headerFile.append(">")
            }
            else {
                if hasArrayPostfix(functionSignature.result.resultType) {
                    headerFile.append("_Array<")
                    let type: Type = functionSignature.result.resultType
                    appendCppTypeName(headerFile, type)
                    headerFile.append(">*")
                }
                else {
                    appendCppTypeName(headerFile, functionSignature.result.resultType)
                    if isClass(functionSignature.result.resultType.name) {
                        headerFile.append("*")
                    }
                }
            }
        }

        headerFile.append(" ")
        headerFile.append(functionName)
        headerFile.append("(")
        if functionSignature.result != null {
            if isClass(functionSignature.result.resultType.name) {
                let lifeTime: LifeTime = functionSignature.result.resultType.lifeTime
                if (lifeTime == null) || !(lifeTime is Reference) {
                    headerFile.append("_Page* _rp")
                    if (functionSignature.parameterClause.parameters) || (functionSignature.throwsClause) {
                        headerFile.append(", ")
                    }
                }
            }
        }
        if functionSignature.throwsClause != null {
            headerFile.append("_Page* _ep")
            if functionSignature.parameterClause.parameters {
                headerFile.append(", ")
            }
        }

        true
    }

    function closeParameterClause(parameterClause: ParameterClause) {
        headerFile.append(")")
    }

    function openConstParameter(constParameter: ConstParameter): bool {
        let constParameterName: string = constParameter.name
        writeParameter(constParameterName, constParameter.parameterType)

        false
    }

    function writeParameter(name: string, parameterType: Type) {
        if parameterType.parent is Parameter {
            let parameter: Parameter = parameterType.parent as Parameter
            if parameter.parent is ParameterClause {
                let parameters: Parameter[] = (parameter.parent as ParameterClause).parameters
                if parameter != parameters[0]
                    headerFile.append(", ")
                parameterType.accept(this)
                headerFile.append(" ")
                headerFile.append(name)
            }
        }
    }

    function isClass(name: string): bool {
        if name.equals("string")
        ||  name.equals("VarString")
        ||  name.equals("File")
        ||  name.equals("Directory")
        ||  name.equals("Path")
        ||  name.equals("DirectoryError")
        ||  name.equals("FileError")
        ||  name.equals("ParserError")
        ||  name.equals("CppError")
        ||  name.equals("CompilerError")
            return(true)

        for className: string in classes {
            if className.equals(name) {
                return(true)
            }
        }

        false
    }

    function closeConstParameter(constParameter: ConstParameter) {
        headerFile.append(constParameter.name)
    }

    function openVarParameter(varParameter: VarParameter): bool {
        writeParameter(varParameter.name, varParameter.parameterType)
        false
    }

    function closeVarParameter(varParameter: VarParameter) {
        headerFile.append(varParameter.name)
    }

    function openEnumMember(enumMember: EnumMember): bool {
        if !enumMember.parent is EnumDeclaration
            return(false)

        let enumDeclarationName: string = (enumMember.parent as EnumDeclaration).name
        if enumMember.parameterClause {
            headerFile.append("\nclass _")
            headerFile.append(enumDeclarationName)
            headerFile.append("_")
            headerFile.append(enumMember.enumCase.name)
            headerFile.append(" : public Object {\npublic:\n    _")
            headerFile.append(enumDeclarationName)
            headerFile.append("_")
            headerFile.append(enumMember.enumCase.name)
            headerFile.append("(")
        }

        true
    }

    function closeEnumMember(enumMember: EnumMember) {
        if enumMember.parameterClause != null {
            headerFile.append(";\n\n")

            let parameters: Parameter[] = enumMember.parameterClause.parameters
            if parameters != null {
                mutable pos: number = 0
                for parameter: Parameter in parameters {
                    if parameter is ConstParameter {
                        let constParameter: ConstParameter = parameter as ConstParameter
                        headerFile.append("    ")
                        appendCppType(headerFile, constParameter.parameterType)
                        headerFile.append(" ")
                        headerFile.append(constParameter.name)
                        headerFile.append(";\n")
                    }
                    pos++
                }
            }

            headerFile.append("};\n")
        }
    }

    function openClassMember(classMember: ClassMember): bool {
        headerFile.append("\n    ")

        true
    }

    function closeClassMember(classMember: ClassMember) {
        headerFile.append(";")
    }

    function openIdentifierPattern(identifierPattern: IdentifierPattern): bool {

        if identifierPattern.annotationForType != null {
            identifierPattern.annotationForType.accept(this)
            headerFile.append(" ")
        }

        headerFile.append(identifierPattern.identifier)

        false
    }

    function openType(type: Type): bool {

        if (type.parent is FunctionResult)
        || (type.parent is Inheritance)
        || (type.parent is ThrowsClause)
            return(false)
            
        if hasArrayPostfix(type) {
            headerFile.append("_Array<")
        }
        appendCppTypeName(headerFile, type)
 
        true
    }

    function closeType(type: Type) {

        if hasArrayPostfix(type)
            headerFile.append(">*")

        if isClass(type.name) && !hasArrayPostfix(type) && !type.parent is ConstructorCall {
                headerFile.append("*")
        }
    }

    function buildMainHeaderFileString(program: Program) {
        mainHeaderFile = new VarString()
        mainHeaderFile.append("#ifndef __scaly__")
        mainHeaderFile.append(program.name)
        mainHeaderFile.append("__\n#define __scaly__")
        mainHeaderFile.append(program.name)
        mainHeaderFile.append("__\n\n#include \"Scaly.h\"\n")
        for compilationUnit: CompilationUnit in program.compilationUnits {
            mainHeaderFile.append("#include \"")
            let fileName: string$ = getFileName(compilationUnit)
            let fileNameWithoutExtension: string$ = Path.getFileNameWithoutExtension(fileName)
            mainHeaderFile.append(fileNameWithoutExtension)
            mainHeaderFile.append(".h\"\n")
        }
        mainHeaderFile.append("\nusing namespace scaly;\nnamespace ")
        mainHeaderFile.append(program.name)
        mainHeaderFile.append(" {\nFileError* _main(_Page* page, _Array<string>* arguments);\n}\n\n#endif // __scaly__")
        mainHeaderFile.append(program.name)
        mainHeaderFile.append("__\n")
    }

    function collectInheritances(program: Program) {
        for compilationUnit: CompilationUnit in program.compilationUnits
            collectInheritancesInCompilationUnit(compilationUnit)
    }
}