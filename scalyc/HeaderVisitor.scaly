class HeaderVisitor extends CppVisitor {
    
    mutable headerFile: VarString
    mutable mainHeaderFile: VarString

    // Some rudimentary semantics cache
    mutable inherits: Inherits[]
    mutable classes: string[]

    constructor() {

        // null constructor of mutable members does not work yet
        moduleName = new string()
        headerFile = new VarString()
        mainHeaderFile = new VarString()
        inherits = new Inherits[]()
        classes = new string[]()
    }

    function openProgram(program: Program): bool {
        mutable programDirectory: string$ = new string(program.directory)

        if programDirectory == null || programDirectory.equals("") {
            programDirectory = new string(".")
        }

        if !Directory.exists(programDirectory) {
            Directory.create(programDirectory)
                catch _ (error: dirError())
                    return(false)
        }

        {
            mutable outputFilePath: VarString$ = new VarString(programDirectory)
            outputFilePath.append("/")
            outputFilePath.append(program.name)

            // Build and write the main header file
            {
                buildMainHeaderFileString(program)
                {
                    mutable headerFilePath: VarString$  = new VarString(outputFilePath)
                    headerFilePath.append(".h")
                    File.writeFromString(headerFilePath, mainHeaderFile)
                        catch _ (error: fileError)
                            return(false)
                }
            }

            collectInheritances(program)
        }

        true
    }

    function openCompilationUnit(compilationUnit: CompilationUnit): bool {

        moduleName = compilationUnit.fileName

        if !(compilationUnit.parent is Program)
            return(false)

        let programName: string = ((compilationUnit.parent) as Program).name

        if !moduleName.equals(programName) {
            headerFile = new VarString()
            headerFile.append("#ifndef __")
            headerFile.append(programName)
            headerFile.append("__")
            headerFile.append(moduleName)
            headerFile.append("__\n")
            headerFile.append("#define __")
            headerFile.append(programName)
            headerFile.append("__")
            headerFile.append(moduleName)
            headerFile.append("__\n#include \"")
            headerFile.append(programName)
            headerFile.append(".h\"\nusing namespace scaly;\nnamespace ")
            headerFile.append(programName)
            headerFile.append(" {")
        }

        true
    }

    function closeCompilationUnit(compilationUnit: CompilationUnit) {

        if !(compilationUnit.parent) is Program
            return

        let programName: string = ((compilationUnit.parent) as Program).name
        let programDirectory: string = ((compilationUnit.parent) as Program).directory
        mutable outputFilePath: VarString$  = new VarString(programDirectory)
        outputFilePath.append('/')
        let fileNameWithoutExtension: string$ = Path.getFileNameWithoutExtension(compilationUnit.fileName)
        outputFilePath.append(fileNameWithoutExtension)

        if !moduleName.equals(programName) {
            headerFile.append("\n\n}\n#endif // __scalyc__")
            headerFile.append(moduleName)
            headerFile.append("__\n")
            let headerFilePath: VarString = new VarString(outputFilePath)
            headerFilePath.append(".h")
            File.writeFromString(headerFilePath, headerFile)
                catch _ (error: fileError)
                    return
        }
    }

    function openConstantDeclaration(constantDeclaration: ConstantDeclaration): bool {

        if constantDeclaration.parent.parent.parent == null
            return(false)

        if constantDeclaration.parent.parent.parent is ClassDeclaration
            return(true)

        false
    }

    function openVariableDeclaration(variableDeclaration: VariableDeclaration): bool {

        if variableDeclaration.parent.parent.parent == null
            return(false)

        if variableDeclaration.parent.parent.parent is ClassDeclaration
            return(true)

        false
    }

    function openMutableDeclaration(mutableDeclaration: MutableDeclaration): bool {

        if mutableDeclaration.parent.parent.parent == null
            return(false)

        if mutableDeclaration.parent.parent.parent is ClassDeclaration
            return(true)

        false
    }

    function closeFunctionDeclaration(functionDeclaration: FunctionDeclaration) {

        if functionDeclaration.body == null
            headerFile.append(" = 0")
    }

    function openEnumDeclaration(enumDeclaration: EnumDeclaration): bool {
        let enumDeclarationName: string = enumDeclaration.name

        headerFile.append("\n\nclass ")
        headerFile.append(enumDeclarationName)
        headerFile.append(";\n")

        true
    }

    function closeEnumDeclaration(enumDeclaration: EnumDeclaration) {
        let enumDeclarationName: string = enumDeclaration.name
        let members: EnumMember[] = enumDeclaration.members

        if members != null {
            headerFile.append("enum _")
            headerFile.append(enumDeclarationName)
            headerFile.append("Code {\n")
            var i: int = 0
            for member: EnumMember in members {
                headerFile.append("    _")
                headerFile.append(enumDeclarationName)
                headerFile.append("Code_")
                headerFile.append(member.enumCase.name)
                if i == 0
                    headerFile.append(" = 1")
                headerFile.append(",\n")
                i++
            }
            headerFile.append("};\n\n")
        }

        headerFile.append("class ")
        headerFile.append(enumDeclarationName)
        headerFile.append(" : public Object {\npublic:\n    ")
        headerFile.append(enumDeclarationName)
        headerFile.append("(_")
        headerFile.append(enumDeclarationName)
        headerFile.append("Code errorCode)\n    : errorCode(errorCode), errorInfo(0) {}\n\n")

        if members != null {
            for member: EnumMember in members {
                if member.parameterClause {
                    headerFile.append("    ")
                    headerFile.append(enumDeclarationName)
                    headerFile.append("(_")
                    headerFile.append(enumDeclarationName)
                    headerFile.append("_")
                    headerFile.append(member.enumCase.name)
                    headerFile.append("* ")
                    headerFile.append(member.enumCase.name)
                    headerFile.append(")\n    : errorCode(_")
                    headerFile.append(enumDeclarationName)
                    headerFile.append("Code_")
                    headerFile.append(member.enumCase.name)
                    headerFile.append("), errorInfo(")
                    headerFile.append(member.enumCase.name)
                    headerFile.append(") {}\n\n")
                }
            }
        }

        headerFile.append("    long _getErrorCode();\n    void* _getErrorInfo();\n\n")

        if members != null {
            for member: EnumMember in members {
                if member.parameterClause {
                    headerFile.append("    _")
                    headerFile.append(enumDeclarationName)
                    headerFile.append("_")
                    headerFile.append(member.enumCase.name)
                    headerFile.append("* get_")
                    headerFile.append(member.enumCase.name)
                    headerFile.append("();\n")
                }
            }
        }
        headerFile.append("\nprivate:\n    _")
        headerFile.append(enumDeclarationName)
        headerFile.append("Code errorCode;\n    void* errorInfo;\n};")
    }

    function openClassDeclaration(classDeclaration: ClassDeclaration): bool {
        headerFile.append("\n\nclass ")
        headerFile.append(classDeclaration.name)
        if classDeclaration.body == null {
            headerFile.append(";")
            return(false)
        }

        headerFile.append(" : public ")
        if classDeclaration.typeInheritanceClause != null {
            let inheritances: Inheritance[] = classDeclaration.typeInheritanceClause.inheritances
            var i: int = 0
            for inheritance: Inheritance in inheritances {

                if i > 0
                    headerFile.append(", ")

                headerFile.append(inheritance.type.name)

                i++
            }
        }
        else {
            headerFile.append("Object")
        }
        headerFile.append(" {\n")
        headerFile.append("public:")

        true
    }

    function closeClassDeclaration(classDeclaration: ClassDeclaration) {

        headerFile.append("\n")

        if classDeclaration.typeInheritanceClause != null {
            headerFile.append("\n    virtual bool _is")
            headerFile.append(classDeclaration.name)
            headerFile.append("();")
        }

        {
            mutable derivedClasses: string[]$ = new string[]()
            collectDerivedClasses(derivedClasses, new string(classDeclaration.name))
            for derivedClass: string in derivedClasses {
                headerFile.append("\n    virtual bool _is")
                headerFile.append(derivedClass)
                headerFile.append("();")
            }
        }

        headerFile.append("\n};")
    }

    function openConstructorDeclaration(constructorDeclaration: ConstructorDeclaration): bool {

        if !constructorDeclaration.parent.parent.parent is ClassDeclaration
            return(false)

        let classDeclarationName: string = ((constructorDeclaration.parent.parent.parent) as Program).name

        headerFile.append(classDeclarationName)
        headerFile.append("(")

        true
    }

    function openCodeBlock(codeBlock: CodeBlock): bool {
        false
    }

    function openPatternInitializer(patternInitializer: PatternInitializer): bool {
        if patternInitializer.parent is AdditionalInitializer
            headerFile.append(", ")

        true
    }

    function openFunctionSignature(functionSignature: FunctionSignature): bool {
        let functionName: string = (functionSignature.parent as FunctionDeclaration).name

        let functionDeclaration: FunctionDeclaration = functionSignature.parent as FunctionDeclaration
        if functionDeclaration.modifiers != null {
            let modifiers: Modifier[] = functionDeclaration.modifiers
            for modifier: Modifier in modifiers {
                if modifier is StaticWord
                    headerFile.append("static ")
                else
                    headerFile.append("virtual ")
            }
        }
        else {
            headerFile.append("virtual ")
        }

        if functionSignature.result == null {
            if functionSignature.throwsClause == null {
                headerFile.append("void")
            }
            else {
                appendCppType(headerFile, functionSignature.throwsClause.throwsType)
            }
        }
        else {
            if functionSignature.throwsClause != null {
                headerFile.append("_Result<")

                if hasArrayPostfix(functionSignature.result.resultType) {
                    headerFile.append("_Array<")
                    let type: Type = functionSignature.result.resultType
                    appendCppTypeName(headerFile, type)
                    headerFile.append(">")
                }
                else {
                    let type: Type = functionSignature.result.resultType as Type
                    appendCppTypeName(headerFile, type)
                }
                headerFile.append(", ")
                appendCppTypeName(headerFile, (functionSignature.throwsClause.throwsType) as Type)
                headerFile.append(">")
            }
            else {
                if hasArrayPostfix(functionSignature.result.resultType) {
                    headerFile.append("_Array<")
                    let type: Type = functionSignature.result.resultType
                    appendCppTypeName(headerFile, type)
                    headerFile.append(">")
                }
                else {
                    let type: Type = functionSignature.result.resultType as Type
                    appendCppTypeName(headerFile, type)
                    if isClass(type.name) {
                        headerFile.append("*")
                    }
                }
            }
        }

        headerFile.append(" ")
        headerFile.append(functionName)
        headerFile.append("(")
        if functionSignature.result != null {
            let type: Type = functionSignature.result.resultType as Type
            if isClass(type.name) {
                let lifeTime: LifeTime = type.lifeTime
                if (lifeTime == null) || !(lifeTime is Reference) {
                    headerFile.append("_Page* _rp")
                    if (functionSignature.parameterClause.parameters) || (functionSignature.throwsClause) {
                        headerFile.append(", ")
                    }
                }
            }
        }
        if functionSignature.throwsClause != null {
            headerFile.append("_Page* _ep")
            if functionSignature.parameterClause.parameters {
                headerFile.append(", ")
            }
        }

        true
    }

    function closeParameterClause(parameterClause: ParameterClause) {
        headerFile.append(")")
    }

    function openConstParameter(constParameter: ConstParameter): bool {
        let constParameterName: string = constParameter.name
        writeParameter(constParameterName, constParameter.parameterType)

        false
    }

    function writeParameter(name: string, parameterType: Type) {
        let parameterClause: ParameterClause = parameterType.parent.parent as ParameterClause
        let parameters: Parameter[] = parameterClause.parameters
        let parameter: Parameter = parameterType.parent as Parameter
        if parameter != parameters[0]
            headerFile.append(", ")
        parameterType.accept(this)
        headerFile.append(" ")
        headerFile.append(name)
    }

    function isClass(name: string): bool {
        if (    name.equals("string")
            ||  name.equals("VarString")
            ||  name.equals("File")
            ||  name.equals("Directory")
            ||  name.equals("Path")
            ||  name.equals("DirectoryError")
            ||  name.equals("FileError")
            ||  name.equals("ParserError")
            ||  name.equals("CppError")
            ||  name.equals("CompilerError")
           )
        {
            return(true)
        }

        for className: string in classes {
            if className.equals(name) {
                return(true)
            }
        }

        false
    }

    function closeConstParameter(constParameter: ConstParameter) {
        headerFile.append(constParameter.name)
    }

    function openVarParameter(varParameter: VarParameter): bool {
        writeParameter(varParameter.name, varParameter.parameterType)
        false
    }

    function closeVarParameter(varParameter: VarParameter) {
        let varParameterName: string = varParameter.name
        headerFile.append(varParameterName)
    }

    function openEnumMember(enumMember: EnumMember): bool {
        if !enumMember.parent is EnumDeclaration
            return(false)

        let enumDeclarationName: string = ((enumMember.parent) as EnumDeclaration).name
        if enumMember.parameterClause {
            headerFile.append("\nclass _")
            headerFile.append(enumDeclarationName)
            headerFile.append("_")
            headerFile.append(enumMember.enumCase.name)
            headerFile.append(" : public Object {\npublic:\n    _")
            headerFile.append(enumDeclarationName)
            headerFile.append("_")
            headerFile.append(enumMember.enumCase.name)
            headerFile.append("(")
        }

        true
    }

    function closeEnumMember(enumMember: EnumMember) {
        if enumMember.parameterClause != null {
            headerFile.append(";\n\n")

            let parameters: Parameter[] = enumMember.parameterClause.parameters
            if parameters != null {
                var pos: number = 0
                for parameter: Parameter in parameters {
                    if parameter is ConstParameter {
                        let constParameter: ConstParameter = parameter as ConstParameter
                        headerFile.append("    ")
                        appendCppType(headerFile, constParameter.parameterType)
                        headerFile.append(" ")
                        headerFile.append(constParameter.name)
                        headerFile.append(";\n")
                    }
                    pos++
                }
            }

            headerFile.append("};\n")
        }
    }

    function collectDerivedClasses(mutable derivedClasses: string[], className: string) {
        for inherit: Inherits in inherits {
            if inherit.name.equals(className)
                appendDerivedClasses(derivedClasses, inherit.inheritors)
        }
    }

    function appendDerivedClasses(mutable derivedClasses: string[], mutable inheritors: string[]) {
        for inheritor: string in inheritors {
            derivedClasses.push(inheritor)
            collectDerivedClasses(derivedClasses, inheritor)
        }
    }

    function openClassMember(classMember: ClassMember): bool {
        headerFile.append("\n    ")

        true
    }

    function closeClassMember(classMember: ClassMember) {
        headerFile.append(";")
    }

    function openIdentifierPattern(identifierPattern: IdentifierPattern): bool {

        if identifierPattern.annotationForType != null {
            identifierPattern.annotationForType.accept(this)
            headerFile.append(" ")
        }

        headerFile.append(identifierPattern.identifier)

        false
    }

    function openType(type: Type): bool {

        if (type.parent is FunctionResult) || (type.parent is Inheritance) || (type.parent is ThrowsClause)
            return(false)
            
        if hasArrayPostfix(type) {
            headerFile.append("_Array<")
        }
        appendCppTypeName(headerFile, type)
 
        true
    }

    function closeType(type: Type) {

        if hasArrayPostfix(type)
            headerFile.append(">*")

        if isClass(type.name) && !hasArrayPostfix(type) && !type.parent is ConstructorCall {
                headerFile.append("*")
        }
    }

    function buildMainHeaderFileString(program: Program) {
        mainHeaderFile.append("#ifndef __scaly__")
        mainHeaderFile.append(program.name)
        mainHeaderFile.append("__\n#define __scaly__")
        mainHeaderFile.append(program.name)
        mainHeaderFile.append("__\n\n#include \"Scaly.h\"\n")
        let compilationUnits: CompilationUnit[] = program.compilationUnits
        for compilationUnit: CompilationUnit in compilationUnits {
            mainHeaderFile.append("#include \"")
            let fileName: string$ = Path.getFileNameWithoutExtension(compilationUnit.fileName)
            mainHeaderFile.append(fileName)
            mainHeaderFile.append(".h\"\n")
        }
        mainHeaderFile.append("\nusing namespace scaly;\nnamespace ")
        mainHeaderFile.append(program.name)
        mainHeaderFile.append(" {\nFileError* _main(_Page* page, _Array<string>* arguments);\n}\n\n#endif // __scaly__")
        mainHeaderFile.append(program.name)
        mainHeaderFile.append("__\n")
    }

    function collectInheritances(program: Program) {
        let compilationUnits: CompilationUnit[] = program.compilationUnits
        for compilationUnit: CompilationUnit in compilationUnits
            collectInheritancesInCompilationUnit(compilationUnit)
    }

    function collectInheritancesInCompilationUnit(compilationUnit: CompilationUnit) {
        if compilationUnit.statements != null {
            let statements: Statement[] = compilationUnit.statements
            for statement: Statement in statements {
                if statement is ClassDeclaration {
                    let classDeclaration: ClassDeclaration = statement as ClassDeclaration
                    classes.push(classDeclaration.name)
                    if classDeclaration.typeInheritanceClause != null {
                        let inheritanceClause: TypeInheritanceClause  = classDeclaration.typeInheritanceClause
                        let inheritances: Inheritance[] = inheritanceClause.inheritances
                        for inheritance: Inheritance in inheritances {
                            registerInheritance(classDeclaration.name, inheritance.type.name)
                        }
                    }
                }
            }
        }
    }

    function registerInheritance(className: string, baseName: string) {
        var inherit: Inherits@inherits = null
        for inh: Inherits in inherits {
            if inh.name.equals(baseName)
             inherit = inh
        }

        if inherit == null {
            inherit = new Inherits(baseName)
            inherits.push(inherit)
        }
        inherit.inheritors.push(className)
    }
}