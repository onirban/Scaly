class Parser {
    init(theFileName: String, text: String) {
        lexer = Lexer(text)
        fileName = theFileName
        useKeyword = String("use")
        classKeyword = String("class")
        functionKeyword = String("function")
        ifKeyword = String("if")
        elseKeyword = String("else")
        switchKeyword = String("switch")
        caseKeyword = String("case")
        defaultKeyword = String("default")
        catchKeyword = String("catch")
        forKeyword = String("for")
        inKeyword = String("in")
        whileKeyword = String("while")
        repeatKeyword = String("repeat")
        returnKeyword = String("return")
        throwKeyword = String("throw")
        breakKeyword = String("break")
        throwsKeyword = String("throws")
        existingKeyword = String("existing")
        overrideKeyword = String("override")
        staticKeyword = String("static")
        letKeyword = String("let")
        varKeyword = String("var")
        mutableKeyword = String("mutable")
        isKeyword = String("is")
        asKeyword = String("as")
        initKeyword = String("init")
        enumKeyword = String("enum")
        superKeyword = String("super")
        thisKeyword = String("this")
        nullKeyword = String("null")
        semicolon = String(";")
        equal = String("=")
        leftAngular = String("<")
        rightAngular = String(">")
        comma = String(",")
        leftParen = String("(")
        rightParen = String(")")
        leftCurly = String("{")
        rightCurly = String("}")
        leftBracket = String("[")
        rightBracket = String("]")
        colon = String(":")
        dot = String(".")
        questionMark = String("?")
        underscore = String("_")
        evaluatesTo = String("->")
    }

    function parseCompilationUnit() -> CompilationUnit throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let statements: [TerminatedStatement] = parseTerminatedStatementList() catch _ null
        if statements != null {
            if !isAtEnd() {
                mutable current: Position = lexer.getPosition()
                throw notAtEnd(Position(current))
            }
        }
        mutable end: Position = lexer.getPosition()
        var ret: CompilationUnit = CompilationUnit(statements, Position(start), Position(end))
        ret.fileName = fileName
        if statements != null {
            for item: TerminatedStatement in statements
                item.parent = ret
        }

        return ret
    }

    function parseTerminatedStatementList() -> [TerminatedStatement] throws ParserError {
        mutable ret: [TerminatedStatement]? = null
        while true {
            let node: TerminatedStatement = parseTerminatedStatement()
                catch _ break;
            if ret == null
                ret = [TerminatedStatement]()
            ret.push(node)
        }
        return ret
    }

    function parseTerminatedStatement() -> TerminatedStatement throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let statement: Statement = parseStatement() catch _ (error)
            throw error
        let successSemicolon2: bool = lexer.parsePunctuation(semicolon)
        if successSemicolon2
            lexer.advance()
        mutable end: Position = lexer.getPosition()
        var ret: TerminatedStatement = TerminatedStatement(statement, Position(start), Position(end))
        statement.parent = ret

        return ret
    }

    function parseStatement() -> Statement throws ParserError {
        mutable errors: [ParserError] = [ParserError]()
        mutable start: Position = lexer.getPreviousPosition()

        {
            let node: Declaration = parseDeclaration() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        {
            let node: Expression = parseExpression() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        throw ParserError.UnableToParse(Position(start), errors)
    }

    function parseDeclaration() -> Declaration throws ParserError {
        mutable errors: [ParserError] = [ParserError]()
        mutable start: Position = lexer.getPreviousPosition()

        {
            let node: UseDeclaration = parseUseDeclaration() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        {
            let node: ConstantDeclaration = parseConstantDeclaration() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        {
            let node: VariableDeclaration = parseVariableDeclaration() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        {
            let node: MutableDeclaration = parseMutableDeclaration() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        {
            let node: FunctionDeclaration = parseFunctionDeclaration() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        {
            let node: EnumDeclaration = parseEnumDeclaration() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        {
            let node: ClassDeclaration = parseClassDeclaration() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        {
            let node: InitializerDeclaration = parseInitializerDeclaration() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        throw ParserError.UnableToParse(Position(start), errors)
    }

    function parseExpression() -> Expression throws ParserError {
        mutable errors: [ParserError] = [ParserError]()
        mutable start: Position = lexer.getPreviousPosition()

        {
            let node: CodeBlock = parseCodeBlock() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        {
            let node: SimpleExpression = parseSimpleExpression() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        throw ParserError.UnableToParse(Position(start), errors)
    }

    function parseUseDeclaration() -> UseDeclaration throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startUse1: Position = lexer.getPreviousPosition()
        let successUse1: bool = lexer.parseKeyword(useKeyword)
        if successUse1
            lexer.advance()
        let importModule: PathItem = parsePathItem() catch _ (error)
            throw error
        let importExtensions: [PathIdentifier] = parsePathIdentifierList() catch _ null
        mutable end: Position = lexer.getPosition()
        var ret: UseDeclaration = UseDeclaration(importModule, importExtensions, Position(start), Position(end))
        importModule.parent = ret
        if importExtensions != null {
            for item: PathIdentifier in importExtensions
                item.parent = ret
        }

        return ret
    }

    function parseConstantDeclaration() -> ConstantDeclaration throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startLet1: Position = lexer.getPreviousPosition()
        let successLet1: bool = lexer.parseKeyword(letKeyword)
        if successLet1
            lexer.advance()
        let initializer: BindingInitializer = parseBindingInitializer() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: ConstantDeclaration = ConstantDeclaration(initializer, Position(start), Position(end))
        initializer.parent = ret

        return ret
    }

    function parseVariableDeclaration() -> VariableDeclaration throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startVar1: Position = lexer.getPreviousPosition()
        let successVar1: bool = lexer.parseKeyword(varKeyword)
        if successVar1
            lexer.advance()
        let initializer: BindingInitializer = parseBindingInitializer() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: VariableDeclaration = VariableDeclaration(initializer, Position(start), Position(end))
        initializer.parent = ret

        return ret
    }

    function parseMutableDeclaration() -> MutableDeclaration throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startMutable1: Position = lexer.getPreviousPosition()
        let successMutable1: bool = lexer.parseKeyword(mutableKeyword)
        if successMutable1
            lexer.advance()
        let initializer: BindingInitializer = parseBindingInitializer() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: MutableDeclaration = MutableDeclaration(initializer, Position(start), Position(end))
        initializer.parent = ret

        return ret
    }

    function parseFunctionDeclaration() -> FunctionDeclaration throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let modifiers: [Modifier] = parseModifierList() catch _ null
        mutable startFunction2: Position = lexer.getPreviousPosition()
        let successFunction2: bool = lexer.parseKeyword(functionKeyword)
        if successFunction2
            lexer.advance()
        let name: FunctionName = parseFunctionName() catch _ (error)
            throw error
        let signature: FunctionSignature = parseFunctionSignature() catch _ (error)
            throw error
        let body: Expression = parseExpression() catch _ null
        mutable end: Position = lexer.getPosition()
        var ret: FunctionDeclaration = FunctionDeclaration(modifiers, name, signature, body, Position(start), Position(end))
        if modifiers != null {
            for item: Modifier in modifiers
                item.parent = ret
        }
        name.parent = ret
        signature.parent = ret
       if body != null
            body.parent = ret

        return ret
    }

    function parseEnumDeclaration() -> EnumDeclaration throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startEnum1: Position = lexer.getPreviousPosition()
        let successEnum1: bool = lexer.parseKeyword(enumKeyword)
        if successEnum1
            lexer.advance()
        mutable startName: Position = lexer.getPreviousPosition()
        let name: String? = lexer.parseIdentifier()
        if (name != null) && (name is Identifier)
            lexer.advance()
        mutable startLeftCurly3: Position = lexer.getPreviousPosition()
        let successLeftCurly3: bool = lexer.parsePunctuation(leftCurly)
        if successLeftCurly3
            lexer.advance()
        let members: [EnumMember] = parseEnumMemberList() catch _ (error)
            throw error
        mutable startRightCurly5: Position = lexer.getPreviousPosition()
        let successRightCurly5: bool = lexer.parsePunctuation(rightCurly)
        if successRightCurly5
            lexer.advance()
        mutable end: Position = lexer.getPosition()
        var ret: EnumDeclaration = EnumDeclaration(name, members, Position(start), Position(end))
        if members != null {
            for item: EnumMember in members
                item.parent = ret
        }

        return ret
    }

    function parseClassDeclaration() -> ClassDeclaration throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startClass1: Position = lexer.getPreviousPosition()
        let successClass1: bool = lexer.parseKeyword(classKeyword)
        if successClass1
            lexer.advance()
        mutable startName: Position = lexer.getPreviousPosition()
        let name: String? = lexer.parseIdentifier()
        if (name != null) && (name is Identifier)
            lexer.advance()
        let genericArgumentClause: GenericArgumentClause = parseGenericArgumentClause() catch _ null
        let typeInheritanceClause: TypeInheritanceClause = parseTypeInheritanceClause() catch _ null
        let body: ClassBody = parseClassBody() catch _ null
        mutable end: Position = lexer.getPosition()
        var ret: ClassDeclaration = ClassDeclaration(name, genericArgumentClause, typeInheritanceClause, body, Position(start), Position(end))
       if genericArgumentClause != null
            genericArgumentClause.parent = ret
       if typeInheritanceClause != null
            typeInheritanceClause.parent = ret
       if body != null
            body.parent = ret

        return ret
    }

    function parseInitializerDeclaration() -> InitializerDeclaration throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let modifiers: [Modifier] = parseModifierList() catch _ null
        mutable startInit2: Position = lexer.getPreviousPosition()
        let successInit2: bool = lexer.parseKeyword(initKeyword)
        if successInit2
            lexer.advance()
        let parameterClause: ParameterClause = parseParameterClause() catch _ (error)
            throw error
        let throwsClause: ThrowsClause = parseThrowsClause() catch _ null
        let body: Expression = parseExpression() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: InitializerDeclaration = InitializerDeclaration(modifiers, parameterClause, throwsClause, body, Position(start), Position(end))
        if modifiers != null {
            for item: Modifier in modifiers
                item.parent = ret
        }
        parameterClause.parent = ret
       if throwsClause != null
            throwsClause.parent = ret
        body.parent = ret

        return ret
    }

    function parseCodeBlock() -> CodeBlock throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startLeftCurly1: Position = lexer.getPreviousPosition()
        let successLeftCurly1: bool = lexer.parsePunctuation(leftCurly)
        if successLeftCurly1
            lexer.advance()
        let statements: [TerminatedStatement] = parseTerminatedStatementList() catch _ (error)
            throw error
        mutable startRightCurly3: Position = lexer.getPreviousPosition()
        let successRightCurly3: bool = lexer.parsePunctuation(rightCurly)
        if successRightCurly3
            lexer.advance()
        mutable end: Position = lexer.getPosition()
        var ret: CodeBlock = CodeBlock(statements, Position(start), Position(end))
        if statements != null {
            for item: TerminatedStatement in statements
                item.parent = ret
        }

        return ret
    }

    function parseSimpleExpression() -> SimpleExpression throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let prefixExpression: PrefixExpression = parsePrefixExpression() catch _ (error)
            throw error
        let binaryOps: [BinaryOp] = parseBinaryOpList() catch _ null
        mutable end: Position = lexer.getPosition()
        var ret: SimpleExpression = SimpleExpression(prefixExpression, binaryOps, Position(start), Position(end))
        prefixExpression.parent = ret
        if binaryOps != null {
            for item: BinaryOp in binaryOps
                item.parent = ret
        }

        return ret
    }

    function parsePathIdentifierList() -> [PathIdentifier] throws ParserError {
        mutable ret: [PathIdentifier]? = null
        while true {
            let node: PathIdentifier = parsePathIdentifier()
                catch _ break;
            if ret == null
                ret = [PathIdentifier]()
            ret.push(node)
        }
        return ret
    }

    function parsePathIdentifier() -> PathIdentifier throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startDot1: Position = lexer.getPreviousPosition()
        let successDot1: bool = lexer.parsePunctuation(dot)
        if successDot1
            lexer.advance()
        let extension: PathItem = parsePathItem() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: PathIdentifier = PathIdentifier(extension, Position(start), Position(end))
        extension.parent = ret

        return ret
    }

    function parsePathItem() -> PathItem throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startName: Position = lexer.getPreviousPosition()
        let name: String? = lexer.parseIdentifier()
        if (name != null) && (name is Identifier)
            lexer.advance()
        mutable end: Position = lexer.getPosition()
        var ret: PathItem = PathItem(name, Position(start), Position(end))

        return ret
    }

    function parseInitializer() -> Initializer throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startEqual1: Position = lexer.getPreviousPosition()
        let successEqual1: bool = lexer.parsePunctuation(equal)
        if successEqual1
            lexer.advance()
        let expression: Expression = parseExpression() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: Initializer = Initializer(expression, Position(start), Position(end))
        expression.parent = ret

        return ret
    }

    function parseBindingInitializer() -> BindingInitializer throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let initializer: PatternInitializer = parsePatternInitializer() catch _ (error)
            throw error
        let additionalInitializers: [AdditionalInitializer] = parseAdditionalInitializerList() catch _ null
        mutable end: Position = lexer.getPosition()
        var ret: BindingInitializer = BindingInitializer(initializer, additionalInitializers, Position(start), Position(end))
        initializer.parent = ret
        if additionalInitializers != null {
            for item: AdditionalInitializer in additionalInitializers
                item.parent = ret
        }

        return ret
    }

    function parsePatternInitializerList() -> [PatternInitializer] throws ParserError {
        mutable ret: [PatternInitializer]? = null
        while true {
            let node: PatternInitializer = parsePatternInitializer()
                catch _ break;
            if ret == null
                ret = [PatternInitializer]()
            ret.push(node)
        }
        return ret
    }

    function parsePatternInitializer() -> PatternInitializer throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let pattern: Pattern = parsePattern() catch _ (error)
            throw error
        let initializer: Initializer = parseInitializer() catch _ null
        mutable end: Position = lexer.getPosition()
        var ret: PatternInitializer = PatternInitializer(pattern, initializer, Position(start), Position(end))
        pattern.parent = ret
       if initializer != null
            initializer.parent = ret

        return ret
    }

    function parseAdditionalInitializerList() -> [AdditionalInitializer] throws ParserError {
        mutable ret: [AdditionalInitializer]? = null
        while true {
            let node: AdditionalInitializer = parseAdditionalInitializer()
                catch _ break;
            if ret == null
                ret = [AdditionalInitializer]()
            ret.push(node)
        }
        return ret
    }

    function parseAdditionalInitializer() -> AdditionalInitializer throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startComma1: Position = lexer.getPreviousPosition()
        let successComma1: bool = lexer.parsePunctuation(comma)
        if successComma1
            lexer.advance()
        let pattern: PatternInitializer = parsePatternInitializer() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: AdditionalInitializer = AdditionalInitializer(pattern, Position(start), Position(end))
        pattern.parent = ret

        return ret
    }

    function parseModifierList() -> [Modifier] throws ParserError {
        mutable ret: [Modifier]? = null
        while true {
            let node: Modifier = parseModifier()
                catch _ break;
            if ret == null
                ret = [Modifier]()
            ret.push(node)
        }
        return ret
    }

    function parseModifier() -> Modifier throws ParserError {
        mutable errors: [ParserError] = [ParserError]()
        mutable start: Position = lexer.getPreviousPosition()

        {
            let node: OverrideWord = parseOverrideWord() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        {
            let node: StaticWord = parseStaticWord() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        throw ParserError.UnableToParse(Position(start), errors)
    }

    function parseOverrideWord() -> OverrideWord throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startOverride1: Position = lexer.getPreviousPosition()
        let successOverride1: bool = lexer.parseKeyword(overrideKeyword)
        if successOverride1
            lexer.advance()
        mutable end: Position = lexer.getPosition()
        var ret: OverrideWord = OverrideWord(Position(start), Position(end))

        return ret
    }

    function parseStaticWord() -> StaticWord throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startStatic1: Position = lexer.getPreviousPosition()
        let successStatic1: bool = lexer.parseKeyword(staticKeyword)
        if successStatic1
            lexer.advance()
        mutable end: Position = lexer.getPosition()
        var ret: StaticWord = StaticWord(Position(start), Position(end))

        return ret
    }

    function parseFunctionName() -> FunctionName throws ParserError {
        mutable errors: [ParserError] = [ParserError]()
        mutable start: Position = lexer.getPreviousPosition()

        {
            let node: IdentifierFunction = parseIdentifierFunction() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        throw ParserError.UnableToParse(Position(start), errors)
    }

    function parseIdentifierFunction() -> IdentifierFunction throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startName: Position = lexer.getPreviousPosition()
        let name: String? = lexer.parseIdentifier()
        if (name != null) && (name is Identifier)
            lexer.advance()
        mutable end: Position = lexer.getPosition()
        var ret: IdentifierFunction = IdentifierFunction(name, Position(start), Position(end))

        return ret
    }

    function parseFunctionSignature() -> FunctionSignature throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let parameterClause: ParameterClause = parseParameterClause() catch _ (error)
            throw error
        let result: FunctionResult = parseFunctionResult() catch _ null
        let throwsClause: ThrowsClause = parseThrowsClause() catch _ null
        mutable end: Position = lexer.getPosition()
        var ret: FunctionSignature = FunctionSignature(parameterClause, result, throwsClause, Position(start), Position(end))
        parameterClause.parent = ret
       if result != null
            result.parent = ret
       if throwsClause != null
            throwsClause.parent = ret

        return ret
    }

    function parseFunctionResult() -> FunctionResult throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startEvaluatesTo1: Position = lexer.getPreviousPosition()
        let successEvaluatesTo1: bool = lexer.parsePunctuation(evaluatesTo)
        if successEvaluatesTo1
            lexer.advance()
        let existingObject: ExistingClause = parseExistingClause() catch _ null
        let resultType: Type = parseType() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: FunctionResult = FunctionResult(existingObject, resultType, Position(start), Position(end))
       if existingObject != null
            existingObject.parent = ret
        resultType.parent = ret

        return ret
    }

    function parseExistingClause() -> ExistingClause throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startExisting1: Position = lexer.getPreviousPosition()
        let successExisting1: bool = lexer.parseKeyword(existingKeyword)
        if successExisting1
            lexer.advance()
        mutable end: Position = lexer.getPosition()
        var ret: ExistingClause = ExistingClause(Position(start), Position(end))

        return ret
    }

    function parseParameterClauseList() -> [ParameterClause] throws ParserError {
        mutable ret: [ParameterClause]? = null
        while true {
            let node: ParameterClause = parseParameterClause()
                catch _ break;
            if ret == null
                ret = [ParameterClause]()
            ret.push(node)
        }
        return ret
    }

    function parseParameterClause() -> ParameterClause throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startLeftParen1: Position = lexer.getPreviousPosition()
        let successLeftParen1: bool = lexer.parsePunctuation(leftParen)
        if successLeftParen1
            lexer.advance()
        let parameters: [Parameter] = parseParameterList() catch _ null
        mutable startRightParen3: Position = lexer.getPreviousPosition()
        let successRightParen3: bool = lexer.parsePunctuation(rightParen)
        if successRightParen3
            lexer.advance()
        mutable end: Position = lexer.getPosition()
        var ret: ParameterClause = ParameterClause(parameters, Position(start), Position(end))
        if parameters != null {
            for item: Parameter in parameters
                item.parent = ret
        }

        return ret
    }

    function parseParameterList() -> [Parameter] throws ParserError {
        mutable ret: [Parameter]? = null
        while true {
            let node: Parameter = parseParameter()
                catch _ break;
            if ret == null
                ret = [Parameter]()
            ret.push(node)
        }
        return ret
    }

    function parseParameter() -> Parameter throws ParserError {
        mutable errors: [ParserError] = [ParserError]()
        mutable start: Position = lexer.getPreviousPosition()

        {
            let node: ConstParameter = parseConstParameter() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        {
            let node: VarParameter = parseVarParameter() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        throw ParserError.UnableToParse(Position(start), errors)
    }

    function parseConstParameter() -> ConstParameter throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let successLet1: bool = lexer.parseKeyword(letKeyword)
        if successLet1
            lexer.advance()
        mutable startName: Position = lexer.getPreviousPosition()
        let name: String? = lexer.parseIdentifier()
        if (name != null) && (name is Identifier)
            lexer.advance()
        mutable startColon3: Position = lexer.getPreviousPosition()
        let successColon3: bool = lexer.parsePunctuation(colon)
        if successColon3
            lexer.advance()
        let parameterType: Type = parseType() catch _ (error)
            throw error
        let successComma5: bool = lexer.parsePunctuation(comma)
        if successComma5
            lexer.advance()
        mutable end: Position = lexer.getPosition()
        var ret: ConstParameter = ConstParameter(name, parameterType, Position(start), Position(end))
        parameterType.parent = ret

        return ret
    }

    function parseVarParameter() -> VarParameter throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startMutable1: Position = lexer.getPreviousPosition()
        let successMutable1: bool = lexer.parseKeyword(mutableKeyword)
        if successMutable1
            lexer.advance()
        mutable startName: Position = lexer.getPreviousPosition()
        let name: String? = lexer.parseIdentifier()
        if (name != null) && (name is Identifier)
            lexer.advance()
        mutable startColon3: Position = lexer.getPreviousPosition()
        let successColon3: bool = lexer.parsePunctuation(colon)
        if successColon3
            lexer.advance()
        let parameterType: Type = parseType() catch _ (error)
            throw error
        let successComma5: bool = lexer.parsePunctuation(comma)
        if successComma5
            lexer.advance()
        mutable end: Position = lexer.getPosition()
        var ret: VarParameter = VarParameter(name, parameterType, Position(start), Position(end))
        parameterType.parent = ret

        return ret
    }

    function parseThrowsClause() -> ThrowsClause throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startThrows1: Position = lexer.getPreviousPosition()
        let successThrows1: bool = lexer.parseKeyword(throwsKeyword)
        if successThrows1
            lexer.advance()
        let throwsType: Type = parseType() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: ThrowsClause = ThrowsClause(throwsType, Position(start), Position(end))
        throwsType.parent = ret

        return ret
    }

    function parseEnumMemberList() -> [EnumMember] throws ParserError {
        mutable ret: [EnumMember]? = null
        while true {
            let node: EnumMember = parseEnumMember()
                catch _ break;
            if ret == null
                ret = [EnumMember]()
            ret.push(node)
        }
        return ret
    }

    function parseEnumMember() -> EnumMember throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startCase1: Position = lexer.getPreviousPosition()
        let successCase1: bool = lexer.parseKeyword(caseKeyword)
        if successCase1
            lexer.advance()
        let enumCase: EnumCase = parseEnumCase() catch _ (error)
            throw error
        let additionalCases: [AdditionalCase] = parseAdditionalCaseList() catch _ null
        let parameterClause: ParameterClause = parseParameterClause() catch _ null
        mutable end: Position = lexer.getPosition()
        var ret: EnumMember = EnumMember(enumCase, additionalCases, parameterClause, Position(start), Position(end))
        enumCase.parent = ret
        if additionalCases != null {
            for item: AdditionalCase in additionalCases
                item.parent = ret
        }
       if parameterClause != null
            parameterClause.parent = ret

        return ret
    }

    function parseEnumCase() -> EnumCase throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startName: Position = lexer.getPreviousPosition()
        let name: String? = lexer.parseIdentifier()
        if (name != null) && (name is Identifier)
            lexer.advance()
        mutable end: Position = lexer.getPosition()
        var ret: EnumCase = EnumCase(name, Position(start), Position(end))

        return ret
    }

    function parseAdditionalCaseList() -> [AdditionalCase] throws ParserError {
        mutable ret: [AdditionalCase]? = null
        while true {
            let node: AdditionalCase = parseAdditionalCase()
                catch _ break;
            if ret == null
                ret = [AdditionalCase]()
            ret.push(node)
        }
        return ret
    }

    function parseAdditionalCase() -> AdditionalCase throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startComma1: Position = lexer.getPreviousPosition()
        let successComma1: bool = lexer.parsePunctuation(comma)
        if successComma1
            lexer.advance()
        let enumCase: EnumCase = parseEnumCase() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: AdditionalCase = AdditionalCase(enumCase, Position(start), Position(end))
        enumCase.parent = ret

        return ret
    }

    function parseClassBody() -> ClassBody throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startLeftCurly1: Position = lexer.getPreviousPosition()
        let successLeftCurly1: bool = lexer.parsePunctuation(leftCurly)
        if successLeftCurly1
            lexer.advance()
        let members: [ClassMember] = parseClassMemberList() catch _ null
        mutable startRightCurly3: Position = lexer.getPreviousPosition()
        let successRightCurly3: bool = lexer.parsePunctuation(rightCurly)
        if successRightCurly3
            lexer.advance()
        mutable end: Position = lexer.getPosition()
        var ret: ClassBody = ClassBody(members, Position(start), Position(end))
        if members != null {
            for item: ClassMember in members
                item.parent = ret
        }

        return ret
    }

    function parseGenericArgumentClause() -> GenericArgumentClause throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startLeftAngular1: Position = lexer.getPreviousPosition()
        let successLeftAngular1: bool = lexer.parsePunctuation(leftAngular)
        if successLeftAngular1
            lexer.advance()
        let genericParameters: [GenericParameter] = parseGenericParameterList() catch _ (error)
            throw error
        mutable startRightAngular3: Position = lexer.getPreviousPosition()
        let successRightAngular3: bool = lexer.parsePunctuation(rightAngular)
        if successRightAngular3
            lexer.advance()
        mutable end: Position = lexer.getPosition()
        var ret: GenericArgumentClause = GenericArgumentClause(genericParameters, Position(start), Position(end))
        if genericParameters != null {
            for item: GenericParameter in genericParameters
                item.parent = ret
        }

        return ret
    }

    function parseGenericParameterList() -> [GenericParameter] throws ParserError {
        mutable ret: [GenericParameter]? = null
        while true {
            let node: GenericParameter = parseGenericParameter()
                catch _ break;
            if ret == null
                ret = [GenericParameter]()
            ret.push(node)
        }
        return ret
    }

    function parseGenericParameter() -> GenericParameter throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startTypeName: Position = lexer.getPreviousPosition()
        let typeName: String? = lexer.parseIdentifier()
        if (typeName != null) && (typeName is Identifier)
            lexer.advance()
        mutable end: Position = lexer.getPosition()
        var ret: GenericParameter = GenericParameter(typeName, Position(start), Position(end))

        return ret
    }

    function parseClassMemberList() -> [ClassMember] throws ParserError {
        mutable ret: [ClassMember]? = null
        while true {
            let node: ClassMember = parseClassMember()
                catch _ break;
            if ret == null
                ret = [ClassMember]()
            ret.push(node)
        }
        return ret
    }

    function parseClassMember() -> ClassMember throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let declaration: Declaration = parseDeclaration() catch _ (error)
            throw error
        let successSemicolon2: bool = lexer.parsePunctuation(semicolon)
        if successSemicolon2
            lexer.advance()
        mutable end: Position = lexer.getPosition()
        var ret: ClassMember = ClassMember(declaration, Position(start), Position(end))
        declaration.parent = ret

        return ret
    }

    function parsePrefixExpression() -> PrefixExpression throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let prefixOperator: String? = lexer.parsePrefixOperator()
        if prefixOperator != null
            lexer.advance()
        let expression: PostfixExpression = parsePostfixExpression() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: PrefixExpression = PrefixExpression(prefixOperator, expression, Position(start), Position(end))
        expression.parent = ret

        return ret
    }

    function parsePostfixExpression() -> PostfixExpression throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let primaryExpression: PrimaryExpression = parsePrimaryExpression() catch _ (error)
            throw error
        let postfixes: [Postfix] = parsePostfixList() catch _ null
        mutable end: Position = lexer.getPosition()
        var ret: PostfixExpression = PostfixExpression(primaryExpression, postfixes, Position(start), Position(end))
        primaryExpression.parent = ret
        if postfixes != null {
            for item: Postfix in postfixes
                item.parent = ret
        }

        return ret
    }

    function parseBinaryOpList() -> [BinaryOp] throws ParserError {
        mutable ret: [BinaryOp]? = null
        while true {
            let node: BinaryOp = parseBinaryOp()
                catch _ break;
            if ret == null
                ret = [BinaryOp]()
            ret.push(node)
        }
        return ret
    }

    function parseBinaryOp() -> BinaryOp throws ParserError {
        mutable errors: [ParserError] = [ParserError]()
        mutable start: Position = lexer.getPreviousPosition()

        {
            let node: BinaryOperation = parseBinaryOperation() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        {
            let node: Assignment = parseAssignment() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        {
            let node: TypeQuery = parseTypeQuery() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        {
            let node: TypeCast = parseTypeCast() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        throw ParserError.UnableToParse(Position(start), errors)
    }

    function parseBinaryOperation() -> BinaryOperation throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startBinaryOperator: Position = lexer.getPreviousPosition()
        let binaryOperator: String? = lexer.parseBinaryOperator()
        if binaryOperator != null
            lexer.advance()
        let expression: PrefixExpression = parsePrefixExpression() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: BinaryOperation = BinaryOperation(binaryOperator, expression, Position(start), Position(end))
        expression.parent = ret

        return ret
    }

    function parseAssignment() -> Assignment throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startEqual1: Position = lexer.getPreviousPosition()
        let successEqual1: bool = lexer.parsePunctuation(equal)
        if successEqual1
            lexer.advance()
        let expression: PrefixExpression = parsePrefixExpression() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: Assignment = Assignment(expression, Position(start), Position(end))
        expression.parent = ret

        return ret
    }

    function parseTypeQuery() -> TypeQuery throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startIs1: Position = lexer.getPreviousPosition()
        let successIs1: bool = lexer.parseKeyword(isKeyword)
        if successIs1
            lexer.advance()
        let objectType: Type = parseType() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: TypeQuery = TypeQuery(objectType, Position(start), Position(end))
        objectType.parent = ret

        return ret
    }

    function parseTypeCast() -> TypeCast throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startAs1: Position = lexer.getPreviousPosition()
        let successAs1: bool = lexer.parseKeyword(asKeyword)
        if successAs1
            lexer.advance()
        let objectType: Type = parseType() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: TypeCast = TypeCast(objectType, Position(start), Position(end))
        objectType.parent = ret

        return ret
    }

    function parseCatchClauseList() -> [CatchClause] throws ParserError {
        mutable ret: [CatchClause]? = null
        while true {
            let node: CatchClause = parseCatchClause()
                catch _ break;
            if ret == null
                ret = [CatchClause]()
            ret.push(node)
        }
        return ret
    }

    function parseCatchClause() -> CatchClause throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startCatch1: Position = lexer.getPreviousPosition()
        let successCatch1: bool = lexer.parseKeyword(catchKeyword)
        if successCatch1
            lexer.advance()
        let catchPattern: CatchPattern = parseCatchPattern() catch _ (error)
            throw error
        let bindingPattern: TuplePattern = parseTuplePattern() catch _ null
        let expression: Expression = parseExpression() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: CatchClause = CatchClause(catchPattern, bindingPattern, expression, Position(start), Position(end))
        catchPattern.parent = ret
       if bindingPattern != null
            bindingPattern.parent = ret
        expression.parent = ret

        return ret
    }

    function parseCatchPattern() -> CatchPattern throws ParserError {
        mutable errors: [ParserError] = [ParserError]()
        mutable start: Position = lexer.getPreviousPosition()

        {
            let node: WildCardCatchPattern = parseWildCardCatchPattern() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        {
            let node: IdentifierCatchPattern = parseIdentifierCatchPattern() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        throw ParserError.UnableToParse(Position(start), errors)
    }

    function parseWildCardCatchPattern() -> WildCardCatchPattern throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let pattern: WildcardPattern = parseWildcardPattern() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: WildCardCatchPattern = WildCardCatchPattern(pattern, Position(start), Position(end))
        pattern.parent = ret

        return ret
    }

    function parseIdentifierCatchPattern() -> IdentifierCatchPattern throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startName: Position = lexer.getPreviousPosition()
        let name: String? = lexer.parseIdentifier()
        if (name != null) && (name is Identifier)
            lexer.advance()
        mutable end: Position = lexer.getPosition()
        var ret: IdentifierCatchPattern = IdentifierCatchPattern(name, Position(start), Position(end))

        return ret
    }

    function parsePostfixList() -> [Postfix] throws ParserError {
        mutable ret: [Postfix]? = null
        while true {
            let node: Postfix = parsePostfix()
                catch _ break;
            if ret == null
                ret = [Postfix]()
            ret.push(node)
        }
        return ret
    }

    function parsePostfix() -> Postfix throws ParserError {
        mutable errors: [ParserError] = [ParserError]()
        mutable start: Position = lexer.getPreviousPosition()

        {
            let node: OperatorPostfix = parseOperatorPostfix() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        {
            let node: FunctionCall = parseFunctionCall() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        {
            let node: ExplicitMemberExpression = parseExplicitMemberExpression() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        {
            let node: Subscript = parseSubscript() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        throw ParserError.UnableToParse(Position(start), errors)
    }

    function parseOperatorPostfix() -> OperatorPostfix throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startPostfixOperator: Position = lexer.getPreviousPosition()
        let postfixOperator: String? = lexer.parsePostfixOperator()
        if postfixOperator != null
            lexer.advance()
        mutable end: Position = lexer.getPosition()
        var ret: OperatorPostfix = OperatorPostfix(postfixOperator, Position(start), Position(end))

        return ret
    }

    function parseFunctionCall() -> FunctionCall throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let arguments: ParenthesizedExpression = parseParenthesizedExpression() catch _ (error)
            throw error
        let catchClauses: [CatchClause] = parseCatchClauseList() catch _ null
        mutable end: Position = lexer.getPosition()
        var ret: FunctionCall = FunctionCall(arguments, catchClauses, Position(start), Position(end))
        arguments.parent = ret
        if catchClauses != null {
            for item: CatchClause in catchClauses
                item.parent = ret
        }

        return ret
    }

    function parseExplicitMemberExpression() -> ExplicitMemberExpression throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startDot1: Position = lexer.getPreviousPosition()
        let successDot1: bool = lexer.parsePunctuation(dot)
        if successDot1
            lexer.advance()
        let memberPostfix: MemberPostfix = parseMemberPostfix() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: ExplicitMemberExpression = ExplicitMemberExpression(memberPostfix, Position(start), Position(end))
        memberPostfix.parent = ret

        return ret
    }

    function parseSubscript() -> Subscript throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startLeftBracket1: Position = lexer.getPreviousPosition()
        let successLeftBracket1: bool = lexer.parsePunctuation(leftBracket)
        if successLeftBracket1
            lexer.advance()
        let expressions: [ExpressionElement] = parseExpressionElementList() catch _ (error)
            throw error
        mutable startRightBracket3: Position = lexer.getPreviousPosition()
        let successRightBracket3: bool = lexer.parsePunctuation(rightBracket)
        if successRightBracket3
            lexer.advance()
        mutable end: Position = lexer.getPosition()
        var ret: Subscript = Subscript(expressions, Position(start), Position(end))
        if expressions != null {
            for item: ExpressionElement in expressions
                item.parent = ret
        }

        return ret
    }

    function parseExpressionElementList() -> [ExpressionElement] throws ParserError {
        mutable ret: [ExpressionElement]? = null
        while true {
            let node: ExpressionElement = parseExpressionElement()
                catch _ break;
            if ret == null
                ret = [ExpressionElement]()
            ret.push(node)
        }
        return ret
    }

    function parseExpressionElement() -> ExpressionElement throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let expression: Expression = parseExpression() catch _ (error)
            throw error
        let successComma2: bool = lexer.parsePunctuation(comma)
        if successComma2
            lexer.advance()
        mutable end: Position = lexer.getPosition()
        var ret: ExpressionElement = ExpressionElement(expression, Position(start), Position(end))
        expression.parent = ret

        return ret
    }

    function parseMemberPostfix() -> MemberPostfix throws ParserError {
        mutable errors: [ParserError] = [ParserError]()
        mutable start: Position = lexer.getPreviousPosition()

        {
            let node: NamedMemberPostfix = parseNamedMemberPostfix() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        throw ParserError.UnableToParse(Position(start), errors)
    }

    function parseNamedMemberPostfix() -> NamedMemberPostfix throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let identifier: IdentifierExpression = parseIdentifierExpression() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: NamedMemberPostfix = NamedMemberPostfix(identifier, Position(start), Position(end))
        identifier.parent = ret

        return ret
    }

    function parsePrimaryExpression() -> PrimaryExpression throws ParserError {
        mutable errors: [ParserError] = [ParserError]()
        mutable start: Position = lexer.getPreviousPosition()

        {
            let node: IdentifierExpression = parseIdentifierExpression() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        {
            let node: LiteralExpression = parseLiteralExpression() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        {
            let node: IfExpression = parseIfExpression() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        {
            let node: SwitchExpression = parseSwitchExpression() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        {
            let node: ForExpression = parseForExpression() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        {
            let node: WhileExpression = parseWhileExpression() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        {
            let node: RepeatExpression = parseRepeatExpression() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        {
            let node: ParenthesizedExpression = parseParenthesizedExpression() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        {
            let node: ReturnExpression = parseReturnExpression() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        {
            let node: ThrowExpression = parseThrowExpression() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        {
            let node: BreakExpression = parseBreakExpression() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        {
            let node: InitializerCall = parseInitializerCall() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        {
            let node: ThisExpression = parseThisExpression() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        {
            let node: SuperExpression = parseSuperExpression() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        {
            let node: NullExpression = parseNullExpression() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        throw ParserError.UnableToParse(Position(start), errors)
    }

    function parseIdentifierExpression() -> IdentifierExpression throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startName: Position = lexer.getPreviousPosition()
        let name: String? = lexer.parseIdentifier()
        if (name != null) && (name is Identifier)
            lexer.advance()
        mutable end: Position = lexer.getPosition()
        var ret: IdentifierExpression = IdentifierExpression(name, Position(start), Position(end))

        return ret
    }

    function parseLiteralExpression() -> LiteralExpression throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startLiteral: Position = lexer.getPreviousPosition()
        let literal: Literal? = lexer.parseLiteral()
        if literal != null
            lexer.advance()
        mutable end: Position = lexer.getPosition()
        var ret: LiteralExpression = LiteralExpression(literal, Position(start), Position(end))

        return ret
    }

    function parseIfExpression() -> IfExpression throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startIf1: Position = lexer.getPreviousPosition()
        let successIf1: bool = lexer.parseKeyword(ifKeyword)
        if successIf1
            lexer.advance()
        let condition: Expression = parseExpression() catch _ (error)
            throw error
        let consequent: Expression = parseExpression() catch _ (error)
            throw error
        let elseClause: ElseClause = parseElseClause() catch _ null
        mutable end: Position = lexer.getPosition()
        var ret: IfExpression = IfExpression(condition, consequent, elseClause, Position(start), Position(end))
        condition.parent = ret
        consequent.parent = ret
       if elseClause != null
            elseClause.parent = ret

        return ret
    }

    function parseSwitchExpression() -> SwitchExpression throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startSwitch1: Position = lexer.getPreviousPosition()
        let successSwitch1: bool = lexer.parseKeyword(switchKeyword)
        if successSwitch1
            lexer.advance()
        let expression: Expression = parseExpression() catch _ (error)
            throw error
        let body: SwitchBody = parseSwitchBody() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: SwitchExpression = SwitchExpression(expression, body, Position(start), Position(end))
        expression.parent = ret
        body.parent = ret

        return ret
    }

    function parseForExpression() -> ForExpression throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startFor1: Position = lexer.getPreviousPosition()
        let successFor1: bool = lexer.parseKeyword(forKeyword)
        if successFor1
            lexer.advance()
        let pattern: Pattern = parsePattern() catch _ (error)
            throw error
        mutable startIn3: Position = lexer.getPreviousPosition()
        let successIn3: bool = lexer.parseKeyword(inKeyword)
        if successIn3
            lexer.advance()
        let expression: Expression = parseExpression() catch _ (error)
            throw error
        let code: Expression = parseExpression() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: ForExpression = ForExpression(pattern, expression, code, Position(start), Position(end))
        pattern.parent = ret
        expression.parent = ret
        code.parent = ret

        return ret
    }

    function parseWhileExpression() -> WhileExpression throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startWhile1: Position = lexer.getPreviousPosition()
        let successWhile1: bool = lexer.parseKeyword(whileKeyword)
        if successWhile1
            lexer.advance()
        let condition: Expression = parseExpression() catch _ (error)
            throw error
        let code: Expression = parseExpression() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: WhileExpression = WhileExpression(condition, code, Position(start), Position(end))
        condition.parent = ret
        code.parent = ret

        return ret
    }

    function parseRepeatExpression() -> RepeatExpression throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startRepeat1: Position = lexer.getPreviousPosition()
        let successRepeat1: bool = lexer.parseKeyword(repeatKeyword)
        if successRepeat1
            lexer.advance()
        let code: Expression = parseExpression() catch _ (error)
            throw error
        mutable startWhile3: Position = lexer.getPreviousPosition()
        let successWhile3: bool = lexer.parseKeyword(whileKeyword)
        if successWhile3
            lexer.advance()
        let condition: Expression = parseExpression() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: RepeatExpression = RepeatExpression(code, condition, Position(start), Position(end))
        code.parent = ret
        condition.parent = ret

        return ret
    }

    function parseParenthesizedExpression() -> ParenthesizedExpression throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startLeftParen1: Position = lexer.getPreviousPosition()
        let successLeftParen1: bool = lexer.parsePunctuation(leftParen)
        if successLeftParen1
            lexer.advance()
        let expressionElements: [ExpressionElement] = parseExpressionElementList() catch _ null
        mutable startRightParen3: Position = lexer.getPreviousPosition()
        let successRightParen3: bool = lexer.parsePunctuation(rightParen)
        if successRightParen3
            lexer.advance()
        mutable end: Position = lexer.getPosition()
        var ret: ParenthesizedExpression = ParenthesizedExpression(expressionElements, Position(start), Position(end))
        if expressionElements != null {
            for item: ExpressionElement in expressionElements
                item.parent = ret
        }

        return ret
    }

    function parseReturnExpression() -> ReturnExpression throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startReturn1: Position = lexer.getPreviousPosition()
        let successReturn1: bool = lexer.parseKeyword(returnKeyword)
        if successReturn1
            lexer.advance()
        let expression: Expression = parseExpression() catch _ null
        mutable end: Position = lexer.getPosition()
        var ret: ReturnExpression = ReturnExpression(expression, Position(start), Position(end))
       if expression != null
            expression.parent = ret

        return ret
    }

    function parseThrowExpression() -> ThrowExpression throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startThrow1: Position = lexer.getPreviousPosition()
        let successThrow1: bool = lexer.parseKeyword(throwKeyword)
        if successThrow1
            lexer.advance()
        let expression: Expression = parseExpression() catch _ null
        mutable end: Position = lexer.getPosition()
        var ret: ThrowExpression = ThrowExpression(expression, Position(start), Position(end))
       if expression != null
            expression.parent = ret

        return ret
    }

    function parseBreakExpression() -> BreakExpression throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startBreak1: Position = lexer.getPreviousPosition()
        let successBreak1: bool = lexer.parseKeyword(breakKeyword)
        if successBreak1
            lexer.advance()
        let expression: Expression = parseExpression() catch _ null
        mutable end: Position = lexer.getPosition()
        var ret: BreakExpression = BreakExpression(expression, Position(start), Position(end))
       if expression != null
            expression.parent = ret

        return ret
    }

    function parseInitializerCall() -> InitializerCall throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let typeToInitialize: Type = parseType() catch _ (error)
            throw error
        let arguments: ParenthesizedExpression = parseParenthesizedExpression() catch _ (error)
            throw error
        let catchClauses: [CatchClause] = parseCatchClauseList() catch _ null
        mutable end: Position = lexer.getPosition()
        var ret: InitializerCall = InitializerCall(typeToInitialize, arguments, catchClauses, Position(start), Position(end))
        typeToInitialize.parent = ret
        arguments.parent = ret
        if catchClauses != null {
            for item: CatchClause in catchClauses
                item.parent = ret
        }

        return ret
    }

    function parseThisExpression() -> ThisExpression throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startThis1: Position = lexer.getPreviousPosition()
        let successThis1: bool = lexer.parseKeyword(thisKeyword)
        if successThis1
            lexer.advance()
        mutable end: Position = lexer.getPosition()
        var ret: ThisExpression = ThisExpression(Position(start), Position(end))

        return ret
    }

    function parseSuperExpression() -> SuperExpression throws ParserError {
        mutable errors: [ParserError] = [ParserError]()
        mutable start: Position = lexer.getPreviousPosition()

        {
            let node: SuperDot = parseSuperDot() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        {
            let node: SuperSubscript = parseSuperSubscript() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        throw ParserError.UnableToParse(Position(start), errors)
    }

    function parseSuperDot() -> SuperDot throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startSuper1: Position = lexer.getPreviousPosition()
        let successSuper1: bool = lexer.parseKeyword(superKeyword)
        if successSuper1
            lexer.advance()
        mutable startDot2: Position = lexer.getPreviousPosition()
        let successDot2: bool = lexer.parsePunctuation(dot)
        if successDot2
            lexer.advance()
        let member: CommonSuperMember = parseCommonSuperMember() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: SuperDot = SuperDot(member, Position(start), Position(end))
        member.parent = ret

        return ret
    }

    function parseSuperSubscript() -> SuperSubscript throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startSuper1: Position = lexer.getPreviousPosition()
        let successSuper1: bool = lexer.parseKeyword(superKeyword)
        if successSuper1
            lexer.advance()
        let subscript: Subscript = parseSubscript() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: SuperSubscript = SuperSubscript(subscript, Position(start), Position(end))
        subscript.parent = ret

        return ret
    }

    function parseNullExpression() -> NullExpression throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startNull1: Position = lexer.getPreviousPosition()
        let successNull1: bool = lexer.parseKeyword(nullKeyword)
        if successNull1
            lexer.advance()
        mutable end: Position = lexer.getPosition()
        var ret: NullExpression = NullExpression(Position(start), Position(end))

        return ret
    }

    function parseElseClause() -> ElseClause throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startElse1: Position = lexer.getPreviousPosition()
        let successElse1: bool = lexer.parseKeyword(elseKeyword)
        if successElse1
            lexer.advance()
        let alternative: Expression = parseExpression() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: ElseClause = ElseClause(alternative, Position(start), Position(end))
        alternative.parent = ret

        return ret
    }

    function parseSwitchBody() -> SwitchBody throws ParserError {
        mutable errors: [ParserError] = [ParserError]()
        mutable start: Position = lexer.getPreviousPosition()

        {
            let node: CurliedSwitchBody = parseCurliedSwitchBody() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        {
            let node: NakedSwitchBody = parseNakedSwitchBody() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        throw ParserError.UnableToParse(Position(start), errors)
    }

    function parseCurliedSwitchBody() -> CurliedSwitchBody throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startLeftCurly1: Position = lexer.getPreviousPosition()
        let successLeftCurly1: bool = lexer.parsePunctuation(leftCurly)
        if successLeftCurly1
            lexer.advance()
        let cases: [SwitchCase] = parseSwitchCaseList() catch _ (error)
            throw error
        mutable startRightCurly3: Position = lexer.getPreviousPosition()
        let successRightCurly3: bool = lexer.parsePunctuation(rightCurly)
        if successRightCurly3
            lexer.advance()
        mutable end: Position = lexer.getPosition()
        var ret: CurliedSwitchBody = CurliedSwitchBody(cases, Position(start), Position(end))
        if cases != null {
            for item: SwitchCase in cases
                item.parent = ret
        }

        return ret
    }

    function parseNakedSwitchBody() -> NakedSwitchBody throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let cases: [SwitchCase] = parseSwitchCaseList() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: NakedSwitchBody = NakedSwitchBody(cases, Position(start), Position(end))
        if cases != null {
            for item: SwitchCase in cases
                item.parent = ret
        }

        return ret
    }

    function parseSwitchCaseList() -> [SwitchCase] throws ParserError {
        mutable ret: [SwitchCase]? = null
        while true {
            let node: SwitchCase = parseSwitchCase()
                catch _ break;
            if ret == null
                ret = [SwitchCase]()
            ret.push(node)
        }
        return ret
    }

    function parseSwitchCase() -> SwitchCase throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let label: CaseLabel = parseCaseLabel() catch _ (error)
            throw error
        let content: CaseContent = parseCaseContent() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: SwitchCase = SwitchCase(label, content, Position(start), Position(end))
        label.parent = ret
        content.parent = ret

        return ret
    }

    function parseCaseLabel() -> CaseLabel throws ParserError {
        mutable errors: [ParserError] = [ParserError]()
        mutable start: Position = lexer.getPreviousPosition()

        {
            let node: ItemCaseLabel = parseItemCaseLabel() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        {
            let node: DefaultCaseLabel = parseDefaultCaseLabel() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        throw ParserError.UnableToParse(Position(start), errors)
    }

    function parseItemCaseLabel() -> ItemCaseLabel throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startCase1: Position = lexer.getPreviousPosition()
        let successCase1: bool = lexer.parseKeyword(caseKeyword)
        if successCase1
            lexer.advance()
        let pattern: Pattern = parsePattern() catch _ (error)
            throw error
        let additionalPatterns: [CaseItem] = parseCaseItemList() catch _ null
        mutable startColon4: Position = lexer.getPreviousPosition()
        let successColon4: bool = lexer.parsePunctuation(colon)
        if successColon4
            lexer.advance()
        mutable end: Position = lexer.getPosition()
        var ret: ItemCaseLabel = ItemCaseLabel(pattern, additionalPatterns, Position(start), Position(end))
        pattern.parent = ret
        if additionalPatterns != null {
            for item: CaseItem in additionalPatterns
                item.parent = ret
        }

        return ret
    }

    function parseDefaultCaseLabel() -> DefaultCaseLabel throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startDefault1: Position = lexer.getPreviousPosition()
        let successDefault1: bool = lexer.parseKeyword(defaultKeyword)
        if successDefault1
            lexer.advance()
        mutable startColon2: Position = lexer.getPreviousPosition()
        let successColon2: bool = lexer.parsePunctuation(colon)
        if successColon2
            lexer.advance()
        mutable end: Position = lexer.getPosition()
        var ret: DefaultCaseLabel = DefaultCaseLabel(Position(start), Position(end))

        return ret
    }

    function parseCaseItemList() -> [CaseItem] throws ParserError {
        mutable ret: [CaseItem]? = null
        while true {
            let node: CaseItem = parseCaseItem()
                catch _ break;
            if ret == null
                ret = [CaseItem]()
            ret.push(node)
        }
        return ret
    }

    function parseCaseItem() -> CaseItem throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startComma1: Position = lexer.getPreviousPosition()
        let successComma1: bool = lexer.parsePunctuation(comma)
        if successComma1
            lexer.advance()
        let pattern: Pattern = parsePattern() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: CaseItem = CaseItem(pattern, Position(start), Position(end))
        pattern.parent = ret

        return ret
    }

    function parsePattern() -> Pattern throws ParserError {
        mutable errors: [ParserError] = [ParserError]()
        mutable start: Position = lexer.getPreviousPosition()

        {
            let node: WildcardPattern = parseWildcardPattern() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        {
            let node: IdentifierPattern = parseIdentifierPattern() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        {
            let node: TuplePattern = parseTuplePattern() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        {
            let node: ExpressionPattern = parseExpressionPattern() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        throw ParserError.UnableToParse(Position(start), errors)
    }

    function parseWildcardPattern() -> WildcardPattern throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startUnderscore1: Position = lexer.getPreviousPosition()
        let successUnderscore1: bool = lexer.parsePunctuation(underscore)
        if successUnderscore1
            lexer.advance()
        mutable end: Position = lexer.getPosition()
        var ret: WildcardPattern = WildcardPattern(Position(start), Position(end))

        return ret
    }

    function parseIdentifierPattern() -> IdentifierPattern throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startIdentifier: Position = lexer.getPreviousPosition()
        let identifier: String? = lexer.parseIdentifier()
        if (identifier != null) && (identifier is Identifier)
            lexer.advance()
        let annotationForType: TypeAnnotation = parseTypeAnnotation() catch _ null
        mutable end: Position = lexer.getPosition()
        var ret: IdentifierPattern = IdentifierPattern(identifier, annotationForType, Position(start), Position(end))
       if annotationForType != null
            annotationForType.parent = ret

        return ret
    }

    function parseTuplePattern() -> TuplePattern throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startLeftParen1: Position = lexer.getPreviousPosition()
        let successLeftParen1: bool = lexer.parsePunctuation(leftParen)
        if successLeftParen1
            lexer.advance()
        let elements: [TuplePatternElement] = parseTuplePatternElementList() catch _ (error)
            throw error
        mutable startRightParen3: Position = lexer.getPreviousPosition()
        let successRightParen3: bool = lexer.parsePunctuation(rightParen)
        if successRightParen3
            lexer.advance()
        mutable end: Position = lexer.getPosition()
        var ret: TuplePattern = TuplePattern(elements, Position(start), Position(end))
        if elements != null {
            for item: TuplePatternElement in elements
                item.parent = ret
        }

        return ret
    }

    function parseExpressionPattern() -> ExpressionPattern throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let expression: Expression = parseExpression() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: ExpressionPattern = ExpressionPattern(expression, Position(start), Position(end))
        expression.parent = ret

        return ret
    }

    function parseTuplePatternElementList() -> [TuplePatternElement] throws ParserError {
        mutable ret: [TuplePatternElement]? = null
        while true {
            let node: TuplePatternElement = parseTuplePatternElement()
                catch _ break;
            if ret == null
                ret = [TuplePatternElement]()
            ret.push(node)
        }
        return ret
    }

    function parseTuplePatternElement() -> TuplePatternElement throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let pattern: Pattern = parsePattern() catch _ (error)
            throw error
        let successComma2: bool = lexer.parsePunctuation(comma)
        if successComma2
            lexer.advance()
        mutable end: Position = lexer.getPosition()
        var ret: TuplePatternElement = TuplePatternElement(pattern, Position(start), Position(end))
        pattern.parent = ret

        return ret
    }

    function parseCaseContent() -> CaseContent throws ParserError {
        mutable errors: [ParserError] = [ParserError]()
        mutable start: Position = lexer.getPreviousPosition()

        {
            let node: BlockCaseContent = parseBlockCaseContent() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        {
            let node: EmptyCaseContent = parseEmptyCaseContent() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        throw ParserError.UnableToParse(Position(start), errors)
    }

    function parseBlockCaseContent() -> BlockCaseContent throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let statements: [TerminatedStatement] = parseTerminatedStatementList() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: BlockCaseContent = BlockCaseContent(statements, Position(start), Position(end))
        if statements != null {
            for item: TerminatedStatement in statements
                item.parent = ret
        }

        return ret
    }

    function parseEmptyCaseContent() -> EmptyCaseContent throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startSemicolon1: Position = lexer.getPreviousPosition()
        let successSemicolon1: bool = lexer.parsePunctuation(semicolon)
        if successSemicolon1
            lexer.advance()
        mutable end: Position = lexer.getPosition()
        var ret: EmptyCaseContent = EmptyCaseContent(Position(start), Position(end))

        return ret
    }

    function parseCommonSuperMember() -> CommonSuperMember throws ParserError {
        mutable errors: [ParserError] = [ParserError]()
        mutable start: Position = lexer.getPreviousPosition()

        {
            let node: SuperInit = parseSuperInit() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        {
            let node: SuperMember = parseSuperMember() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        throw ParserError.UnableToParse(Position(start), errors)
    }

    function parseSuperInit() -> SuperInit throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startInit1: Position = lexer.getPreviousPosition()
        let successInit1: bool = lexer.parseKeyword(initKeyword)
        if successInit1
            lexer.advance()
        mutable end: Position = lexer.getPosition()
        var ret: SuperInit = SuperInit(Position(start), Position(end))

        return ret
    }

    function parseSuperMember() -> SuperMember throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startName: Position = lexer.getPreviousPosition()
        let name: String? = lexer.parseIdentifier()
        if (name != null) && (name is Identifier)
            lexer.advance()
        mutable end: Position = lexer.getPosition()
        var ret: SuperMember = SuperMember(name, Position(start), Position(end))

        return ret
    }

    function parseType() -> Type throws ParserError {
        mutable errors: [ParserError] = [ParserError]()
        mutable start: Position = lexer.getPreviousPosition()

        {
            let node: ArrayType = parseArrayType() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        {
            let node: TypeIdentifier = parseTypeIdentifier() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        throw ParserError.UnableToParse(Position(start), errors)
    }

    function parseTypeIdentifier() -> TypeIdentifier throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startName: Position = lexer.getPreviousPosition()
        let name: String? = lexer.parseIdentifier()
        if (name != null) && (name is Identifier)
            lexer.advance()
        let subType: SubtypeIdentifier = parseSubtypeIdentifier() catch _ null
        let postfixes: [TypePostfix] = parseTypePostfixList() catch _ null
        mutable end: Position = lexer.getPosition()
        var ret: TypeIdentifier = TypeIdentifier(name, subType, postfixes, Position(start), Position(end))
       if subType != null
            subType.parent = ret
        if postfixes != null {
            for item: TypePostfix in postfixes
                item.parent = ret
        }

        return ret
    }

    function parseArrayType() -> ArrayType throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startLeftBracket1: Position = lexer.getPreviousPosition()
        let successLeftBracket1: bool = lexer.parsePunctuation(leftBracket)
        if successLeftBracket1
            lexer.advance()
        let elementType: Type = parseType() catch _ (error)
            throw error
        mutable startRightBracket3: Position = lexer.getPreviousPosition()
        let successRightBracket3: bool = lexer.parsePunctuation(rightBracket)
        if successRightBracket3
            lexer.advance()
        let postfixes: [TypePostfix] = parseTypePostfixList() catch _ null
        mutable end: Position = lexer.getPosition()
        var ret: ArrayType = ArrayType(elementType, postfixes, Position(start), Position(end))
        elementType.parent = ret
        if postfixes != null {
            for item: TypePostfix in postfixes
                item.parent = ret
        }

        return ret
    }

    function parseTypeAnnotation() -> TypeAnnotation throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startColon1: Position = lexer.getPreviousPosition()
        let successColon1: bool = lexer.parsePunctuation(colon)
        if successColon1
            lexer.advance()
        let annotationForType: Type = parseType() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: TypeAnnotation = TypeAnnotation(annotationForType, Position(start), Position(end))
        annotationForType.parent = ret

        return ret
    }

    function parseSubtypeIdentifier() -> SubtypeIdentifier throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startDot1: Position = lexer.getPreviousPosition()
        let successDot1: bool = lexer.parsePunctuation(dot)
        if successDot1
            lexer.advance()
        let typeIdentifier: TypeIdentifier = parseTypeIdentifier() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: SubtypeIdentifier = SubtypeIdentifier(typeIdentifier, Position(start), Position(end))
        typeIdentifier.parent = ret

        return ret
    }

    function parseTypePostfixList() -> [TypePostfix] throws ParserError {
        mutable ret: [TypePostfix]? = null
        while true {
            let node: TypePostfix = parseTypePostfix()
                catch _ break;
            if ret == null
                ret = [TypePostfix]()
            ret.push(node)
        }
        return ret
    }

    function parseTypePostfix() -> TypePostfix throws ParserError {
        mutable errors: [ParserError] = [ParserError]()
        mutable start: Position = lexer.getPreviousPosition()

        {
            let node: OptionalType = parseOptionalType() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return node
        }

        throw ParserError.UnableToParse(Position(start), errors)
    }

    function parseOptionalType() -> OptionalType throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startQuestionMark1: Position = lexer.getPreviousPosition()
        let successQuestionMark1: bool = lexer.parsePunctuation(questionMark)
        if successQuestionMark1
            lexer.advance()
        mutable end: Position = lexer.getPosition()
        var ret: OptionalType = OptionalType(Position(start), Position(end))

        return ret
    }

    function parseTypeInheritanceClause() -> TypeInheritanceClause throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startColon1: Position = lexer.getPreviousPosition()
        let successColon1: bool = lexer.parsePunctuation(colon)
        if successColon1
            lexer.advance()
        let inheritances: [Inheritance] = parseInheritanceList() catch _ null
        mutable end: Position = lexer.getPosition()
        var ret: TypeInheritanceClause = TypeInheritanceClause(inheritances, Position(start), Position(end))
        if inheritances != null {
            for item: Inheritance in inheritances
                item.parent = ret
        }

        return ret
    }

    function parseInheritanceList() -> [Inheritance] throws ParserError {
        mutable ret: [Inheritance]? = null
        while true {
            let node: Inheritance = parseInheritance()
                catch _ break;
            if ret == null
                ret = [Inheritance]()
            ret.push(node)
        }
        return ret
    }

    function parseInheritance() -> Inheritance throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let typeIdentifier: TypeIdentifier = parseTypeIdentifier() catch _ (error)
            throw error
        let successComma2: bool = lexer.parsePunctuation(comma)
        if successComma2
            lexer.advance()
        mutable end: Position = lexer.getPosition()
        var ret: Inheritance = Inheritance(typeIdentifier, Position(start), Position(end))
        typeIdentifier.parent = ret

        return ret
    }

    function isAtEnd() -> bool {
        lexer.isAtEnd()
    }

    function isIdentifier(id: String) -> bool {
        if id.equals(useKeyword)
            return false

        if id.equals(classKeyword)
            return false

        if id.equals(functionKeyword)
            return false

        if id.equals(ifKeyword)
            return false

        if id.equals(elseKeyword)
            return false

        if id.equals(switchKeyword)
            return false

        if id.equals(caseKeyword)
            return false

        if id.equals(defaultKeyword)
            return false

        if id.equals(catchKeyword)
            return false

        if id.equals(forKeyword)
            return false

        if id.equals(inKeyword)
            return false

        if id.equals(whileKeyword)
            return false

        if id.equals(repeatKeyword)
            return false

        if id.equals(returnKeyword)
            return false

        if id.equals(throwKeyword)
            return false

        if id.equals(breakKeyword)
            return false

        if id.equals(throwsKeyword)
            return false

        if id.equals(existingKeyword)
            return false

        if id.equals(overrideKeyword)
            return false

        if id.equals(staticKeyword)
            return false

        if id.equals(letKeyword)
            return false

        if id.equals(varKeyword)
            return false

        if id.equals(mutableKeyword)
            return false

        if id.equals(isKeyword)
            return false

        if id.equals(asKeyword)
            return false

        if id.equals(initKeyword)
            return false

        if id.equals(enumKeyword)
            return false

        if id.equals(superKeyword)
            return false

        if id.equals(thisKeyword)
            return false

        if id.equals(nullKeyword)
            return false

        true
    }

    mutable lexer: Lexer
    let fileName: String

    let useKeyword: String = "use"
    let classKeyword: String = "class"
    let functionKeyword: String = "function"
    let ifKeyword: String = "if"
    let elseKeyword: String = "else"
    let switchKeyword: String = "switch"
    let caseKeyword: String = "case"
    let defaultKeyword: String = "default"
    let catchKeyword: String = "catch"
    let forKeyword: String = "for"
    let inKeyword: String = "in"
    let whileKeyword: String = "while"
    let repeatKeyword: String = "repeat"
    let returnKeyword: String = "return"
    let throwKeyword: String = "throw"
    let breakKeyword: String = "break"
    let throwsKeyword: String = "throws"
    let existingKeyword: String = "existing"
    let overrideKeyword: String = "override"
    let staticKeyword: String = "static"
    let letKeyword: String = "let"
    let varKeyword: String = "var"
    let mutableKeyword: String = "mutable"
    let isKeyword: String = "is"
    let asKeyword: String = "as"
    let initKeyword: String = "init"
    let enumKeyword: String = "enum"
    let superKeyword: String = "super"
    let thisKeyword: String = "this"
    let nullKeyword: String = "null"
    let semicolon: String = ";"
    let equal: String = "="
    let leftAngular: String = "<"
    let rightAngular: String = ">"
    let comma: String = ","
    let leftParen: String = "("
    let rightParen: String = ")"
    let leftCurly: String = "{"
    let rightCurly: String = "}"
    let leftBracket: String = "["
    let rightBracket: String = "]"
    let colon: String = ":"
    let dot: String = "."
    let questionMark: String = "?"
    let underscore: String = "_"
    let evaluatesTo: String = "->"
}
