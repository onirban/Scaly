class Parser {
    constructor(theFileName: string, text: string) {
        lexer = new Lexer(text)
        fileName = theFileName
        useKeyword = new string("use")
        classKeyword = new string("class")
        functionKeyword = new string("function")
        ifKeyword = new string("if")
        elseKeyword = new string("else")
        switchKeyword = new string("switch")
        caseKeyword = new string("case")
        defaultKeyword = new string("default")
        catchKeyword = new string("catch")
        forKeyword = new string("for")
        inKeyword = new string("in")
        whileKeyword = new string("while")
        repeatKeyword = new string("repeat")
        returnKeyword = new string("return")
        throwKeyword = new string("throw")
        breakKeyword = new string("break")
        throwsKeyword = new string("throws")
        existingKeyword = new string("existing")
        overrideKeyword = new string("override")
        staticKeyword = new string("static")
        letKeyword = new string("let")
        varKeyword = new string("var")
        mutableKeyword = new string("mutable")
        isKeyword = new string("is")
        asKeyword = new string("as")
        constructorKeyword = new string("constructor")
        enumKeyword = new string("enum")
        superKeyword = new string("super")
        thisKeyword = new string("this")
        nullKeyword = new string("null")
        newKeyword = new string("new")
        extendsKeyword = new string("extends")
        equal = new string("=")
        leftAngular = new string("<")
        rightAngular = new string(">")
        comma = new string(",")
        leftParen = new string("(")
        rightParen = new string(")")
        leftCurly = new string("{")
        rightCurly = new string("}")
        leftBracket = new string("[")
        rightBracket = new string("]")
        colon = new string(":")
        dot = new string(".")
        questionMark = new string("?")
        underscore = new string("_")
    }

    function parseCompilationUnit(): CompilationUnit throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let statements: Statement[] = parseStatementList() catch _ null
        if statements != null {
            if !isAtEnd() {
                mutable current: Position = lexer.getPosition()
                throw notAtEnd(new Position(current))
            }
        }
        mutable end: Position = lexer.getPosition()
        var ret: CompilationUnit = new CompilationUnit(statements, new Position(start), new Position(end))
        ret.fileName = fileName
        if statements != null {
            for item: Statement in statements
                item.parent = ret
        }

        return(ret)
    }

    function parseStatementList(): Statement[] throws ParserError {
        mutable ret: Statement[]? = null
        while true {
            let node: Statement = parseStatement()
                catch _ break
            if ret == null
                ret = new Statement[]()
            ret.push(node)
        }
        return(ret)
    }

    function parseStatement(): Statement throws ParserError {
        mutable errors: ParserError[] = new ParserError[]()
        mutable start: Position = lexer.getPreviousPosition()

        {
            let node: Declaration = parseDeclaration() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: Expression = parseExpression() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        throw unableToParse(new Position(start), new ParserError[](errors))
    }

    function parseDeclaration(): Declaration throws ParserError {
        mutable errors: ParserError[] = new ParserError[]()
        mutable start: Position = lexer.getPreviousPosition()

        {
            let node: UseDeclaration = parseUseDeclaration() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: ConstantDeclaration = parseConstantDeclaration() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: VariableDeclaration = parseVariableDeclaration() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: MutableDeclaration = parseMutableDeclaration() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: FunctionDeclaration = parseFunctionDeclaration() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: EnumDeclaration = parseEnumDeclaration() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: ClassDeclaration = parseClassDeclaration() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: ConstructorDeclaration = parseConstructorDeclaration() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        throw unableToParse(new Position(start), new ParserError[](errors))
    }

    function parseExpression(): Expression throws ParserError {
        mutable errors: ParserError[] = new ParserError[]()
        mutable start: Position = lexer.getPreviousPosition()

        {
            let node: CodeBlock = parseCodeBlock() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: SimpleExpression = parseSimpleExpression() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        throw unableToParse(new Position(start), new ParserError[](errors))
    }

    function parseUseDeclaration(): UseDeclaration throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startUse1: Position = lexer.getPreviousPosition()
        let successUse1: bool = lexer.parseKeyword(useKeyword)
        if successUse1
            lexer.advance()
        else
            throw keywordExpected(new Position(startUse1), new string(useKeyword))

        let importModule: PathItem = parsePathItem() catch _ (error)
            throw error
        let importExtensions: PathIdentifier[] = parsePathIdentifierList() catch _ null
        mutable end: Position = lexer.getPosition()
        var ret: UseDeclaration = new UseDeclaration(importModule, importExtensions, new Position(start), new Position(end))
        importModule.parent = ret
        if importExtensions != null {
            for item: PathIdentifier in importExtensions
                item.parent = ret
        }

        return(ret)
    }

    function parseConstantDeclaration(): ConstantDeclaration throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startLet1: Position = lexer.getPreviousPosition()
        let successLet1: bool = lexer.parseKeyword(letKeyword)
        if successLet1
            lexer.advance()
        else
            throw keywordExpected(new Position(startLet1), new string(letKeyword))

        let initializer: BindingInitializer = parseBindingInitializer() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: ConstantDeclaration = new ConstantDeclaration(initializer, new Position(start), new Position(end))
        initializer.parent = ret

        return(ret)
    }

    function parseVariableDeclaration(): VariableDeclaration throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startVar1: Position = lexer.getPreviousPosition()
        let successVar1: bool = lexer.parseKeyword(varKeyword)
        if successVar1
            lexer.advance()
        else
            throw keywordExpected(new Position(startVar1), new string(varKeyword))

        let initializer: BindingInitializer = parseBindingInitializer() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: VariableDeclaration = new VariableDeclaration(initializer, new Position(start), new Position(end))
        initializer.parent = ret

        return(ret)
    }

    function parseMutableDeclaration(): MutableDeclaration throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startMutable1: Position = lexer.getPreviousPosition()
        let successMutable1: bool = lexer.parseKeyword(mutableKeyword)
        if successMutable1
            lexer.advance()
        else
            throw keywordExpected(new Position(startMutable1), new string(mutableKeyword))

        let initializer: BindingInitializer = parseBindingInitializer() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: MutableDeclaration = new MutableDeclaration(initializer, new Position(start), new Position(end))
        initializer.parent = ret

        return(ret)
    }

    function parseFunctionDeclaration(): FunctionDeclaration throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let modifiers: Modifier[] = parseModifierList() catch _ null
        mutable startFunction2: Position = lexer.getPreviousPosition()
        let successFunction2: bool = lexer.parseKeyword(functionKeyword)
        if successFunction2
            lexer.advance()
        else
            throw keywordExpected(new Position(startFunction2), new string(functionKeyword))

        let name: FunctionName = parseFunctionName() catch _ (error)
            throw error
        let signature: FunctionSignature = parseFunctionSignature() catch _ (error)
            throw error
        let body: Expression = parseExpression() catch _ null
        mutable end: Position = lexer.getPosition()
        var ret: FunctionDeclaration = new FunctionDeclaration(modifiers, name, signature, body, new Position(start), new Position(end))
        if modifiers != null {
            for item: Modifier in modifiers
                item.parent = ret
        }
        name.parent = ret
        signature.parent = ret
        if body != null
            body.parent = ret

        return(ret)
    }

    function parseEnumDeclaration(): EnumDeclaration throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startEnum1: Position = lexer.getPreviousPosition()
        let successEnum1: bool = lexer.parseKeyword(enumKeyword)
        if successEnum1
            lexer.advance()
        else
            throw keywordExpected(new Position(startEnum1), new string(enumKeyword))

        mutable startName: Position = lexer.getPreviousPosition()
        let name: string? = lexer.parseIdentifier()
        if (name != null) && isIdentifier(name)
            lexer.advance()
        else
            throw identifierExpected(new Position(startName))

        mutable startLeftCurly3: Position = lexer.getPreviousPosition()
        let successLeftCurly3: bool = lexer.parsePunctuation(leftCurly)
        if successLeftCurly3
            lexer.advance()
        else
            throw punctuationExpected(new Position(startLeftCurly3), new string(leftCurly))

        let members: EnumMember[] = parseEnumMemberList() catch _ (error)
            throw error
        mutable startRightCurly5: Position = lexer.getPreviousPosition()
        let successRightCurly5: bool = lexer.parsePunctuation(rightCurly)
        if successRightCurly5
            lexer.advance()
        else
            throw punctuationExpected(new Position(startRightCurly5), new string(rightCurly))

        mutable end: Position = lexer.getPosition()
        var ret: EnumDeclaration = new EnumDeclaration(name, members, new Position(start), new Position(end))
        if members != null {
            for item: EnumMember in members
                item.parent = ret
        }

        return(ret)
    }

    function parseClassDeclaration(): ClassDeclaration throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startClass1: Position = lexer.getPreviousPosition()
        let successClass1: bool = lexer.parseKeyword(classKeyword)
        if successClass1
            lexer.advance()
        else
            throw keywordExpected(new Position(startClass1), new string(classKeyword))

        mutable startName: Position = lexer.getPreviousPosition()
        let name: string? = lexer.parseIdentifier()
        if (name != null) && isIdentifier(name)
            lexer.advance()
        else
            throw identifierExpected(new Position(startName))

        let genericArgumentClause: GenericArgumentClause = parseGenericArgumentClause() catch _ null
        let typeInheritanceClause: TypeInheritanceClause = parseTypeInheritanceClause() catch _ null
        let body: ClassBody = parseClassBody() catch _ null
        mutable end: Position = lexer.getPosition()
        var ret: ClassDeclaration = new ClassDeclaration(name, genericArgumentClause, typeInheritanceClause, body, new Position(start), new Position(end))
        if genericArgumentClause != null
            genericArgumentClause.parent = ret
        if typeInheritanceClause != null
            typeInheritanceClause.parent = ret
        if body != null
            body.parent = ret

        return(ret)
    }

    function parseConstructorDeclaration(): ConstructorDeclaration throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let modifiers: Modifier[] = parseModifierList() catch _ null
        mutable startConstructor2: Position = lexer.getPreviousPosition()
        let successConstructor2: bool = lexer.parseKeyword(constructorKeyword)
        if successConstructor2
            lexer.advance()
        else
            throw keywordExpected(new Position(startConstructor2), new string(constructorKeyword))

        let parameterClause: ParameterClause = parseParameterClause() catch _ (error)
            throw error
        let throwsClause: ThrowsClause = parseThrowsClause() catch _ null
        let body: Expression = parseExpression() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: ConstructorDeclaration = new ConstructorDeclaration(modifiers, parameterClause, throwsClause, body, new Position(start), new Position(end))
        if modifiers != null {
            for item: Modifier in modifiers
                item.parent = ret
        }
        parameterClause.parent = ret
        if throwsClause != null
            throwsClause.parent = ret
        body.parent = ret

        return(ret)
    }

    function parseCodeBlock(): CodeBlock throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startLeftCurly1: Position = lexer.getPreviousPosition()
        let successLeftCurly1: bool = lexer.parsePunctuation(leftCurly)
        if successLeftCurly1
            lexer.advance()
        else
            throw punctuationExpected(new Position(startLeftCurly1), new string(leftCurly))

        let statements: Statement[] = parseStatementList() catch _ (error)
            throw error
        mutable startRightCurly3: Position = lexer.getPreviousPosition()
        let successRightCurly3: bool = lexer.parsePunctuation(rightCurly)
        if successRightCurly3
            lexer.advance()
        else
            throw punctuationExpected(new Position(startRightCurly3), new string(rightCurly))

        mutable end: Position = lexer.getPosition()
        var ret: CodeBlock = new CodeBlock(statements, new Position(start), new Position(end))
        if statements != null {
            for item: Statement in statements
                item.parent = ret
        }

        return(ret)
    }

    function parseSimpleExpression(): SimpleExpression throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let prefixExpression: PrefixExpression = parsePrefixExpression() catch _ (error)
            throw error
        let binaryOps: BinaryOp[] = parseBinaryOpList() catch _ null
        mutable end: Position = lexer.getPosition()
        var ret: SimpleExpression = new SimpleExpression(prefixExpression, binaryOps, new Position(start), new Position(end))
        prefixExpression.parent = ret
        if binaryOps != null {
            for item: BinaryOp in binaryOps
                item.parent = ret
        }

        return(ret)
    }

    function parsePathIdentifierList(): PathIdentifier[] throws ParserError {
        mutable ret: PathIdentifier[]? = null
        while true {
            let node: PathIdentifier = parsePathIdentifier()
                catch _ break
            if ret == null
                ret = new PathIdentifier[]()
            ret.push(node)
        }
        return(ret)
    }

    function parsePathIdentifier(): PathIdentifier throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startDot1: Position = lexer.getPreviousPosition()
        let successDot1: bool = lexer.parsePunctuation(dot)
        if successDot1
            lexer.advance()
        else
            throw punctuationExpected(new Position(startDot1), new string(dot))

        let extension: PathItem = parsePathItem() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: PathIdentifier = new PathIdentifier(extension, new Position(start), new Position(end))
        extension.parent = ret

        return(ret)
    }

    function parsePathItem(): PathItem throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startName: Position = lexer.getPreviousPosition()
        let name: string? = lexer.parseIdentifier()
        if (name != null) && isIdentifier(name)
            lexer.advance()
        else
            throw identifierExpected(new Position(startName))

        mutable end: Position = lexer.getPosition()
        var ret: PathItem = new PathItem(name, new Position(start), new Position(end))

        return(ret)
    }

    function parseInitializer(): Initializer throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startEqual1: Position = lexer.getPreviousPosition()
        let successEqual1: bool = lexer.parsePunctuation(equal)
        if successEqual1
            lexer.advance()
        else
            throw punctuationExpected(new Position(startEqual1), new string(equal))

        let expression: Expression = parseExpression() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: Initializer = new Initializer(expression, new Position(start), new Position(end))
        expression.parent = ret

        return(ret)
    }

    function parseBindingInitializer(): BindingInitializer throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let initializer: PatternInitializer = parsePatternInitializer() catch _ (error)
            throw error
        let additionalInitializers: AdditionalInitializer[] = parseAdditionalInitializerList() catch _ null
        mutable end: Position = lexer.getPosition()
        var ret: BindingInitializer = new BindingInitializer(initializer, additionalInitializers, new Position(start), new Position(end))
        initializer.parent = ret
        if additionalInitializers != null {
            for item: AdditionalInitializer in additionalInitializers
                item.parent = ret
        }

        return(ret)
    }

    function parsePatternInitializerList(): PatternInitializer[] throws ParserError {
        mutable ret: PatternInitializer[]? = null
        while true {
            let node: PatternInitializer = parsePatternInitializer()
                catch _ break
            if ret == null
                ret = new PatternInitializer[]()
            ret.push(node)
        }
        return(ret)
    }

    function parsePatternInitializer(): PatternInitializer throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let pattern: Pattern = parsePattern() catch _ (error)
            throw error
        let initializer: Initializer = parseInitializer() catch _ null
        mutable end: Position = lexer.getPosition()
        var ret: PatternInitializer = new PatternInitializer(pattern, initializer, new Position(start), new Position(end))
        pattern.parent = ret
        if initializer != null
            initializer.parent = ret

        return(ret)
    }

    function parseAdditionalInitializerList(): AdditionalInitializer[] throws ParserError {
        mutable ret: AdditionalInitializer[]? = null
        while true {
            let node: AdditionalInitializer = parseAdditionalInitializer()
                catch _ break
            if ret == null
                ret = new AdditionalInitializer[]()
            ret.push(node)
        }
        return(ret)
    }

    function parseAdditionalInitializer(): AdditionalInitializer throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startComma1: Position = lexer.getPreviousPosition()
        let successComma1: bool = lexer.parsePunctuation(comma)
        if successComma1
            lexer.advance()
        else
            throw punctuationExpected(new Position(startComma1), new string(comma))

        let pattern: PatternInitializer = parsePatternInitializer() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: AdditionalInitializer = new AdditionalInitializer(pattern, new Position(start), new Position(end))
        pattern.parent = ret

        return(ret)
    }

    function parseModifierList(): Modifier[] throws ParserError {
        mutable ret: Modifier[]? = null
        while true {
            let node: Modifier = parseModifier()
                catch _ break
            if ret == null
                ret = new Modifier[]()
            ret.push(node)
        }
        return(ret)
    }

    function parseModifier(): Modifier throws ParserError {
        mutable errors: ParserError[] = new ParserError[]()
        mutable start: Position = lexer.getPreviousPosition()

        {
            let node: OverrideWord = parseOverrideWord() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: StaticWord = parseStaticWord() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        throw unableToParse(new Position(start), new ParserError[](errors))
    }

    function parseOverrideWord(): OverrideWord throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startOverride1: Position = lexer.getPreviousPosition()
        let successOverride1: bool = lexer.parseKeyword(overrideKeyword)
        if successOverride1
            lexer.advance()
        else
            throw keywordExpected(new Position(startOverride1), new string(overrideKeyword))

        mutable end: Position = lexer.getPosition()
        var ret: OverrideWord = new OverrideWord(new Position(start), new Position(end))

        return(ret)
    }

    function parseStaticWord(): StaticWord throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startStatic1: Position = lexer.getPreviousPosition()
        let successStatic1: bool = lexer.parseKeyword(staticKeyword)
        if successStatic1
            lexer.advance()
        else
            throw keywordExpected(new Position(startStatic1), new string(staticKeyword))

        mutable end: Position = lexer.getPosition()
        var ret: StaticWord = new StaticWord(new Position(start), new Position(end))

        return(ret)
    }

    function parseFunctionName(): FunctionName throws ParserError {
        mutable errors: ParserError[] = new ParserError[]()
        mutable start: Position = lexer.getPreviousPosition()

        {
            let node: IdentifierFunction = parseIdentifierFunction() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        throw unableToParse(new Position(start), new ParserError[](errors))
    }

    function parseIdentifierFunction(): IdentifierFunction throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startName: Position = lexer.getPreviousPosition()
        let name: string? = lexer.parseIdentifier()
        if (name != null) && isIdentifier(name)
            lexer.advance()
        else
            throw identifierExpected(new Position(startName))

        mutable end: Position = lexer.getPosition()
        var ret: IdentifierFunction = new IdentifierFunction(name, new Position(start), new Position(end))

        return(ret)
    }

    function parseFunctionSignature(): FunctionSignature throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let parameterClause: ParameterClause = parseParameterClause() catch _ (error)
            throw error
        let result: FunctionResult = parseFunctionResult() catch _ null
        let throwsClause: ThrowsClause = parseThrowsClause() catch _ null
        mutable end: Position = lexer.getPosition()
        var ret: FunctionSignature = new FunctionSignature(parameterClause, result, throwsClause, new Position(start), new Position(end))
        parameterClause.parent = ret
        if result != null
            result.parent = ret
        if throwsClause != null
            throwsClause.parent = ret

        return(ret)
    }

    function parseFunctionResult(): FunctionResult throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startColon1: Position = lexer.getPreviousPosition()
        let successColon1: bool = lexer.parsePunctuation(colon)
        if successColon1
            lexer.advance()
        else
            throw punctuationExpected(new Position(startColon1), new string(colon))

        let existingObject: ExistingClause = parseExistingClause() catch _ null
        let resultType: Type = parseType() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: FunctionResult = new FunctionResult(existingObject, resultType, new Position(start), new Position(end))
        if existingObject != null
            existingObject.parent = ret
        resultType.parent = ret

        return(ret)
    }

    function parseExistingClause(): ExistingClause throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startExisting1: Position = lexer.getPreviousPosition()
        let successExisting1: bool = lexer.parseKeyword(existingKeyword)
        if successExisting1
            lexer.advance()
        else
            throw keywordExpected(new Position(startExisting1), new string(existingKeyword))

        mutable end: Position = lexer.getPosition()
        var ret: ExistingClause = new ExistingClause(new Position(start), new Position(end))

        return(ret)
    }

    function parseParameterClauseList(): ParameterClause[] throws ParserError {
        mutable ret: ParameterClause[]? = null
        while true {
            let node: ParameterClause = parseParameterClause()
                catch _ break
            if ret == null
                ret = new ParameterClause[]()
            ret.push(node)
        }
        return(ret)
    }

    function parseParameterClause(): ParameterClause throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startLeftParen1: Position = lexer.getPreviousPosition()
        let successLeftParen1: bool = lexer.parsePunctuation(leftParen)
        if successLeftParen1
            lexer.advance()
        else
            throw punctuationExpected(new Position(startLeftParen1), new string(leftParen))

        let parameters: Parameter[] = parseParameterList() catch _ null
        mutable startRightParen3: Position = lexer.getPreviousPosition()
        let successRightParen3: bool = lexer.parsePunctuation(rightParen)
        if successRightParen3
            lexer.advance()
        else
            throw punctuationExpected(new Position(startRightParen3), new string(rightParen))

        mutable end: Position = lexer.getPosition()
        var ret: ParameterClause = new ParameterClause(parameters, new Position(start), new Position(end))
        if parameters != null {
            for item: Parameter in parameters
                item.parent = ret
        }

        return(ret)
    }

    function parseParameterList(): Parameter[] throws ParserError {
        mutable ret: Parameter[]? = null
        while true {
            let node: Parameter = parseParameter()
                catch _ break
            if ret == null
                ret = new Parameter[]()
            ret.push(node)
        }
        return(ret)
    }

    function parseParameter(): Parameter throws ParserError {
        mutable errors: ParserError[] = new ParserError[]()
        mutable start: Position = lexer.getPreviousPosition()

        {
            let node: ConstParameter = parseConstParameter() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: VarParameter = parseVarParameter() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        throw unableToParse(new Position(start), new ParserError[](errors))
    }

    function parseConstParameter(): ConstParameter throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let successLet1: bool = lexer.parseKeyword(letKeyword)
        if successLet1
            lexer.advance()
        mutable startName: Position = lexer.getPreviousPosition()
        let name: string? = lexer.parseIdentifier()
        if (name != null) && isIdentifier(name)
            lexer.advance()
        else
            throw identifierExpected(new Position(startName))

        mutable startColon3: Position = lexer.getPreviousPosition()
        let successColon3: bool = lexer.parsePunctuation(colon)
        if successColon3
            lexer.advance()
        else
            throw punctuationExpected(new Position(startColon3), new string(colon))

        let parameterType: Type = parseType() catch _ (error)
            throw error
        let successComma5: bool = lexer.parsePunctuation(comma)
        if successComma5
            lexer.advance()
        mutable end: Position = lexer.getPosition()
        var ret: ConstParameter = new ConstParameter(name, parameterType, new Position(start), new Position(end))
        parameterType.parent = ret

        return(ret)
    }

    function parseVarParameter(): VarParameter throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startMutable1: Position = lexer.getPreviousPosition()
        let successMutable1: bool = lexer.parseKeyword(mutableKeyword)
        if successMutable1
            lexer.advance()
        else
            throw keywordExpected(new Position(startMutable1), new string(mutableKeyword))

        mutable startName: Position = lexer.getPreviousPosition()
        let name: string? = lexer.parseIdentifier()
        if (name != null) && isIdentifier(name)
            lexer.advance()
        else
            throw identifierExpected(new Position(startName))

        mutable startColon3: Position = lexer.getPreviousPosition()
        let successColon3: bool = lexer.parsePunctuation(colon)
        if successColon3
            lexer.advance()
        else
            throw punctuationExpected(new Position(startColon3), new string(colon))

        let parameterType: Type = parseType() catch _ (error)
            throw error
        let successComma5: bool = lexer.parsePunctuation(comma)
        if successComma5
            lexer.advance()
        mutable end: Position = lexer.getPosition()
        var ret: VarParameter = new VarParameter(name, parameterType, new Position(start), new Position(end))
        parameterType.parent = ret

        return(ret)
    }

    function parseThrowsClause(): ThrowsClause throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startThrows1: Position = lexer.getPreviousPosition()
        let successThrows1: bool = lexer.parseKeyword(throwsKeyword)
        if successThrows1
            lexer.advance()
        else
            throw keywordExpected(new Position(startThrows1), new string(throwsKeyword))

        let throwsType: Type = parseType() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: ThrowsClause = new ThrowsClause(throwsType, new Position(start), new Position(end))
        throwsType.parent = ret

        return(ret)
    }

    function parseEnumMemberList(): EnumMember[] throws ParserError {
        mutable ret: EnumMember[]? = null
        while true {
            let node: EnumMember = parseEnumMember()
                catch _ break
            if ret == null
                ret = new EnumMember[]()
            ret.push(node)
        }
        return(ret)
    }

    function parseEnumMember(): EnumMember throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startCase1: Position = lexer.getPreviousPosition()
        let successCase1: bool = lexer.parseKeyword(caseKeyword)
        if successCase1
            lexer.advance()
        else
            throw keywordExpected(new Position(startCase1), new string(caseKeyword))

        let enumCase: EnumCase = parseEnumCase() catch _ (error)
            throw error
        let additionalCases: AdditionalCase[] = parseAdditionalCaseList() catch _ null
        let parameterClause: ParameterClause = parseParameterClause() catch _ null
        mutable end: Position = lexer.getPosition()
        var ret: EnumMember = new EnumMember(enumCase, additionalCases, parameterClause, new Position(start), new Position(end))
        enumCase.parent = ret
        if additionalCases != null {
            for item: AdditionalCase in additionalCases
                item.parent = ret
        }
        if parameterClause != null
            parameterClause.parent = ret

        return(ret)
    }

    function parseEnumCase(): EnumCase throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startName: Position = lexer.getPreviousPosition()
        let name: string? = lexer.parseIdentifier()
        if (name != null) && isIdentifier(name)
            lexer.advance()
        else
            throw identifierExpected(new Position(startName))

        mutable end: Position = lexer.getPosition()
        var ret: EnumCase = new EnumCase(name, new Position(start), new Position(end))

        return(ret)
    }

    function parseAdditionalCaseList(): AdditionalCase[] throws ParserError {
        mutable ret: AdditionalCase[]? = null
        while true {
            let node: AdditionalCase = parseAdditionalCase()
                catch _ break
            if ret == null
                ret = new AdditionalCase[]()
            ret.push(node)
        }
        return(ret)
    }

    function parseAdditionalCase(): AdditionalCase throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startComma1: Position = lexer.getPreviousPosition()
        let successComma1: bool = lexer.parsePunctuation(comma)
        if successComma1
            lexer.advance()
        else
            throw punctuationExpected(new Position(startComma1), new string(comma))

        let enumCase: EnumCase = parseEnumCase() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: AdditionalCase = new AdditionalCase(enumCase, new Position(start), new Position(end))
        enumCase.parent = ret

        return(ret)
    }

    function parseClassBody(): ClassBody throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startLeftCurly1: Position = lexer.getPreviousPosition()
        let successLeftCurly1: bool = lexer.parsePunctuation(leftCurly)
        if successLeftCurly1
            lexer.advance()
        else
            throw punctuationExpected(new Position(startLeftCurly1), new string(leftCurly))

        let members: ClassMember[] = parseClassMemberList() catch _ null
        mutable startRightCurly3: Position = lexer.getPreviousPosition()
        let successRightCurly3: bool = lexer.parsePunctuation(rightCurly)
        if successRightCurly3
            lexer.advance()
        else
            throw punctuationExpected(new Position(startRightCurly3), new string(rightCurly))

        mutable end: Position = lexer.getPosition()
        var ret: ClassBody = new ClassBody(members, new Position(start), new Position(end))
        if members != null {
            for item: ClassMember in members
                item.parent = ret
        }

        return(ret)
    }

    function parseGenericArgumentClause(): GenericArgumentClause throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startLeftAngular1: Position = lexer.getPreviousPosition()
        let successLeftAngular1: bool = lexer.parsePunctuation(leftAngular)
        if successLeftAngular1
            lexer.advance()
        else
            throw punctuationExpected(new Position(startLeftAngular1), new string(leftAngular))

        let genericParameters: GenericParameter[] = parseGenericParameterList() catch _ (error)
            throw error
        mutable startRightAngular3: Position = lexer.getPreviousPosition()
        let successRightAngular3: bool = lexer.parsePunctuation(rightAngular)
        if successRightAngular3
            lexer.advance()
        else
            throw punctuationExpected(new Position(startRightAngular3), new string(rightAngular))

        mutable end: Position = lexer.getPosition()
        var ret: GenericArgumentClause = new GenericArgumentClause(genericParameters, new Position(start), new Position(end))
        if genericParameters != null {
            for item: GenericParameter in genericParameters
                item.parent = ret
        }

        return(ret)
    }

    function parseGenericParameterList(): GenericParameter[] throws ParserError {
        mutable ret: GenericParameter[]? = null
        while true {
            let node: GenericParameter = parseGenericParameter()
                catch _ break
            if ret == null
                ret = new GenericParameter[]()
            ret.push(node)
        }
        return(ret)
    }

    function parseGenericParameter(): GenericParameter throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startTypeName: Position = lexer.getPreviousPosition()
        let typeName: string? = lexer.parseIdentifier()
        if (typeName != null) && isIdentifier(typeName)
            lexer.advance()
        else
            throw identifierExpected(new Position(startTypeName))

        mutable end: Position = lexer.getPosition()
        var ret: GenericParameter = new GenericParameter(typeName, new Position(start), new Position(end))

        return(ret)
    }

    function parseClassMemberList(): ClassMember[] throws ParserError {
        mutable ret: ClassMember[]? = null
        while true {
            let node: ClassMember = parseClassMember()
                catch _ break
            if ret == null
                ret = new ClassMember[]()
            ret.push(node)
        }
        return(ret)
    }

    function parseClassMember(): ClassMember throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let declaration: Declaration = parseDeclaration() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: ClassMember = new ClassMember(declaration, new Position(start), new Position(end))
        declaration.parent = ret

        return(ret)
    }

    function parsePrefixExpression(): PrefixExpression throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let prefixOperator: string? = lexer.parsePrefixOperator()
        if prefixOperator != null
            lexer.advance()
        let expression: PostfixExpression = parsePostfixExpression() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: PrefixExpression = new PrefixExpression(prefixOperator, expression, new Position(start), new Position(end))
        expression.parent = ret

        return(ret)
    }

    function parsePostfixExpression(): PostfixExpression throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let primaryExpression: PrimaryExpression = parsePrimaryExpression() catch _ (error)
            throw error
        let postfixes: Postfix[] = parsePostfixList() catch _ null
        mutable end: Position = lexer.getPosition()
        var ret: PostfixExpression = new PostfixExpression(primaryExpression, postfixes, new Position(start), new Position(end))
        primaryExpression.parent = ret
        if postfixes != null {
            for item: Postfix in postfixes
                item.parent = ret
        }

        return(ret)
    }

    function parseBinaryOpList(): BinaryOp[] throws ParserError {
        mutable ret: BinaryOp[]? = null
        while true {
            let node: BinaryOp = parseBinaryOp()
                catch _ break
            if ret == null
                ret = new BinaryOp[]()
            ret.push(node)
        }
        return(ret)
    }

    function parseBinaryOp(): BinaryOp throws ParserError {
        mutable errors: ParserError[] = new ParserError[]()
        mutable start: Position = lexer.getPreviousPosition()

        {
            let node: BinaryOperation = parseBinaryOperation() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: Assignment = parseAssignment() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: TypeQuery = parseTypeQuery() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: TypeCast = parseTypeCast() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        throw unableToParse(new Position(start), new ParserError[](errors))
    }

    function parseBinaryOperation(): BinaryOperation throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startBinaryOperator: Position = lexer.getPreviousPosition()
        let binaryOperator: string? = lexer.parseBinaryOperator()
        if binaryOperator != null
            lexer.advance()
        else
            throw operatorExpected(new Position(startBinaryOperator))

        let expression: PrefixExpression = parsePrefixExpression() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: BinaryOperation = new BinaryOperation(binaryOperator, expression, new Position(start), new Position(end))
        expression.parent = ret

        return(ret)
    }

    function parseAssignment(): Assignment throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startEqual1: Position = lexer.getPreviousPosition()
        let successEqual1: bool = lexer.parsePunctuation(equal)
        if successEqual1
            lexer.advance()
        else
            throw punctuationExpected(new Position(startEqual1), new string(equal))

        let expression: Expression = parseExpression() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: Assignment = new Assignment(expression, new Position(start), new Position(end))
        expression.parent = ret

        return(ret)
    }

    function parseTypeQuery(): TypeQuery throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startIs1: Position = lexer.getPreviousPosition()
        let successIs1: bool = lexer.parseKeyword(isKeyword)
        if successIs1
            lexer.advance()
        else
            throw keywordExpected(new Position(startIs1), new string(isKeyword))

        let objectType: Type = parseType() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: TypeQuery = new TypeQuery(objectType, new Position(start), new Position(end))
        objectType.parent = ret

        return(ret)
    }

    function parseTypeCast(): TypeCast throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startAs1: Position = lexer.getPreviousPosition()
        let successAs1: bool = lexer.parseKeyword(asKeyword)
        if successAs1
            lexer.advance()
        else
            throw keywordExpected(new Position(startAs1), new string(asKeyword))

        let objectType: Type = parseType() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: TypeCast = new TypeCast(objectType, new Position(start), new Position(end))
        objectType.parent = ret

        return(ret)
    }

    function parseCatchClauseList(): CatchClause[] throws ParserError {
        mutable ret: CatchClause[]? = null
        while true {
            let node: CatchClause = parseCatchClause()
                catch _ break
            if ret == null
                ret = new CatchClause[]()
            ret.push(node)
        }
        return(ret)
    }

    function parseCatchClause(): CatchClause throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startCatch1: Position = lexer.getPreviousPosition()
        let successCatch1: bool = lexer.parseKeyword(catchKeyword)
        if successCatch1
            lexer.advance()
        else
            throw keywordExpected(new Position(startCatch1), new string(catchKeyword))

        let catchPattern: CatchPattern = parseCatchPattern() catch _ (error)
            throw error
        let bindingPattern: TuplePattern = parseTuplePattern() catch _ null
        let expression: Expression = parseExpression() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: CatchClause = new CatchClause(catchPattern, bindingPattern, expression, new Position(start), new Position(end))
        catchPattern.parent = ret
        if bindingPattern != null
            bindingPattern.parent = ret
        expression.parent = ret

        return(ret)
    }

    function parseCatchPattern(): CatchPattern throws ParserError {
        mutable errors: ParserError[] = new ParserError[]()
        mutable start: Position = lexer.getPreviousPosition()

        {
            let node: WildCardCatchPattern = parseWildCardCatchPattern() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: IdentifierCatchPattern = parseIdentifierCatchPattern() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        throw unableToParse(new Position(start), new ParserError[](errors))
    }

    function parseWildCardCatchPattern(): WildCardCatchPattern throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let pattern: WildcardPattern = parseWildcardPattern() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: WildCardCatchPattern = new WildCardCatchPattern(pattern, new Position(start), new Position(end))
        pattern.parent = ret

        return(ret)
    }

    function parseIdentifierCatchPattern(): IdentifierCatchPattern throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startName: Position = lexer.getPreviousPosition()
        let name: string? = lexer.parseIdentifier()
        if (name != null) && isIdentifier(name)
            lexer.advance()
        else
            throw identifierExpected(new Position(startName))

        let member: ExplicitMemberExpression = parseExplicitMemberExpression() catch _ null
        mutable end: Position = lexer.getPosition()
        var ret: IdentifierCatchPattern = new IdentifierCatchPattern(name, member, new Position(start), new Position(end))
        if member != null
            member.parent = ret

        return(ret)
    }

    function parsePostfixList(): Postfix[] throws ParserError {
        mutable ret: Postfix[]? = null
        while true {
            let node: Postfix = parsePostfix()
                catch _ break
            if ret == null
                ret = new Postfix[]()
            ret.push(node)
        }
        return(ret)
    }

    function parsePostfix(): Postfix throws ParserError {
        mutable errors: ParserError[] = new ParserError[]()
        mutable start: Position = lexer.getPreviousPosition()

        {
            let node: OperatorPostfix = parseOperatorPostfix() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: FunctionCall = parseFunctionCall() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: ExplicitMemberExpression = parseExplicitMemberExpression() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: Subscript = parseSubscript() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        throw unableToParse(new Position(start), new ParserError[](errors))
    }

    function parseOperatorPostfix(): OperatorPostfix throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startPostfixOperator: Position = lexer.getPreviousPosition()
        let postfixOperator: string? = lexer.parsePostfixOperator()
        if postfixOperator != null
            lexer.advance()
        else
            throw operatorExpected(new Position(startPostfixOperator))

        mutable end: Position = lexer.getPosition()
        var ret: OperatorPostfix = new OperatorPostfix(postfixOperator, new Position(start), new Position(end))

        return(ret)
    }

    function parseFunctionCall(): FunctionCall throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let arguments: ParenthesizedExpression = parseParenthesizedExpression() catch _ (error)
            throw error
        let catchClauses: CatchClause[] = parseCatchClauseList() catch _ null
        mutable end: Position = lexer.getPosition()
        var ret: FunctionCall = new FunctionCall(arguments, catchClauses, new Position(start), new Position(end))
        arguments.parent = ret
        if catchClauses != null {
            for item: CatchClause in catchClauses
                item.parent = ret
        }

        return(ret)
    }

    function parseExplicitMemberExpression(): ExplicitMemberExpression throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startDot1: Position = lexer.getPreviousPosition()
        let successDot1: bool = lexer.parsePunctuation(dot)
        if successDot1
            lexer.advance()
        else
            throw punctuationExpected(new Position(startDot1), new string(dot))

        let memberPostfix: MemberPostfix = parseMemberPostfix() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: ExplicitMemberExpression = new ExplicitMemberExpression(memberPostfix, new Position(start), new Position(end))
        memberPostfix.parent = ret

        return(ret)
    }

    function parseSubscript(): Subscript throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startLeftBracket1: Position = lexer.getPreviousPosition()
        let successLeftBracket1: bool = lexer.parsePunctuation(leftBracket)
        if successLeftBracket1
            lexer.advance()
        else
            throw punctuationExpected(new Position(startLeftBracket1), new string(leftBracket))

        let expressions: ExpressionElement[] = parseExpressionElementList() catch _ (error)
            throw error
        mutable startRightBracket3: Position = lexer.getPreviousPosition()
        let successRightBracket3: bool = lexer.parsePunctuation(rightBracket)
        if successRightBracket3
            lexer.advance()
        else
            throw punctuationExpected(new Position(startRightBracket3), new string(rightBracket))

        mutable end: Position = lexer.getPosition()
        var ret: Subscript = new Subscript(expressions, new Position(start), new Position(end))
        if expressions != null {
            for item: ExpressionElement in expressions
                item.parent = ret
        }

        return(ret)
    }

    function parseExpressionElementList(): ExpressionElement[] throws ParserError {
        mutable ret: ExpressionElement[]? = null
        while true {
            let node: ExpressionElement = parseExpressionElement()
                catch _ break
            if ret == null
                ret = new ExpressionElement[]()
            ret.push(node)
        }
        return(ret)
    }

    function parseExpressionElement(): ExpressionElement throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let expression: Expression = parseExpression() catch _ (error)
            throw error
        let successComma2: bool = lexer.parsePunctuation(comma)
        if successComma2
            lexer.advance()
        mutable end: Position = lexer.getPosition()
        var ret: ExpressionElement = new ExpressionElement(expression, new Position(start), new Position(end))
        expression.parent = ret

        return(ret)
    }

    function parseMemberPostfix(): MemberPostfix throws ParserError {
        mutable errors: ParserError[] = new ParserError[]()
        mutable start: Position = lexer.getPreviousPosition()

        {
            let node: NamedMemberPostfix = parseNamedMemberPostfix() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        throw unableToParse(new Position(start), new ParserError[](errors))
    }

    function parseNamedMemberPostfix(): NamedMemberPostfix throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let identifier: IdentifierExpression = parseIdentifierExpression() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: NamedMemberPostfix = new NamedMemberPostfix(identifier, new Position(start), new Position(end))
        identifier.parent = ret

        return(ret)
    }

    function parsePrimaryExpression(): PrimaryExpression throws ParserError {
        mutable errors: ParserError[] = new ParserError[]()
        mutable start: Position = lexer.getPreviousPosition()

        {
            let node: IdentifierExpression = parseIdentifierExpression() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: LiteralExpression = parseLiteralExpression() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: IfExpression = parseIfExpression() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: SwitchExpression = parseSwitchExpression() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: ForExpression = parseForExpression() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: WhileExpression = parseWhileExpression() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: RepeatExpression = parseRepeatExpression() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: ParenthesizedExpression = parseParenthesizedExpression() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: ReturnExpression = parseReturnExpression() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: ThrowExpression = parseThrowExpression() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: BreakExpression = parseBreakExpression() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: ConstructorCall = parseConstructorCall() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: ThisExpression = parseThisExpression() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: SuperExpression = parseSuperExpression() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: NullExpression = parseNullExpression() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        throw unableToParse(new Position(start), new ParserError[](errors))
    }

    function parseIdentifierExpression(): IdentifierExpression throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startName: Position = lexer.getPreviousPosition()
        let name: string? = lexer.parseIdentifier()
        if (name != null) && isIdentifier(name)
            lexer.advance()
        else
            throw identifierExpected(new Position(startName))

        mutable end: Position = lexer.getPosition()
        var ret: IdentifierExpression = new IdentifierExpression(name, new Position(start), new Position(end))

        return(ret)
    }

    function parseLiteralExpression(): LiteralExpression throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startLiteral: Position = lexer.getPreviousPosition()
        let literal: Literal? = lexer.parseLiteral()
        if literal != null
            lexer.advance()
        else
            throw literalExpected(new Position(startLiteral))

        mutable end: Position = lexer.getPosition()
        var ret: LiteralExpression = new LiteralExpression(literal, new Position(start), new Position(end))

        return(ret)
    }

    function parseIfExpression(): IfExpression throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startIf1: Position = lexer.getPreviousPosition()
        let successIf1: bool = lexer.parseKeyword(ifKeyword)
        if successIf1
            lexer.advance()
        else
            throw keywordExpected(new Position(startIf1), new string(ifKeyword))

        let condition: Expression = parseExpression() catch _ (error)
            throw error
        let consequent: Expression = parseExpression() catch _ (error)
            throw error
        let elseClause: ElseClause = parseElseClause() catch _ null
        mutable end: Position = lexer.getPosition()
        var ret: IfExpression = new IfExpression(condition, consequent, elseClause, new Position(start), new Position(end))
        condition.parent = ret
        consequent.parent = ret
        if elseClause != null
            elseClause.parent = ret

        return(ret)
    }

    function parseSwitchExpression(): SwitchExpression throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startSwitch1: Position = lexer.getPreviousPosition()
        let successSwitch1: bool = lexer.parseKeyword(switchKeyword)
        if successSwitch1
            lexer.advance()
        else
            throw keywordExpected(new Position(startSwitch1), new string(switchKeyword))

        let expression: Expression = parseExpression() catch _ (error)
            throw error
        let body: SwitchBody = parseSwitchBody() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: SwitchExpression = new SwitchExpression(expression, body, new Position(start), new Position(end))
        expression.parent = ret
        body.parent = ret

        return(ret)
    }

    function parseForExpression(): ForExpression throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startFor1: Position = lexer.getPreviousPosition()
        let successFor1: bool = lexer.parseKeyword(forKeyword)
        if successFor1
            lexer.advance()
        else
            throw keywordExpected(new Position(startFor1), new string(forKeyword))

        let pattern: Pattern = parsePattern() catch _ (error)
            throw error
        mutable startIn3: Position = lexer.getPreviousPosition()
        let successIn3: bool = lexer.parseKeyword(inKeyword)
        if successIn3
            lexer.advance()
        else
            throw keywordExpected(new Position(startIn3), new string(inKeyword))

        let expression: Expression = parseExpression() catch _ (error)
            throw error
        let code: Expression = parseExpression() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: ForExpression = new ForExpression(pattern, expression, code, new Position(start), new Position(end))
        pattern.parent = ret
        expression.parent = ret
        code.parent = ret

        return(ret)
    }

    function parseWhileExpression(): WhileExpression throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startWhile1: Position = lexer.getPreviousPosition()
        let successWhile1: bool = lexer.parseKeyword(whileKeyword)
        if successWhile1
            lexer.advance()
        else
            throw keywordExpected(new Position(startWhile1), new string(whileKeyword))

        let condition: Expression = parseExpression() catch _ (error)
            throw error
        let code: Expression = parseExpression() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: WhileExpression = new WhileExpression(condition, code, new Position(start), new Position(end))
        condition.parent = ret
        code.parent = ret

        return(ret)
    }

    function parseRepeatExpression(): RepeatExpression throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startRepeat1: Position = lexer.getPreviousPosition()
        let successRepeat1: bool = lexer.parseKeyword(repeatKeyword)
        if successRepeat1
            lexer.advance()
        else
            throw keywordExpected(new Position(startRepeat1), new string(repeatKeyword))

        let code: Expression = parseExpression() catch _ (error)
            throw error
        mutable startWhile3: Position = lexer.getPreviousPosition()
        let successWhile3: bool = lexer.parseKeyword(whileKeyword)
        if successWhile3
            lexer.advance()
        else
            throw keywordExpected(new Position(startWhile3), new string(whileKeyword))

        let condition: Expression = parseExpression() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: RepeatExpression = new RepeatExpression(code, condition, new Position(start), new Position(end))
        code.parent = ret
        condition.parent = ret

        return(ret)
    }

    function parseParenthesizedExpression(): ParenthesizedExpression throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startLeftParen1: Position = lexer.getPreviousPosition()
        let successLeftParen1: bool = lexer.parsePunctuation(leftParen)
        if successLeftParen1
            lexer.advance()
        else
            throw punctuationExpected(new Position(startLeftParen1), new string(leftParen))

        let expressionElements: ExpressionElement[] = parseExpressionElementList() catch _ null
        mutable startRightParen3: Position = lexer.getPreviousPosition()
        let successRightParen3: bool = lexer.parsePunctuation(rightParen)
        if successRightParen3
            lexer.advance()
        else
            throw punctuationExpected(new Position(startRightParen3), new string(rightParen))

        mutable end: Position = lexer.getPosition()
        var ret: ParenthesizedExpression = new ParenthesizedExpression(expressionElements, new Position(start), new Position(end))
        if expressionElements != null {
            for item: ExpressionElement in expressionElements
                item.parent = ret
        }

        return(ret)
    }

    function parseReturnExpression(): ReturnExpression throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startReturn1: Position = lexer.getPreviousPosition()
        let successReturn1: bool = lexer.parseKeyword(returnKeyword)
        if successReturn1
            lexer.advance()
        else
            throw keywordExpected(new Position(startReturn1), new string(returnKeyword))

        let expression: ParenthesizedExpression = parseParenthesizedExpression() catch _ null
        mutable end: Position = lexer.getPosition()
        var ret: ReturnExpression = new ReturnExpression(expression, new Position(start), new Position(end))
        if expression != null
            expression.parent = ret

        return(ret)
    }

    function parseThrowExpression(): ThrowExpression throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startThrow1: Position = lexer.getPreviousPosition()
        let successThrow1: bool = lexer.parseKeyword(throwKeyword)
        if successThrow1
            lexer.advance()
        else
            throw keywordExpected(new Position(startThrow1), new string(throwKeyword))

        let error: IdentifierExpression = parseIdentifierExpression() catch _ (error)
            throw error
        let arguments: ParenthesizedExpression = parseParenthesizedExpression() catch _ null
        mutable end: Position = lexer.getPosition()
        var ret: ThrowExpression = new ThrowExpression(error, arguments, new Position(start), new Position(end))
        error.parent = ret
        if arguments != null
            arguments.parent = ret

        return(ret)
    }

    function parseBreakExpression(): BreakExpression throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startBreak1: Position = lexer.getPreviousPosition()
        let successBreak1: bool = lexer.parseKeyword(breakKeyword)
        if successBreak1
            lexer.advance()
        else
            throw keywordExpected(new Position(startBreak1), new string(breakKeyword))

        let expression: ParenthesizedExpression = parseParenthesizedExpression() catch _ null
        mutable end: Position = lexer.getPosition()
        var ret: BreakExpression = new BreakExpression(expression, new Position(start), new Position(end))
        if expression != null
            expression.parent = ret

        return(ret)
    }

    function parseConstructorCall(): ConstructorCall throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startNew1: Position = lexer.getPreviousPosition()
        let successNew1: bool = lexer.parseKeyword(newKeyword)
        if successNew1
            lexer.advance()
        else
            throw keywordExpected(new Position(startNew1), new string(newKeyword))

        let typeToInitialize: Type = parseType() catch _ (error)
            throw error
        let arguments: ParenthesizedExpression = parseParenthesizedExpression() catch _ (error)
            throw error
        let catchClauses: CatchClause[] = parseCatchClauseList() catch _ null
        mutable end: Position = lexer.getPosition()
        var ret: ConstructorCall = new ConstructorCall(typeToInitialize, arguments, catchClauses, new Position(start), new Position(end))
        typeToInitialize.parent = ret
        arguments.parent = ret
        if catchClauses != null {
            for item: CatchClause in catchClauses
                item.parent = ret
        }

        return(ret)
    }

    function parseThisExpression(): ThisExpression throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startThis1: Position = lexer.getPreviousPosition()
        let successThis1: bool = lexer.parseKeyword(thisKeyword)
        if successThis1
            lexer.advance()
        else
            throw keywordExpected(new Position(startThis1), new string(thisKeyword))

        mutable end: Position = lexer.getPosition()
        var ret: ThisExpression = new ThisExpression(new Position(start), new Position(end))

        return(ret)
    }

    function parseSuperExpression(): SuperExpression throws ParserError {
        mutable errors: ParserError[] = new ParserError[]()
        mutable start: Position = lexer.getPreviousPosition()

        {
            let node: SuperDot = parseSuperDot() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: SuperSubscript = parseSuperSubscript() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        throw unableToParse(new Position(start), new ParserError[](errors))
    }

    function parseSuperDot(): SuperDot throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startSuper1: Position = lexer.getPreviousPosition()
        let successSuper1: bool = lexer.parseKeyword(superKeyword)
        if successSuper1
            lexer.advance()
        else
            throw keywordExpected(new Position(startSuper1), new string(superKeyword))

        mutable startDot2: Position = lexer.getPreviousPosition()
        let successDot2: bool = lexer.parsePunctuation(dot)
        if successDot2
            lexer.advance()
        else
            throw punctuationExpected(new Position(startDot2), new string(dot))

        let member: CommonSuperMember = parseCommonSuperMember() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: SuperDot = new SuperDot(member, new Position(start), new Position(end))
        member.parent = ret

        return(ret)
    }

    function parseSuperSubscript(): SuperSubscript throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startSuper1: Position = lexer.getPreviousPosition()
        let successSuper1: bool = lexer.parseKeyword(superKeyword)
        if successSuper1
            lexer.advance()
        else
            throw keywordExpected(new Position(startSuper1), new string(superKeyword))

        let subscript: Subscript = parseSubscript() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: SuperSubscript = new SuperSubscript(subscript, new Position(start), new Position(end))
        subscript.parent = ret

        return(ret)
    }

    function parseNullExpression(): NullExpression throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startNull1: Position = lexer.getPreviousPosition()
        let successNull1: bool = lexer.parseKeyword(nullKeyword)
        if successNull1
            lexer.advance()
        else
            throw keywordExpected(new Position(startNull1), new string(nullKeyword))

        mutable end: Position = lexer.getPosition()
        var ret: NullExpression = new NullExpression(new Position(start), new Position(end))

        return(ret)
    }

    function parseElseClause(): ElseClause throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startElse1: Position = lexer.getPreviousPosition()
        let successElse1: bool = lexer.parseKeyword(elseKeyword)
        if successElse1
            lexer.advance()
        else
            throw keywordExpected(new Position(startElse1), new string(elseKeyword))

        let alternative: Expression = parseExpression() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: ElseClause = new ElseClause(alternative, new Position(start), new Position(end))
        alternative.parent = ret

        return(ret)
    }

    function parseSwitchBody(): SwitchBody throws ParserError {
        mutable errors: ParserError[] = new ParserError[]()
        mutable start: Position = lexer.getPreviousPosition()

        {
            let node: CurliedSwitchBody = parseCurliedSwitchBody() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: NakedSwitchBody = parseNakedSwitchBody() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        throw unableToParse(new Position(start), new ParserError[](errors))
    }

    function parseCurliedSwitchBody(): CurliedSwitchBody throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startLeftCurly1: Position = lexer.getPreviousPosition()
        let successLeftCurly1: bool = lexer.parsePunctuation(leftCurly)
        if successLeftCurly1
            lexer.advance()
        else
            throw punctuationExpected(new Position(startLeftCurly1), new string(leftCurly))

        let cases: SwitchCase[] = parseSwitchCaseList() catch _ (error)
            throw error
        mutable startRightCurly3: Position = lexer.getPreviousPosition()
        let successRightCurly3: bool = lexer.parsePunctuation(rightCurly)
        if successRightCurly3
            lexer.advance()
        else
            throw punctuationExpected(new Position(startRightCurly3), new string(rightCurly))

        mutable end: Position = lexer.getPosition()
        var ret: CurliedSwitchBody = new CurliedSwitchBody(cases, new Position(start), new Position(end))
        if cases != null {
            for item: SwitchCase in cases
                item.parent = ret
        }

        return(ret)
    }

    function parseNakedSwitchBody(): NakedSwitchBody throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let cases: SwitchCase[] = parseSwitchCaseList() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: NakedSwitchBody = new NakedSwitchBody(cases, new Position(start), new Position(end))
        if cases != null {
            for item: SwitchCase in cases
                item.parent = ret
        }

        return(ret)
    }

    function parseSwitchCaseList(): SwitchCase[] throws ParserError {
        mutable ret: SwitchCase[]? = null
        while true {
            let node: SwitchCase = parseSwitchCase()
                catch _ break
            if ret == null
                ret = new SwitchCase[]()
            ret.push(node)
        }
        return(ret)
    }

    function parseSwitchCase(): SwitchCase throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let label: CaseLabel = parseCaseLabel() catch _ (error)
            throw error
        let content: CaseContent = parseCaseContent() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: SwitchCase = new SwitchCase(label, content, new Position(start), new Position(end))
        label.parent = ret
        content.parent = ret

        return(ret)
    }

    function parseCaseLabel(): CaseLabel throws ParserError {
        mutable errors: ParserError[] = new ParserError[]()
        mutable start: Position = lexer.getPreviousPosition()

        {
            let node: ItemCaseLabel = parseItemCaseLabel() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: DefaultCaseLabel = parseDefaultCaseLabel() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        throw unableToParse(new Position(start), new ParserError[](errors))
    }

    function parseItemCaseLabel(): ItemCaseLabel throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startCase1: Position = lexer.getPreviousPosition()
        let successCase1: bool = lexer.parseKeyword(caseKeyword)
        if successCase1
            lexer.advance()
        else
            throw keywordExpected(new Position(startCase1), new string(caseKeyword))

        let pattern: Pattern = parsePattern() catch _ (error)
            throw error
        let additionalPatterns: CaseItem[] = parseCaseItemList() catch _ null
        mutable startColon4: Position = lexer.getPreviousPosition()
        let successColon4: bool = lexer.parsePunctuation(colon)
        if successColon4
            lexer.advance()
        else
            throw punctuationExpected(new Position(startColon4), new string(colon))

        mutable end: Position = lexer.getPosition()
        var ret: ItemCaseLabel = new ItemCaseLabel(pattern, additionalPatterns, new Position(start), new Position(end))
        pattern.parent = ret
        if additionalPatterns != null {
            for item: CaseItem in additionalPatterns
                item.parent = ret
        }

        return(ret)
    }

    function parseDefaultCaseLabel(): DefaultCaseLabel throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startDefault1: Position = lexer.getPreviousPosition()
        let successDefault1: bool = lexer.parseKeyword(defaultKeyword)
        if successDefault1
            lexer.advance()
        else
            throw keywordExpected(new Position(startDefault1), new string(defaultKeyword))

        mutable startColon2: Position = lexer.getPreviousPosition()
        let successColon2: bool = lexer.parsePunctuation(colon)
        if successColon2
            lexer.advance()
        else
            throw punctuationExpected(new Position(startColon2), new string(colon))

        mutable end: Position = lexer.getPosition()
        var ret: DefaultCaseLabel = new DefaultCaseLabel(new Position(start), new Position(end))

        return(ret)
    }

    function parseCaseItemList(): CaseItem[] throws ParserError {
        mutable ret: CaseItem[]? = null
        while true {
            let node: CaseItem = parseCaseItem()
                catch _ break
            if ret == null
                ret = new CaseItem[]()
            ret.push(node)
        }
        return(ret)
    }

    function parseCaseItem(): CaseItem throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startComma1: Position = lexer.getPreviousPosition()
        let successComma1: bool = lexer.parsePunctuation(comma)
        if successComma1
            lexer.advance()
        else
            throw punctuationExpected(new Position(startComma1), new string(comma))

        let pattern: Pattern = parsePattern() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: CaseItem = new CaseItem(pattern, new Position(start), new Position(end))
        pattern.parent = ret

        return(ret)
    }

    function parsePattern(): Pattern throws ParserError {
        mutable errors: ParserError[] = new ParserError[]()
        mutable start: Position = lexer.getPreviousPosition()

        {
            let node: WildcardPattern = parseWildcardPattern() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: IdentifierPattern = parseIdentifierPattern() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: TuplePattern = parseTuplePattern() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: ExpressionPattern = parseExpressionPattern() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        throw unableToParse(new Position(start), new ParserError[](errors))
    }

    function parseWildcardPattern(): WildcardPattern throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startUnderscore1: Position = lexer.getPreviousPosition()
        let successUnderscore1: bool = lexer.parsePunctuation(underscore)
        if successUnderscore1
            lexer.advance()
        else
            throw punctuationExpected(new Position(startUnderscore1), new string(underscore))

        mutable end: Position = lexer.getPosition()
        var ret: WildcardPattern = new WildcardPattern(new Position(start), new Position(end))

        return(ret)
    }

    function parseIdentifierPattern(): IdentifierPattern throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startIdentifier: Position = lexer.getPreviousPosition()
        let identifier: string? = lexer.parseIdentifier()
        if (identifier != null) && isIdentifier(identifier)
            lexer.advance()
        else
            throw identifierExpected(new Position(startIdentifier))

        let annotationForType: TypeAnnotation = parseTypeAnnotation() catch _ null
        mutable end: Position = lexer.getPosition()
        var ret: IdentifierPattern = new IdentifierPattern(identifier, annotationForType, new Position(start), new Position(end))
        if annotationForType != null
            annotationForType.parent = ret

        return(ret)
    }

    function parseTuplePattern(): TuplePattern throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startLeftParen1: Position = lexer.getPreviousPosition()
        let successLeftParen1: bool = lexer.parsePunctuation(leftParen)
        if successLeftParen1
            lexer.advance()
        else
            throw punctuationExpected(new Position(startLeftParen1), new string(leftParen))

        let elements: TuplePatternElement[] = parseTuplePatternElementList() catch _ (error)
            throw error
        mutable startRightParen3: Position = lexer.getPreviousPosition()
        let successRightParen3: bool = lexer.parsePunctuation(rightParen)
        if successRightParen3
            lexer.advance()
        else
            throw punctuationExpected(new Position(startRightParen3), new string(rightParen))

        mutable end: Position = lexer.getPosition()
        var ret: TuplePattern = new TuplePattern(elements, new Position(start), new Position(end))
        if elements != null {
            for item: TuplePatternElement in elements
                item.parent = ret
        }

        return(ret)
    }

    function parseExpressionPattern(): ExpressionPattern throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let expression: Expression = parseExpression() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: ExpressionPattern = new ExpressionPattern(expression, new Position(start), new Position(end))
        expression.parent = ret

        return(ret)
    }

    function parseTuplePatternElementList(): TuplePatternElement[] throws ParserError {
        mutable ret: TuplePatternElement[]? = null
        while true {
            let node: TuplePatternElement = parseTuplePatternElement()
                catch _ break
            if ret == null
                ret = new TuplePatternElement[]()
            ret.push(node)
        }
        return(ret)
    }

    function parseTuplePatternElement(): TuplePatternElement throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let pattern: Pattern = parsePattern() catch _ (error)
            throw error
        let successComma2: bool = lexer.parsePunctuation(comma)
        if successComma2
            lexer.advance()
        mutable end: Position = lexer.getPosition()
        var ret: TuplePatternElement = new TuplePatternElement(pattern, new Position(start), new Position(end))
        pattern.parent = ret

        return(ret)
    }

    function parseCaseContent(): CaseContent throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let statements: Statement[] = parseStatementList() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: CaseContent = new CaseContent(statements, new Position(start), new Position(end))
        if statements != null {
            for item: Statement in statements
                item.parent = ret
        }

        return(ret)
    }

    function parseCommonSuperMember(): CommonSuperMember throws ParserError {
        mutable errors: ParserError[] = new ParserError[]()
        mutable start: Position = lexer.getPreviousPosition()

        {
            let node: SuperConstructor = parseSuperConstructor() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: SuperMember = parseSuperMember() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        throw unableToParse(new Position(start), new ParserError[](errors))
    }

    function parseSuperConstructor(): SuperConstructor throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startConstructor1: Position = lexer.getPreviousPosition()
        let successConstructor1: bool = lexer.parseKeyword(constructorKeyword)
        if successConstructor1
            lexer.advance()
        else
            throw keywordExpected(new Position(startConstructor1), new string(constructorKeyword))

        mutable end: Position = lexer.getPosition()
        var ret: SuperConstructor = new SuperConstructor(new Position(start), new Position(end))

        return(ret)
    }

    function parseSuperMember(): SuperMember throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startName: Position = lexer.getPreviousPosition()
        let name: string? = lexer.parseIdentifier()
        if (name != null) && isIdentifier(name)
            lexer.advance()
        else
            throw identifierExpected(new Position(startName))

        mutable end: Position = lexer.getPosition()
        var ret: SuperMember = new SuperMember(name, new Position(start), new Position(end))

        return(ret)
    }

    function parseType(): Type throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startName: Position = lexer.getPreviousPosition()
        let name: string? = lexer.parseIdentifier()
        if (name != null) && isIdentifier(name)
            lexer.advance()
        else
            throw identifierExpected(new Position(startName))

        let subType: Subtype = parseSubtype() catch _ null
        let postfixes: TypePostfix[] = parseTypePostfixList() catch _ null
        mutable end: Position = lexer.getPosition()
        var ret: Type = new Type(name, subType, postfixes, new Position(start), new Position(end))
        if subType != null
            subType.parent = ret
        if postfixes != null {
            for item: TypePostfix in postfixes
                item.parent = ret
        }

        return(ret)
    }

    function parseTypeAnnotation(): TypeAnnotation throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startColon1: Position = lexer.getPreviousPosition()
        let successColon1: bool = lexer.parsePunctuation(colon)
        if successColon1
            lexer.advance()
        else
            throw punctuationExpected(new Position(startColon1), new string(colon))

        let annotationForType: Type = parseType() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: TypeAnnotation = new TypeAnnotation(annotationForType, new Position(start), new Position(end))
        annotationForType.parent = ret

        return(ret)
    }

    function parseSubtype(): Subtype throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startDot1: Position = lexer.getPreviousPosition()
        let successDot1: bool = lexer.parsePunctuation(dot)
        if successDot1
            lexer.advance()
        else
            throw punctuationExpected(new Position(startDot1), new string(dot))

        let type: Type = parseType() catch _ (error)
            throw error
        mutable end: Position = lexer.getPosition()
        var ret: Subtype = new Subtype(type, new Position(start), new Position(end))
        type.parent = ret

        return(ret)
    }

    function parseTypePostfixList(): TypePostfix[] throws ParserError {
        mutable ret: TypePostfix[]? = null
        while true {
            let node: TypePostfix = parseTypePostfix()
                catch _ break
            if ret == null
                ret = new TypePostfix[]()
            ret.push(node)
        }
        return(ret)
    }

    function parseTypePostfix(): TypePostfix throws ParserError {
        mutable errors: ParserError[] = new ParserError[]()
        mutable start: Position = lexer.getPreviousPosition()

        {
            let node: OptionalType = parseOptionalType() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: IndexedType = parseIndexedType() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        throw unableToParse(new Position(start), new ParserError[](errors))
    }

    function parseOptionalType(): OptionalType throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startQuestionMark1: Position = lexer.getPreviousPosition()
        let successQuestionMark1: bool = lexer.parsePunctuation(questionMark)
        if successQuestionMark1
            lexer.advance()
        else
            throw punctuationExpected(new Position(startQuestionMark1), new string(questionMark))

        mutable end: Position = lexer.getPosition()
        var ret: OptionalType = new OptionalType(new Position(start), new Position(end))

        return(ret)
    }

    function parseIndexedType(): IndexedType throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startLeftBracket1: Position = lexer.getPreviousPosition()
        let successLeftBracket1: bool = lexer.parsePunctuation(leftBracket)
        if successLeftBracket1
            lexer.advance()
        else
            throw punctuationExpected(new Position(startLeftBracket1), new string(leftBracket))

        let key: Type = parseType() catch _ null
        mutable startRightBracket3: Position = lexer.getPreviousPosition()
        let successRightBracket3: bool = lexer.parsePunctuation(rightBracket)
        if successRightBracket3
            lexer.advance()
        else
            throw punctuationExpected(new Position(startRightBracket3), new string(rightBracket))

        mutable end: Position = lexer.getPosition()
        var ret: IndexedType = new IndexedType(key, new Position(start), new Position(end))
        if key != null
            key.parent = ret

        return(ret)
    }

    function parseTypeInheritanceClause(): TypeInheritanceClause throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        mutable startExtends1: Position = lexer.getPreviousPosition()
        let successExtends1: bool = lexer.parseKeyword(extendsKeyword)
        if successExtends1
            lexer.advance()
        else
            throw keywordExpected(new Position(startExtends1), new string(extendsKeyword))

        let inheritances: Inheritance[] = parseInheritanceList() catch _ null
        mutable end: Position = lexer.getPosition()
        var ret: TypeInheritanceClause = new TypeInheritanceClause(inheritances, new Position(start), new Position(end))
        if inheritances != null {
            for item: Inheritance in inheritances
                item.parent = ret
        }

        return(ret)
    }

    function parseInheritanceList(): Inheritance[] throws ParserError {
        mutable ret: Inheritance[]? = null
        while true {
            let node: Inheritance = parseInheritance()
                catch _ break
            if ret == null
                ret = new Inheritance[]()
            ret.push(node)
        }
        return(ret)
    }

    function parseInheritance(): Inheritance throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let type: Type = parseType() catch _ (error)
            throw error
        let successComma2: bool = lexer.parsePunctuation(comma)
        if successComma2
            lexer.advance()
        mutable end: Position = lexer.getPosition()
        var ret: Inheritance = new Inheritance(type, new Position(start), new Position(end))
        type.parent = ret

        return(ret)
    }

    function isAtEnd(): bool {
        return(lexer.isAtEnd())
    }

    function isIdentifier(id: string): bool {
        if id.equals(useKeyword)
            return(false)

        if id.equals(classKeyword)
            return(false)

        if id.equals(functionKeyword)
            return(false)

        if id.equals(ifKeyword)
            return(false)

        if id.equals(elseKeyword)
            return(false)

        if id.equals(switchKeyword)
            return(false)

        if id.equals(caseKeyword)
            return(false)

        if id.equals(defaultKeyword)
            return(false)

        if id.equals(catchKeyword)
            return(false)

        if id.equals(forKeyword)
            return(false)

        if id.equals(inKeyword)
            return(false)

        if id.equals(whileKeyword)
            return(false)

        if id.equals(repeatKeyword)
            return(false)

        if id.equals(returnKeyword)
            return(false)

        if id.equals(throwKeyword)
            return(false)

        if id.equals(breakKeyword)
            return(false)

        if id.equals(throwsKeyword)
            return(false)

        if id.equals(existingKeyword)
            return(false)

        if id.equals(overrideKeyword)
            return(false)

        if id.equals(staticKeyword)
            return(false)

        if id.equals(letKeyword)
            return(false)

        if id.equals(varKeyword)
            return(false)

        if id.equals(mutableKeyword)
            return(false)

        if id.equals(isKeyword)
            return(false)

        if id.equals(asKeyword)
            return(false)

        if id.equals(constructorKeyword)
            return(false)

        if id.equals(enumKeyword)
            return(false)

        if id.equals(superKeyword)
            return(false)

        if id.equals(thisKeyword)
            return(false)

        if id.equals(nullKeyword)
            return(false)

        if id.equals(newKeyword)
            return(false)

        if id.equals(extendsKeyword)
            return(false)

        return(true)
    }

    mutable lexer: Lexer
    let fileName: string

    let useKeyword: string
    let classKeyword: string
    let functionKeyword: string
    let ifKeyword: string
    let elseKeyword: string
    let switchKeyword: string
    let caseKeyword: string
    let defaultKeyword: string
    let catchKeyword: string
    let forKeyword: string
    let inKeyword: string
    let whileKeyword: string
    let repeatKeyword: string
    let returnKeyword: string
    let throwKeyword: string
    let breakKeyword: string
    let throwsKeyword: string
    let existingKeyword: string
    let overrideKeyword: string
    let staticKeyword: string
    let letKeyword: string
    let varKeyword: string
    let mutableKeyword: string
    let isKeyword: string
    let asKeyword: string
    let constructorKeyword: string
    let enumKeyword: string
    let superKeyword: string
    let thisKeyword: string
    let nullKeyword: string
    let newKeyword: string
    let extendsKeyword: string
    let equal: string
    let leftAngular: string
    let rightAngular: string
    let comma: string
    let leftParen: string
    let rightParen: string
    let leftCurly: string
    let rightCurly: string
    let leftBracket: string
    let rightBracket: string
    let colon: string
    let dot: string
    let questionMark: string
    let underscore: string
}
