class Program
class CompilationUnit
class Statement
class Declaration
class Expression
class ConstantDeclaration
class VariableDeclaration
class MutableDeclaration
class FunctionDeclaration
class EnumDeclaration
class ClassDeclaration
class ConstructorDeclaration
class CodeBlock
class SimpleExpression
class Initializer
class BindingInitializer
class PatternInitializer
class AdditionalInitializer
class Modifier
class OverrideWord
class StaticWord
class FunctionSignature
class FunctionResult
class ParameterClause
class Parameter
class ConstParameter
class VarParameter
class ThrowsClause
class EnumMember
class EnumCase
class AdditionalCase
class ClassBody
class ClassMember
class PrefixExpression
class PostfixExpression
class BinaryOp
class BinaryOperation
class Assignment
class TypeQuery
class TypeCast
class CatchClause
class CatchPattern
class WildCardCatchPattern
class IdentifierCatchPattern
class Postfix
class OperatorPostfix
class FunctionCall
class MemberExpression
class Subscript
class ExpressionElement
class PrimaryExpression
class IdentifierExpression
class LiteralExpression
class IfExpression
class SwitchExpression
class ForExpression
class WhileExpression
class DoExpression
class ParenthesizedExpression
class ReturnExpression
class ThrowExpression
class BreakExpression
class ConstructorCall
class ThisExpression
class NullExpression
class ElseClause
class SwitchBody
class CurliedSwitchBody
class NakedSwitchBody
class SwitchCase
class CaseLabel
class ItemCaseLabel
class DefaultCaseLabel
class CaseItem
class Pattern
class WildcardPattern
class IdentifierPattern
class TuplePattern
class ExpressionPattern
class TuplePatternElement
class CaseContent
class Type
class TypeAnnotation
class Subtype
class TypePostfix
class IndexedType
class Pointer
class LifeTime
class Root
class Local
class Reference
class Thrown
class TypeInheritanceClause
class Inheritance

class Visitor {
    function openProgram(program: Program): bool {
        true
    }

    function closeProgram(program: Program) {
    }

    function openCompilationUnit(compilationUnit: CompilationUnit): bool {
        true
    }

    function closeCompilationUnit(compilationUnit: CompilationUnit) {
    }

    function openConstantDeclaration(constantDeclaration: ConstantDeclaration): bool {
        true
    }

    function closeConstantDeclaration(constantDeclaration: ConstantDeclaration) {
    }

    function openVariableDeclaration(variableDeclaration: VariableDeclaration): bool {
        true
    }

    function closeVariableDeclaration(variableDeclaration: VariableDeclaration) {
    }

    function openMutableDeclaration(mutableDeclaration: MutableDeclaration): bool {
        true
    }

    function closeMutableDeclaration(mutableDeclaration: MutableDeclaration) {
    }

    function openFunctionDeclaration(functionDeclaration: FunctionDeclaration): bool {
        true
    }

    function closeFunctionDeclaration(functionDeclaration: FunctionDeclaration) {
    }

    function openEnumDeclaration(enumDeclaration: EnumDeclaration): bool {
        true
    }

    function closeEnumDeclaration(enumDeclaration: EnumDeclaration) {
    }

    function openClassDeclaration(classDeclaration: ClassDeclaration): bool {
        true
    }

    function closeClassDeclaration(classDeclaration: ClassDeclaration) {
    }

    function openConstructorDeclaration(constructorDeclaration: ConstructorDeclaration): bool {
        true
    }

    function closeConstructorDeclaration(constructorDeclaration: ConstructorDeclaration) {
    }

    function openCodeBlock(codeBlock: CodeBlock): bool {
        true
    }

    function closeCodeBlock(codeBlock: CodeBlock) {
    }

    function openSimpleExpression(simpleExpression: SimpleExpression): bool {
        true
    }

    function closeSimpleExpression(simpleExpression: SimpleExpression) {
    }

    function openInitializer(initializer: Initializer): bool {
        true
    }

    function closeInitializer(initializer: Initializer) {
    }

    function openBindingInitializer(bindingInitializer: BindingInitializer): bool {
        true
    }

    function closeBindingInitializer(bindingInitializer: BindingInitializer) {
    }

    function openPatternInitializer(patternInitializer: PatternInitializer): bool {
        true
    }

    function closePatternInitializer(patternInitializer: PatternInitializer) {
    }

    function openAdditionalInitializer(additionalInitializer: AdditionalInitializer): bool {
        true
    }

    function closeAdditionalInitializer(additionalInitializer: AdditionalInitializer) {
    }

    function visitOverrideWord(overrideWord: OverrideWord) {
    }

    function visitStaticWord(staticWord: StaticWord) {
    }

    function openFunctionSignature(functionSignature: FunctionSignature): bool {
        true
    }

    function closeFunctionSignature(functionSignature: FunctionSignature) {
    }

    function openFunctionResult(functionResult: FunctionResult): bool {
        true
    }

    function closeFunctionResult(functionResult: FunctionResult) {
    }

    function openParameterClause(parameterClause: ParameterClause): bool {
        true
    }

    function closeParameterClause(parameterClause: ParameterClause) {
    }

    function openConstParameter(constParameter: ConstParameter): bool {
        true
    }

    function closeConstParameter(constParameter: ConstParameter) {
    }

    function openVarParameter(varParameter: VarParameter): bool {
        true
    }

    function closeVarParameter(varParameter: VarParameter) {
    }

    function openThrowsClause(throwsClause: ThrowsClause): bool {
        true
    }

    function closeThrowsClause(throwsClause: ThrowsClause) {
    }

    function openEnumMember(enumMember: EnumMember): bool {
        true
    }

    function closeEnumMember(enumMember: EnumMember) {
    }

    function visitEnumCase(enumCase: EnumCase) {
    }

    function openAdditionalCase(additionalCase: AdditionalCase): bool {
        true
    }

    function closeAdditionalCase(additionalCase: AdditionalCase) {
    }

    function openClassBody(classBody: ClassBody): bool {
        true
    }

    function closeClassBody(classBody: ClassBody) {
    }

    function openClassMember(classMember: ClassMember): bool {
        true
    }

    function closeClassMember(classMember: ClassMember) {
    }

    function openPrefixExpression(prefixExpression: PrefixExpression): bool {
        true
    }

    function closePrefixExpression(prefixExpression: PrefixExpression) {
    }

    function openPostfixExpression(postfixExpression: PostfixExpression): bool {
        true
    }

    function closePostfixExpression(postfixExpression: PostfixExpression) {
    }

    function openBinaryOperation(binaryOperation: BinaryOperation): bool {
        true
    }

    function closeBinaryOperation(binaryOperation: BinaryOperation) {
    }

    function openAssignment(assignment: Assignment): bool {
        true
    }

    function closeAssignment(assignment: Assignment) {
    }

    function openTypeQuery(typeQuery: TypeQuery): bool {
        true
    }

    function closeTypeQuery(typeQuery: TypeQuery) {
    }

    function openTypeCast(typeCast: TypeCast): bool {
        true
    }

    function closeTypeCast(typeCast: TypeCast) {
    }

    function openCatchClause(catchClause: CatchClause): bool {
        true
    }

    function closeCatchClause(catchClause: CatchClause) {
    }

    function openWildCardCatchPattern(wildCardCatchPattern: WildCardCatchPattern): bool {
        true
    }

    function closeWildCardCatchPattern(wildCardCatchPattern: WildCardCatchPattern) {
    }

    function openIdentifierCatchPattern(identifierCatchPattern: IdentifierCatchPattern): bool {
        true
    }

    function closeIdentifierCatchPattern(identifierCatchPattern: IdentifierCatchPattern) {
    }

    function visitOperatorPostfix(operatorPostfix: OperatorPostfix) {
    }

    function openFunctionCall(functionCall: FunctionCall): bool {
        true
    }

    function closeFunctionCall(functionCall: FunctionCall) {
    }

    function visitMemberExpression(memberExpression: MemberExpression) {
    }

    function openSubscript(subscript: Subscript): bool {
        true
    }

    function closeSubscript(subscript: Subscript) {
    }

    function openExpressionElement(expressionElement: ExpressionElement): bool {
        true
    }

    function closeExpressionElement(expressionElement: ExpressionElement) {
    }

    function visitIdentifierExpression(identifierExpression: IdentifierExpression) {
    }

    function visitLiteralExpression(literalExpression: LiteralExpression) {
    }

    function openIfExpression(ifExpression: IfExpression): bool {
        true
    }

    function closeIfExpression(ifExpression: IfExpression) {
    }

    function openSwitchExpression(switchExpression: SwitchExpression): bool {
        true
    }

    function closeSwitchExpression(switchExpression: SwitchExpression) {
    }

    function openForExpression(forExpression: ForExpression): bool {
        true
    }

    function closeForExpression(forExpression: ForExpression) {
    }

    function openWhileExpression(whileExpression: WhileExpression): bool {
        true
    }

    function closeWhileExpression(whileExpression: WhileExpression) {
    }

    function openDoExpression(doExpression: DoExpression): bool {
        true
    }

    function closeDoExpression(doExpression: DoExpression) {
    }

    function openParenthesizedExpression(parenthesizedExpression: ParenthesizedExpression): bool {
        true
    }

    function closeParenthesizedExpression(parenthesizedExpression: ParenthesizedExpression) {
    }

    function openReturnExpression(returnExpression: ReturnExpression): bool {
        true
    }

    function closeReturnExpression(returnExpression: ReturnExpression) {
    }

    function openThrowExpression(throwExpression: ThrowExpression): bool {
        true
    }

    function closeThrowExpression(throwExpression: ThrowExpression) {
    }

    function openBreakExpression(breakExpression: BreakExpression): bool {
        true
    }

    function closeBreakExpression(breakExpression: BreakExpression) {
    }

    function openConstructorCall(constructorCall: ConstructorCall): bool {
        true
    }

    function closeConstructorCall(constructorCall: ConstructorCall) {
    }

    function visitThisExpression(thisExpression: ThisExpression) {
    }

    function visitNullExpression(nullExpression: NullExpression) {
    }

    function openElseClause(elseClause: ElseClause): bool {
        true
    }

    function closeElseClause(elseClause: ElseClause) {
    }

    function openCurliedSwitchBody(curliedSwitchBody: CurliedSwitchBody): bool {
        true
    }

    function closeCurliedSwitchBody(curliedSwitchBody: CurliedSwitchBody) {
    }

    function openNakedSwitchBody(nakedSwitchBody: NakedSwitchBody): bool {
        true
    }

    function closeNakedSwitchBody(nakedSwitchBody: NakedSwitchBody) {
    }

    function openSwitchCase(switchCase: SwitchCase): bool {
        true
    }

    function closeSwitchCase(switchCase: SwitchCase) {
    }

    function openItemCaseLabel(itemCaseLabel: ItemCaseLabel): bool {
        true
    }

    function closeItemCaseLabel(itemCaseLabel: ItemCaseLabel) {
    }

    function visitDefaultCaseLabel(defaultCaseLabel: DefaultCaseLabel) {
    }

    function openCaseItem(caseItem: CaseItem): bool {
        true
    }

    function closeCaseItem(caseItem: CaseItem) {
    }

    function visitWildcardPattern(wildcardPattern: WildcardPattern) {
    }

    function openIdentifierPattern(identifierPattern: IdentifierPattern): bool {
        true
    }

    function closeIdentifierPattern(identifierPattern: IdentifierPattern) {
    }

    function openTuplePattern(tuplePattern: TuplePattern): bool {
        true
    }

    function closeTuplePattern(tuplePattern: TuplePattern) {
    }

    function openExpressionPattern(expressionPattern: ExpressionPattern): bool {
        true
    }

    function closeExpressionPattern(expressionPattern: ExpressionPattern) {
    }

    function openTuplePatternElement(tuplePatternElement: TuplePatternElement): bool {
        true
    }

    function closeTuplePatternElement(tuplePatternElement: TuplePatternElement) {
    }

    function openCaseContent(caseContent: CaseContent): bool {
        true
    }

    function closeCaseContent(caseContent: CaseContent) {
    }

    function openType(type: Type): bool {
        true
    }

    function closeType(type: Type) {
    }

    function openTypeAnnotation(typeAnnotation: TypeAnnotation): bool {
        true
    }

    function closeTypeAnnotation(typeAnnotation: TypeAnnotation) {
    }

    function openSubtype(subtype: Subtype): bool {
        true
    }

    function closeSubtype(subtype: Subtype) {
    }

    function openIndexedType(indexedType: IndexedType): bool {
        true
    }

    function closeIndexedType(indexedType: IndexedType) {
    }

    function visitPointer(pointer: Pointer) {
    }

    function visitRoot(root: Root) {
    }

    function visitLocal(local: Local) {
    }

    function visitReference(reference: Reference) {
    }

    function visitThrown(thrown: Thrown) {
    }

    function openTypeInheritanceClause(typeInheritanceClause: TypeInheritanceClause): bool {
        true
    }

    function closeTypeInheritanceClause(typeInheritanceClause: TypeInheritanceClause) {
    }

    function openInheritance(inheritance: Inheritance): bool {
        true
    }

    function closeInheritance(inheritance: Inheritance) {
    }
}

class SyntaxNode {
    let start: Position
    let end: Position
    var parent: SyntaxNode
}

class Program extends SyntaxNode {

    constructor(name: string, directory: string, compilationUnits: CompilationUnit[]) {
        start = new Position(0, 0)
        end = new Position(0, 0)
        this.name = name
        this.directory = directory
        this.compilationUnits = compilationUnits
        this.parent = null
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openProgram(this)
            return
        if compilationUnits != null {
            for node: CompilationUnit in compilationUnits
                node.accept(visitor)
        }
        visitor.closeProgram(this)
    }

    let name: string
    let directory: string
    let compilationUnits: CompilationUnit[]
}

class CompilationUnit extends SyntaxNode {

    constructor(statements: Statement[], start: Position, end: Position) {
        this.start = start
        this.end = end
        this.statements = statements
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openCompilationUnit(this)
            return
        if statements != null {
            for node: Statement in statements
                node.accept(visitor)
        }
        visitor.closeCompilationUnit(this)
    }

    let statements: Statement[]
    let fileName: string
}

class Statement extends SyntaxNode {

    function accept(mutable visitor: Visitor) {
    }

}

class Declaration extends Statement {

    override function accept(mutable visitor: Visitor) {
    }

}

class Expression extends Statement {

    override function accept(mutable visitor: Visitor) {
    }

}

class ConstantDeclaration extends Declaration {

    constructor(initializer: BindingInitializer, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.initializer = initializer
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openConstantDeclaration(this)
            return
        initializer.accept(visitor)
        visitor.closeConstantDeclaration(this)
    }

    let initializer: BindingInitializer
}

class VariableDeclaration extends Declaration {

    constructor(initializer: BindingInitializer, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.initializer = initializer
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openVariableDeclaration(this)
            return
        initializer.accept(visitor)
        visitor.closeVariableDeclaration(this)
    }

    let initializer: BindingInitializer
}

class MutableDeclaration extends Declaration {

    constructor(initializer: BindingInitializer, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.initializer = initializer
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openMutableDeclaration(this)
            return
        initializer.accept(visitor)
        visitor.closeMutableDeclaration(this)
    }

    let initializer: BindingInitializer
}

class FunctionDeclaration extends Declaration {

    constructor(modifiers: Modifier[], name: string, signature: FunctionSignature, body: Expression, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.modifiers = modifiers
        this.name = name
        this.signature = signature
        this.body = body
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openFunctionDeclaration(this)
            return
        if modifiers != null {
            for node: Modifier in modifiers
                node.accept(visitor)
        }
        signature.accept(visitor)
        if body != null
            body.accept(visitor)
        visitor.closeFunctionDeclaration(this)
    }

    let modifiers: Modifier[]
    let name: string
    let signature: FunctionSignature
    let body: Expression
}

class EnumDeclaration extends Declaration {

    constructor(name: string, members: EnumMember[], start: Position, end: Position) {
        this.start = start
        this.end = end
        this.name = name
        this.members = members
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openEnumDeclaration(this)
            return
        if members != null {
            for node: EnumMember in members
                node.accept(visitor)
        }
        visitor.closeEnumDeclaration(this)
    }

    let name: string
    let members: EnumMember[]
}

class ClassDeclaration extends Declaration {

    constructor(name: string, typeInheritanceClause: TypeInheritanceClause, body: ClassBody, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.name = name
        this.typeInheritanceClause = typeInheritanceClause
        this.body = body
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openClassDeclaration(this)
            return
        if typeInheritanceClause != null
            typeInheritanceClause.accept(visitor)
        if body != null
            body.accept(visitor)
        visitor.closeClassDeclaration(this)
    }

    let name: string
    let typeInheritanceClause: TypeInheritanceClause
    let body: ClassBody
}

class ConstructorDeclaration extends Declaration {

    constructor(parameterClause: ParameterClause, body: Expression, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.parameterClause = parameterClause
        this.body = body
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openConstructorDeclaration(this)
            return
        parameterClause.accept(visitor)
        body.accept(visitor)
        visitor.closeConstructorDeclaration(this)
    }

    let parameterClause: ParameterClause
    let body: Expression
}

class CodeBlock extends Expression {

    constructor(statements: Statement[], start: Position, end: Position) {
        this.start = start
        this.end = end
        this.statements = statements
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openCodeBlock(this)
            return
        if statements != null {
            for node: Statement in statements
                node.accept(visitor)
        }
        visitor.closeCodeBlock(this)
    }

    let statements: Statement[]
}

class SimpleExpression extends Expression {

    constructor(prefixExpression: PrefixExpression, binaryOps: BinaryOp[], start: Position, end: Position) {
        this.start = start
        this.end = end
        this.prefixExpression = prefixExpression
        this.binaryOps = binaryOps
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openSimpleExpression(this)
            return
        prefixExpression.accept(visitor)
        if binaryOps != null {
            for node: BinaryOp in binaryOps
                node.accept(visitor)
        }
        visitor.closeSimpleExpression(this)
    }

    let prefixExpression: PrefixExpression
    let binaryOps: BinaryOp[]
}

class Initializer extends SyntaxNode {

    constructor(expression: Expression, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.expression = expression
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openInitializer(this)
            return
        expression.accept(visitor)
        visitor.closeInitializer(this)
    }

    let expression: Expression
}

class BindingInitializer extends SyntaxNode {

    constructor(initializer: PatternInitializer, additionalInitializers: AdditionalInitializer[], start: Position, end: Position) {
        this.start = start
        this.end = end
        this.initializer = initializer
        this.additionalInitializers = additionalInitializers
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openBindingInitializer(this)
            return
        initializer.accept(visitor)
        if additionalInitializers != null {
            for node: AdditionalInitializer in additionalInitializers
                node.accept(visitor)
        }
        visitor.closeBindingInitializer(this)
    }

    let initializer: PatternInitializer
    let additionalInitializers: AdditionalInitializer[]
}

class PatternInitializer extends SyntaxNode {

    constructor(pattern: Pattern, initializer: Initializer, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.pattern = pattern
        this.initializer = initializer
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openPatternInitializer(this)
            return
        pattern.accept(visitor)
        if initializer != null
            initializer.accept(visitor)
        visitor.closePatternInitializer(this)
    }

    let pattern: Pattern
    let initializer: Initializer
}

class AdditionalInitializer extends SyntaxNode {

    constructor(pattern: PatternInitializer, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.pattern = pattern
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openAdditionalInitializer(this)
            return
        pattern.accept(visitor)
        visitor.closeAdditionalInitializer(this)
    }

    let pattern: PatternInitializer
}

class Modifier extends SyntaxNode {

    function accept(mutable visitor: Visitor) {
    }

}

class OverrideWord extends Modifier {

    constructor(start: Position, end: Position) {
        this.start = start
        this.end = end
    }

    override function accept(mutable visitor: Visitor) {
        visitor.visitOverrideWord(this)
    }

}

class StaticWord extends Modifier {

    constructor(start: Position, end: Position) {
        this.start = start
        this.end = end
    }

    override function accept(mutable visitor: Visitor) {
        visitor.visitStaticWord(this)
    }

}

class FunctionSignature extends SyntaxNode {

    constructor(parameterClause: ParameterClause, result: FunctionResult, throwsClause: ThrowsClause, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.parameterClause = parameterClause
        this.result = result
        this.throwsClause = throwsClause
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openFunctionSignature(this)
            return
        parameterClause.accept(visitor)
        if result != null
            result.accept(visitor)
        if throwsClause != null
            throwsClause.accept(visitor)
        visitor.closeFunctionSignature(this)
    }

    let parameterClause: ParameterClause
    let result: FunctionResult
    let throwsClause: ThrowsClause
}

class FunctionResult extends SyntaxNode {

    constructor(resultType: Type, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.resultType = resultType
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openFunctionResult(this)
            return
        resultType.accept(visitor)
        visitor.closeFunctionResult(this)
    }

    let resultType: Type
}

class ParameterClause extends SyntaxNode {

    constructor(parameters: Parameter[], start: Position, end: Position) {
        this.start = start
        this.end = end
        this.parameters = parameters
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openParameterClause(this)
            return
        if parameters != null {
            for node: Parameter in parameters
                node.accept(visitor)
        }
        visitor.closeParameterClause(this)
    }

    let parameters: Parameter[]
}

class Parameter extends SyntaxNode {

    function accept(mutable visitor: Visitor) {
    }

}

class ConstParameter extends Parameter {

    constructor(name: string, parameterType: Type, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.name = name
        this.parameterType = parameterType
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openConstParameter(this)
            return
        parameterType.accept(visitor)
        visitor.closeConstParameter(this)
    }

    let name: string
    let parameterType: Type
}

class VarParameter extends Parameter {

    constructor(name: string, parameterType: Type, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.name = name
        this.parameterType = parameterType
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openVarParameter(this)
            return
        parameterType.accept(visitor)
        visitor.closeVarParameter(this)
    }

    let name: string
    let parameterType: Type
}

class ThrowsClause extends SyntaxNode {

    constructor(throwsType: Type, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.throwsType = throwsType
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openThrowsClause(this)
            return
        throwsType.accept(visitor)
        visitor.closeThrowsClause(this)
    }

    let throwsType: Type
}

class EnumMember extends SyntaxNode {

    constructor(enumCase: EnumCase, additionalCases: AdditionalCase[], parameterClause: ParameterClause, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.enumCase = enumCase
        this.additionalCases = additionalCases
        this.parameterClause = parameterClause
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openEnumMember(this)
            return
        enumCase.accept(visitor)
        if additionalCases != null {
            for node: AdditionalCase in additionalCases
                node.accept(visitor)
        }
        if parameterClause != null
            parameterClause.accept(visitor)
        visitor.closeEnumMember(this)
    }

    let enumCase: EnumCase
    let additionalCases: AdditionalCase[]
    let parameterClause: ParameterClause
}

class EnumCase extends SyntaxNode {

    constructor(name: string, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.name = name
    }

    function accept(mutable visitor: Visitor) {
        visitor.visitEnumCase(this)
    }

    let name: string
}

class AdditionalCase extends SyntaxNode {

    constructor(enumCase: EnumCase, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.enumCase = enumCase
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openAdditionalCase(this)
            return
        enumCase.accept(visitor)
        visitor.closeAdditionalCase(this)
    }

    let enumCase: EnumCase
}

class ClassBody extends SyntaxNode {

    constructor(members: ClassMember[], start: Position, end: Position) {
        this.start = start
        this.end = end
        this.members = members
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openClassBody(this)
            return
        if members != null {
            for node: ClassMember in members
                node.accept(visitor)
        }
        visitor.closeClassBody(this)
    }

    let members: ClassMember[]
}

class ClassMember extends SyntaxNode {

    constructor(declaration: Declaration, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.declaration = declaration
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openClassMember(this)
            return
        declaration.accept(visitor)
        visitor.closeClassMember(this)
    }

    let declaration: Declaration
}

class PrefixExpression extends SyntaxNode {

    constructor(prefixOperator: string, expression: PostfixExpression, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.prefixOperator = prefixOperator
        this.expression = expression
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openPrefixExpression(this)
            return
        expression.accept(visitor)
        visitor.closePrefixExpression(this)
    }

    let prefixOperator: string
    let expression: PostfixExpression
}

class PostfixExpression extends SyntaxNode {

    constructor(primaryExpression: PrimaryExpression, postfixes: Postfix[], start: Position, end: Position) {
        this.start = start
        this.end = end
        this.primaryExpression = primaryExpression
        this.postfixes = postfixes
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openPostfixExpression(this)
            return
        primaryExpression.accept(visitor)
        if postfixes != null {
            for node: Postfix in postfixes
                node.accept(visitor)
        }
        visitor.closePostfixExpression(this)
    }

    let primaryExpression: PrimaryExpression
    let postfixes: Postfix[]
}

class BinaryOp extends SyntaxNode {

    function accept(mutable visitor: Visitor) {
    }

}

class BinaryOperation extends BinaryOp {

    constructor(binaryOperator: string, expression: PrefixExpression, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.binaryOperator = binaryOperator
        this.expression = expression
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openBinaryOperation(this)
            return
        expression.accept(visitor)
        visitor.closeBinaryOperation(this)
    }

    let binaryOperator: string
    let expression: PrefixExpression
}

class Assignment extends BinaryOp {

    constructor(expression: Expression, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.expression = expression
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openAssignment(this)
            return
        expression.accept(visitor)
        visitor.closeAssignment(this)
    }

    let expression: Expression
}

class TypeQuery extends BinaryOp {

    constructor(objectType: Type, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.objectType = objectType
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openTypeQuery(this)
            return
        objectType.accept(visitor)
        visitor.closeTypeQuery(this)
    }

    let objectType: Type
}

class TypeCast extends BinaryOp {

    constructor(objectType: Type, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.objectType = objectType
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openTypeCast(this)
            return
        objectType.accept(visitor)
        visitor.closeTypeCast(this)
    }

    let objectType: Type
}

class CatchClause extends SyntaxNode {

    constructor(catchPattern: CatchPattern, bindingPattern: TuplePattern, expression: Expression, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.catchPattern = catchPattern
        this.bindingPattern = bindingPattern
        this.expression = expression
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openCatchClause(this)
            return
        catchPattern.accept(visitor)
        if bindingPattern != null
            bindingPattern.accept(visitor)
        expression.accept(visitor)
        visitor.closeCatchClause(this)
    }

    let catchPattern: CatchPattern
    let bindingPattern: TuplePattern
    let expression: Expression
}

class CatchPattern extends SyntaxNode {

    function accept(mutable visitor: Visitor) {
    }

}

class WildCardCatchPattern extends CatchPattern {

    constructor(pattern: WildcardPattern, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.pattern = pattern
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openWildCardCatchPattern(this)
            return
        pattern.accept(visitor)
        visitor.closeWildCardCatchPattern(this)
    }

    let pattern: WildcardPattern
}

class IdentifierCatchPattern extends CatchPattern {

    constructor(name: string, member: MemberExpression, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.name = name
        this.member = member
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openIdentifierCatchPattern(this)
            return
        if member != null
            member.accept(visitor)
        visitor.closeIdentifierCatchPattern(this)
    }

    let name: string
    let member: MemberExpression
}

class Postfix extends SyntaxNode {

    function accept(mutable visitor: Visitor) {
    }

}

class OperatorPostfix extends Postfix {

    constructor(postfixOperator: string, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.postfixOperator = postfixOperator
    }

    override function accept(mutable visitor: Visitor) {
        visitor.visitOperatorPostfix(this)
    }

    let postfixOperator: string
}

class FunctionCall extends Postfix {

    constructor(arguments: ParenthesizedExpression, catchClauses: CatchClause[], start: Position, end: Position) {
        this.start = start
        this.end = end
        this.arguments = arguments
        this.catchClauses = catchClauses
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openFunctionCall(this)
            return
        arguments.accept(visitor)
        if catchClauses != null {
            for node: CatchClause in catchClauses
                node.accept(visitor)
        }
        visitor.closeFunctionCall(this)
    }

    let arguments: ParenthesizedExpression
    let catchClauses: CatchClause[]
}

class MemberExpression extends Postfix {

    constructor(member: string, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.member = member
    }

    override function accept(mutable visitor: Visitor) {
        visitor.visitMemberExpression(this)
    }

    let member: string
}

class Subscript extends Postfix {

    constructor(expressions: ExpressionElement[], start: Position, end: Position) {
        this.start = start
        this.end = end
        this.expressions = expressions
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openSubscript(this)
            return
        if expressions != null {
            for node: ExpressionElement in expressions
                node.accept(visitor)
        }
        visitor.closeSubscript(this)
    }

    let expressions: ExpressionElement[]
}

class ExpressionElement extends SyntaxNode {

    constructor(expression: Expression, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.expression = expression
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openExpressionElement(this)
            return
        expression.accept(visitor)
        visitor.closeExpressionElement(this)
    }

    let expression: Expression
}

class PrimaryExpression extends SyntaxNode {

    function accept(mutable visitor: Visitor) {
    }

}

class IdentifierExpression extends PrimaryExpression {

    constructor(name: string, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.name = name
    }

    override function accept(mutable visitor: Visitor) {
        visitor.visitIdentifierExpression(this)
    }

    let name: string
}

class LiteralExpression extends PrimaryExpression {

    constructor(literal: Literal, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.literal = literal
    }

    override function accept(mutable visitor: Visitor) {
        visitor.visitLiteralExpression(this)
    }

    let literal: Literal
}

class IfExpression extends PrimaryExpression {

    constructor(condition: Expression, consequent: Expression, elseClause: ElseClause, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.condition = condition
        this.consequent = consequent
        this.elseClause = elseClause
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openIfExpression(this)
            return
        condition.accept(visitor)
        consequent.accept(visitor)
        if elseClause != null
            elseClause.accept(visitor)
        visitor.closeIfExpression(this)
    }

    let condition: Expression
    let consequent: Expression
    let elseClause: ElseClause
}

class SwitchExpression extends PrimaryExpression {

    constructor(expression: Expression, body: SwitchBody, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.expression = expression
        this.body = body
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openSwitchExpression(this)
            return
        expression.accept(visitor)
        body.accept(visitor)
        visitor.closeSwitchExpression(this)
    }

    let expression: Expression
    let body: SwitchBody
}

class ForExpression extends PrimaryExpression {

    constructor(pattern: Pattern, expression: Expression, code: Expression, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.pattern = pattern
        this.expression = expression
        this.code = code
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openForExpression(this)
            return
        pattern.accept(visitor)
        expression.accept(visitor)
        code.accept(visitor)
        visitor.closeForExpression(this)
    }

    let pattern: Pattern
    let expression: Expression
    let code: Expression
}

class WhileExpression extends PrimaryExpression {

    constructor(condition: Expression, code: Expression, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.condition = condition
        this.code = code
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openWhileExpression(this)
            return
        condition.accept(visitor)
        code.accept(visitor)
        visitor.closeWhileExpression(this)
    }

    let condition: Expression
    let code: Expression
}

class DoExpression extends PrimaryExpression {

    constructor(code: Expression, condition: Expression, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.code = code
        this.condition = condition
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openDoExpression(this)
            return
        code.accept(visitor)
        condition.accept(visitor)
        visitor.closeDoExpression(this)
    }

    let code: Expression
    let condition: Expression
}

class ParenthesizedExpression extends PrimaryExpression {

    constructor(expressionElements: ExpressionElement[], start: Position, end: Position) {
        this.start = start
        this.end = end
        this.expressionElements = expressionElements
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openParenthesizedExpression(this)
            return
        if expressionElements != null {
            for node: ExpressionElement in expressionElements
                node.accept(visitor)
        }
        visitor.closeParenthesizedExpression(this)
    }

    let expressionElements: ExpressionElement[]
}

class ReturnExpression extends PrimaryExpression {

    constructor(expression: ParenthesizedExpression, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.expression = expression
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openReturnExpression(this)
            return
        if expression != null
            expression.accept(visitor)
        visitor.closeReturnExpression(this)
    }

    let expression: ParenthesizedExpression
}

class ThrowExpression extends PrimaryExpression {

    constructor(error: IdentifierExpression, arguments: ParenthesizedExpression, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.error = error
        this.arguments = arguments
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openThrowExpression(this)
            return
        error.accept(visitor)
        if arguments != null
            arguments.accept(visitor)
        visitor.closeThrowExpression(this)
    }

    let error: IdentifierExpression
    let arguments: ParenthesizedExpression
}

class BreakExpression extends PrimaryExpression {

    constructor(expression: ParenthesizedExpression, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.expression = expression
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openBreakExpression(this)
            return
        if expression != null
            expression.accept(visitor)
        visitor.closeBreakExpression(this)
    }

    let expression: ParenthesizedExpression
}

class ConstructorCall extends PrimaryExpression {

    constructor(typeToInitialize: Type, arguments: ParenthesizedExpression, catchClauses: CatchClause[], start: Position, end: Position) {
        this.start = start
        this.end = end
        this.typeToInitialize = typeToInitialize
        this.arguments = arguments
        this.catchClauses = catchClauses
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openConstructorCall(this)
            return
        typeToInitialize.accept(visitor)
        arguments.accept(visitor)
        if catchClauses != null {
            for node: CatchClause in catchClauses
                node.accept(visitor)
        }
        visitor.closeConstructorCall(this)
    }

    let typeToInitialize: Type
    let arguments: ParenthesizedExpression
    let catchClauses: CatchClause[]
}

class ThisExpression extends PrimaryExpression {

    constructor(start: Position, end: Position) {
        this.start = start
        this.end = end
    }

    override function accept(mutable visitor: Visitor) {
        visitor.visitThisExpression(this)
    }

}

class NullExpression extends PrimaryExpression {

    constructor(start: Position, end: Position) {
        this.start = start
        this.end = end
    }

    override function accept(mutable visitor: Visitor) {
        visitor.visitNullExpression(this)
    }

}

class ElseClause extends SyntaxNode {

    constructor(alternative: Expression, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.alternative = alternative
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openElseClause(this)
            return
        alternative.accept(visitor)
        visitor.closeElseClause(this)
    }

    let alternative: Expression
}

class SwitchBody extends SyntaxNode {

    function accept(mutable visitor: Visitor) {
    }

}

class CurliedSwitchBody extends SwitchBody {

    constructor(cases: SwitchCase[], start: Position, end: Position) {
        this.start = start
        this.end = end
        this.cases = cases
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openCurliedSwitchBody(this)
            return
        if cases != null {
            for node: SwitchCase in cases
                node.accept(visitor)
        }
        visitor.closeCurliedSwitchBody(this)
    }

    let cases: SwitchCase[]
}

class NakedSwitchBody extends SwitchBody {

    constructor(cases: SwitchCase[], start: Position, end: Position) {
        this.start = start
        this.end = end
        this.cases = cases
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openNakedSwitchBody(this)
            return
        if cases != null {
            for node: SwitchCase in cases
                node.accept(visitor)
        }
        visitor.closeNakedSwitchBody(this)
    }

    let cases: SwitchCase[]
}

class SwitchCase extends SyntaxNode {

    constructor(label: CaseLabel, content: CaseContent, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.label = label
        this.content = content
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openSwitchCase(this)
            return
        label.accept(visitor)
        content.accept(visitor)
        visitor.closeSwitchCase(this)
    }

    let label: CaseLabel
    let content: CaseContent
}

class CaseLabel extends SyntaxNode {

    function accept(mutable visitor: Visitor) {
    }

}

class ItemCaseLabel extends CaseLabel {

    constructor(pattern: Pattern, additionalPatterns: CaseItem[], start: Position, end: Position) {
        this.start = start
        this.end = end
        this.pattern = pattern
        this.additionalPatterns = additionalPatterns
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openItemCaseLabel(this)
            return
        pattern.accept(visitor)
        if additionalPatterns != null {
            for node: CaseItem in additionalPatterns
                node.accept(visitor)
        }
        visitor.closeItemCaseLabel(this)
    }

    let pattern: Pattern
    let additionalPatterns: CaseItem[]
}

class DefaultCaseLabel extends CaseLabel {

    constructor(start: Position, end: Position) {
        this.start = start
        this.end = end
    }

    override function accept(mutable visitor: Visitor) {
        visitor.visitDefaultCaseLabel(this)
    }

}

class CaseItem extends SyntaxNode {

    constructor(pattern: Pattern, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.pattern = pattern
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openCaseItem(this)
            return
        pattern.accept(visitor)
        visitor.closeCaseItem(this)
    }

    let pattern: Pattern
}

class Pattern extends SyntaxNode {

    function accept(mutable visitor: Visitor) {
    }

}

class WildcardPattern extends Pattern {

    constructor(start: Position, end: Position) {
        this.start = start
        this.end = end
    }

    override function accept(mutable visitor: Visitor) {
        visitor.visitWildcardPattern(this)
    }

}

class IdentifierPattern extends Pattern {

    constructor(identifier: string, annotationForType: TypeAnnotation, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.identifier = identifier
        this.annotationForType = annotationForType
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openIdentifierPattern(this)
            return
        if annotationForType != null
            annotationForType.accept(visitor)
        visitor.closeIdentifierPattern(this)
    }

    let identifier: string
    let annotationForType: TypeAnnotation
}

class TuplePattern extends Pattern {

    constructor(elements: TuplePatternElement[], start: Position, end: Position) {
        this.start = start
        this.end = end
        this.elements = elements
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openTuplePattern(this)
            return
        if elements != null {
            for node: TuplePatternElement in elements
                node.accept(visitor)
        }
        visitor.closeTuplePattern(this)
    }

    let elements: TuplePatternElement[]
}

class ExpressionPattern extends Pattern {

    constructor(expression: Expression, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.expression = expression
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openExpressionPattern(this)
            return
        expression.accept(visitor)
        visitor.closeExpressionPattern(this)
    }

    let expression: Expression
}

class TuplePatternElement extends SyntaxNode {

    constructor(pattern: Pattern, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.pattern = pattern
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openTuplePatternElement(this)
            return
        pattern.accept(visitor)
        visitor.closeTuplePatternElement(this)
    }

    let pattern: Pattern
}

class CaseContent extends SyntaxNode {

    constructor(statements: Statement[], start: Position, end: Position) {
        this.start = start
        this.end = end
        this.statements = statements
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openCaseContent(this)
            return
        if statements != null {
            for node: Statement in statements
                node.accept(visitor)
        }
        visitor.closeCaseContent(this)
    }

    let statements: Statement[]
}

class Type extends SyntaxNode {

    constructor(name: string, subType: Subtype, postfixes: TypePostfix[], lifeTime: LifeTime, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.name = name
        this.subType = subType
        this.postfixes = postfixes
        this.lifeTime = lifeTime
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openType(this)
            return
        if subType != null
            subType.accept(visitor)
        if postfixes != null {
            for node: TypePostfix in postfixes
                node.accept(visitor)
        }
        if lifeTime != null
            lifeTime.accept(visitor)
        visitor.closeType(this)
    }

    let name: string
    let subType: Subtype
    let postfixes: TypePostfix[]
    let lifeTime: LifeTime
}

class TypeAnnotation extends SyntaxNode {

    constructor(annotationForType: Type, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.annotationForType = annotationForType
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openTypeAnnotation(this)
            return
        annotationForType.accept(visitor)
        visitor.closeTypeAnnotation(this)
    }

    let annotationForType: Type
}

class Subtype extends SyntaxNode {

    constructor(type: Type, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.type = type
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openSubtype(this)
            return
        type.accept(visitor)
        visitor.closeSubtype(this)
    }

    let type: Type
}

class TypePostfix extends SyntaxNode {

    function accept(mutable visitor: Visitor) {
    }

}

class IndexedType extends TypePostfix {

    constructor(key: Type, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.key = key
    }

    override function accept(mutable visitor: Visitor) {
        if !visitor.openIndexedType(this)
            return
        if key != null
            key.accept(visitor)
        visitor.closeIndexedType(this)
    }

    let key: Type
}

class Pointer extends TypePostfix {

    constructor(start: Position, end: Position) {
        this.start = start
        this.end = end
    }

    override function accept(mutable visitor: Visitor) {
        visitor.visitPointer(this)
    }

}

class LifeTime extends SyntaxNode {

    function accept(mutable visitor: Visitor) {
    }

}

class Root extends LifeTime {

    constructor(start: Position, end: Position) {
        this.start = start
        this.end = end
    }

    override function accept(mutable visitor: Visitor) {
        visitor.visitRoot(this)
    }

}

class Local extends LifeTime {

    constructor(location: string, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.location = location
    }

    override function accept(mutable visitor: Visitor) {
        visitor.visitLocal(this)
    }

    let location: string
}

class Reference extends LifeTime {

    constructor(age: Literal, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.age = age
    }

    override function accept(mutable visitor: Visitor) {
        visitor.visitReference(this)
    }

    let age: Literal
}

class Thrown extends LifeTime {

    constructor(start: Position, end: Position) {
        this.start = start
        this.end = end
    }

    override function accept(mutable visitor: Visitor) {
        visitor.visitThrown(this)
    }

}

class TypeInheritanceClause extends SyntaxNode {

    constructor(inheritances: Inheritance[], start: Position, end: Position) {
        this.start = start
        this.end = end
        this.inheritances = inheritances
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openTypeInheritanceClause(this)
            return
        if inheritances != null {
            for node: Inheritance in inheritances
                node.accept(visitor)
        }
        visitor.closeTypeInheritanceClause(this)
    }

    let inheritances: Inheritance[]
}

class Inheritance extends SyntaxNode {

    constructor(type: Type, start: Position, end: Position) {
        this.start = start
        this.end = end
        this.type = type
    }

    function accept(mutable visitor: Visitor) {
        if !visitor.openInheritance(this)
            return
        type.accept(visitor)
        visitor.closeInheritance(this)
    }

    let type: Type
}
class Parser {
    constructor(theFileName: string, text: string) {
        lexer = new Lexer(text)
        fileName = theFileName
        classKeyword = new string("class")
        functionKeyword = new string("function")
        ifKeyword = new string("if")
        elseKeyword = new string("else")
        switchKeyword = new string("switch")
        caseKeyword = new string("case")
        defaultKeyword = new string("default")
        catchKeyword = new string("catch")
        forKeyword = new string("for")
        inKeyword = new string("in")
        whileKeyword = new string("while")
        doKeyword = new string("do")
        returnKeyword = new string("return")
        throwKeyword = new string("throw")
        breakKeyword = new string("break")
        throwsKeyword = new string("throws")
        overrideKeyword = new string("override")
        staticKeyword = new string("static")
        letKeyword = new string("let")
        varKeyword = new string("var")
        mutableKeyword = new string("mutable")
        isKeyword = new string("is")
        asKeyword = new string("as")
        constructorKeyword = new string("constructor")
        enumKeyword = new string("enum")
        thisKeyword = new string("this")
        nullKeyword = new string("null")
        newKeyword = new string("new")
        extendsKeyword = new string("extends")
        equal = new string("=")
        comma = new string(",")
        leftParen = new string("(")
        rightParen = new string(")")
        leftCurly = new string("{")
        rightCurly = new string("}")
        leftBracket = new string("[")
        rightBracket = new string("]")
        colon = new string(":")
        dot = new string(".")
        underscore = new string("_")
        circumflex = new string("^")
        dollar = new string("$")
        at = new string("@")
        hash = new string("#")
        tilde = new string("~")
    }

    function parseCompilationUnit(): CompilationUnit throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let statements: Statement[] = parseStatementList() catch _ null
        if statements != null {
            if !isAtEnd() {
                let current: Position$ = lexer.getPosition()
                throw notAtEnd(new Position(current))
            }
        }
        let end: Position$ = lexer.getPosition()
        var ret: CompilationUnit = new CompilationUnit(statements, new Position(start), new Position(end))
        ret.fileName = fileName
        if statements != null {
            for item: Statement in statements
                item.parent = ret
        }

        return(ret)
    }

    function parseStatementList(): Statement[] throws ParserError {
        mutable ret: Statement[]$ = null
        while true {
            let node: Statement = parseStatement()
                catch _ break
            if ret == null
                ret = new Statement[]()
            ret.push(node)
        }

        return(ret)
    }

    function parseStatement(): Statement throws ParserError {
        mutable errors: ParserError[]$ = new ParserError[]()
        let start: Position$ = lexer.getPreviousPosition()

        {
            let node: Declaration = parseDeclaration() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: Expression = parseExpression() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        throw unableToParse(new Position(start), new ParserError[](errors))
    }

    function parseDeclaration(): Declaration throws ParserError {
        mutable errors: ParserError[]$ = new ParserError[]()
        let start: Position$ = lexer.getPreviousPosition()

        {
            let node: ConstantDeclaration = parseConstantDeclaration() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: VariableDeclaration = parseVariableDeclaration() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: MutableDeclaration = parseMutableDeclaration() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: FunctionDeclaration = parseFunctionDeclaration() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: EnumDeclaration = parseEnumDeclaration() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: ClassDeclaration = parseClassDeclaration() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: ConstructorDeclaration = parseConstructorDeclaration() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        throw unableToParse(new Position(start), new ParserError[](errors))
    }

    function parseExpression(): Expression throws ParserError {
        mutable errors: ParserError[]$ = new ParserError[]()
        let start: Position$ = lexer.getPreviousPosition()

        {
            let node: CodeBlock = parseCodeBlock() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: SimpleExpression = parseSimpleExpression() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        throw unableToParse(new Position(start), new ParserError[](errors))
    }

    function parseConstantDeclaration(): ConstantDeclaration throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startLet1: Position$ = lexer.getPreviousPosition()
        let successLet1: bool = lexer.parseKeyword(letKeyword)
        if successLet1
            lexer.advance()
        else
            throw keywordExpected(new Position(startLet1), new string(letKeyword))

        let initializer: BindingInitializer = parseBindingInitializer() catch _ (error)
            throw error
        let end: Position$ = lexer.getPosition()
        var ret: ConstantDeclaration = new ConstantDeclaration(initializer, new Position(start), new Position(end))
        initializer.parent = ret

        return(ret)
    }

    function parseVariableDeclaration(): VariableDeclaration throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startVar1: Position$ = lexer.getPreviousPosition()
        let successVar1: bool = lexer.parseKeyword(varKeyword)
        if successVar1
            lexer.advance()
        else
            throw keywordExpected(new Position(startVar1), new string(varKeyword))

        let initializer: BindingInitializer = parseBindingInitializer() catch _ (error)
            throw error
        let end: Position$ = lexer.getPosition()
        var ret: VariableDeclaration = new VariableDeclaration(initializer, new Position(start), new Position(end))
        initializer.parent = ret

        return(ret)
    }

    function parseMutableDeclaration(): MutableDeclaration throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startMutable1: Position$ = lexer.getPreviousPosition()
        let successMutable1: bool = lexer.parseKeyword(mutableKeyword)
        if successMutable1
            lexer.advance()
        else
            throw keywordExpected(new Position(startMutable1), new string(mutableKeyword))

        let initializer: BindingInitializer = parseBindingInitializer() catch _ (error)
            throw error
        let end: Position$ = lexer.getPosition()
        var ret: MutableDeclaration = new MutableDeclaration(initializer, new Position(start), new Position(end))
        initializer.parent = ret

        return(ret)
    }

    function parseFunctionDeclaration(): FunctionDeclaration throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let modifiers: Modifier[] = parseModifierList() catch _ null
        let startFunction2: Position$ = lexer.getPreviousPosition()
        let successFunction2: bool = lexer.parseKeyword(functionKeyword)
        if successFunction2
            lexer.advance()
        else
            throw keywordExpected(new Position(startFunction2), new string(functionKeyword))

        let startName: Position$ = lexer.getPreviousPosition()
        let name: string = lexer.parseIdentifier()
        if (name != null) && isIdentifier(name)
            lexer.advance()
        else
            throw identifierExpected(new Position(startName))

        let signature: FunctionSignature = parseFunctionSignature() catch _ (error)
            throw error
        let body: Expression = parseExpression() catch _ null
        let end: Position$ = lexer.getPosition()
        var ret: FunctionDeclaration = new FunctionDeclaration(modifiers, name, signature, body, new Position(start), new Position(end))
        if modifiers != null {
            for item: Modifier in modifiers
                item.parent = ret
        }
        signature.parent = ret
        if body != null
            body.parent = ret

        return(ret)
    }

    function parseEnumDeclaration(): EnumDeclaration throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startEnum1: Position$ = lexer.getPreviousPosition()
        let successEnum1: bool = lexer.parseKeyword(enumKeyword)
        if successEnum1
            lexer.advance()
        else
            throw keywordExpected(new Position(startEnum1), new string(enumKeyword))

        let startName: Position$ = lexer.getPreviousPosition()
        let name: string = lexer.parseIdentifier()
        if (name != null) && isIdentifier(name)
            lexer.advance()
        else
            throw identifierExpected(new Position(startName))

        let startLeftCurly3: Position$ = lexer.getPreviousPosition()
        let successLeftCurly3: bool = lexer.parsePunctuation(leftCurly)
        if successLeftCurly3
            lexer.advance()
        else
            throw punctuationExpected(new Position(startLeftCurly3), new string(leftCurly))

        let members: EnumMember[] = parseEnumMemberList() catch _ (error)
            throw error
        let startRightCurly5: Position$ = lexer.getPreviousPosition()
        let successRightCurly5: bool = lexer.parsePunctuation(rightCurly)
        if successRightCurly5
            lexer.advance()
        else
            throw punctuationExpected(new Position(startRightCurly5), new string(rightCurly))

        let end: Position$ = lexer.getPosition()
        var ret: EnumDeclaration = new EnumDeclaration(name, members, new Position(start), new Position(end))
        if members != null {
            for item: EnumMember in members
                item.parent = ret
        }

        return(ret)
    }

    function parseClassDeclaration(): ClassDeclaration throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startClass1: Position$ = lexer.getPreviousPosition()
        let successClass1: bool = lexer.parseKeyword(classKeyword)
        if successClass1
            lexer.advance()
        else
            throw keywordExpected(new Position(startClass1), new string(classKeyword))

        let startName: Position$ = lexer.getPreviousPosition()
        let name: string = lexer.parseIdentifier()
        if (name != null) && isIdentifier(name)
            lexer.advance()
        else
            throw identifierExpected(new Position(startName))

        let typeInheritanceClause: TypeInheritanceClause = parseTypeInheritanceClause() catch _ null
        let body: ClassBody = parseClassBody() catch _ null
        let end: Position$ = lexer.getPosition()
        var ret: ClassDeclaration = new ClassDeclaration(name, typeInheritanceClause, body, new Position(start), new Position(end))
        if typeInheritanceClause != null
            typeInheritanceClause.parent = ret
        if body != null
            body.parent = ret

        return(ret)
    }

    function parseConstructorDeclaration(): ConstructorDeclaration throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startConstructor1: Position$ = lexer.getPreviousPosition()
        let successConstructor1: bool = lexer.parseKeyword(constructorKeyword)
        if successConstructor1
            lexer.advance()
        else
            throw keywordExpected(new Position(startConstructor1), new string(constructorKeyword))

        let parameterClause: ParameterClause = parseParameterClause() catch _ (error)
            throw error
        let body: Expression = parseExpression() catch _ (error)
            throw error
        let end: Position$ = lexer.getPosition()
        var ret: ConstructorDeclaration = new ConstructorDeclaration(parameterClause, body, new Position(start), new Position(end))
        parameterClause.parent = ret
        body.parent = ret

        return(ret)
    }

    function parseCodeBlock(): CodeBlock throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startLeftCurly1: Position$ = lexer.getPreviousPosition()
        let successLeftCurly1: bool = lexer.parsePunctuation(leftCurly)
        if successLeftCurly1
            lexer.advance()
        else
            throw punctuationExpected(new Position(startLeftCurly1), new string(leftCurly))

        let statements: Statement[] = parseStatementList() catch _ (error)
            throw error
        let startRightCurly3: Position$ = lexer.getPreviousPosition()
        let successRightCurly3: bool = lexer.parsePunctuation(rightCurly)
        if successRightCurly3
            lexer.advance()
        else
            throw punctuationExpected(new Position(startRightCurly3), new string(rightCurly))

        let end: Position$ = lexer.getPosition()
        var ret: CodeBlock = new CodeBlock(statements, new Position(start), new Position(end))
        if statements != null {
            for item: Statement in statements
                item.parent = ret
        }

        return(ret)
    }

    function parseSimpleExpression(): SimpleExpression throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let prefixExpression: PrefixExpression = parsePrefixExpression() catch _ (error)
            throw error
        let binaryOps: BinaryOp[] = parseBinaryOpList() catch _ null
        let end: Position$ = lexer.getPosition()
        var ret: SimpleExpression = new SimpleExpression(prefixExpression, binaryOps, new Position(start), new Position(end))
        prefixExpression.parent = ret
        if binaryOps != null {
            for item: BinaryOp in binaryOps
                item.parent = ret
        }

        return(ret)
    }

    function parseInitializer(): Initializer throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startEqual1: Position$ = lexer.getPreviousPosition()
        let successEqual1: bool = lexer.parsePunctuation(equal)
        if successEqual1
            lexer.advance()
        else
            throw punctuationExpected(new Position(startEqual1), new string(equal))

        let expression: Expression = parseExpression() catch _ (error)
            throw error
        let end: Position$ = lexer.getPosition()
        var ret: Initializer = new Initializer(expression, new Position(start), new Position(end))
        expression.parent = ret

        return(ret)
    }

    function parseBindingInitializer(): BindingInitializer throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let initializer: PatternInitializer = parsePatternInitializer() catch _ (error)
            throw error
        let additionalInitializers: AdditionalInitializer[] = parseAdditionalInitializerList() catch _ null
        let end: Position$ = lexer.getPosition()
        var ret: BindingInitializer = new BindingInitializer(initializer, additionalInitializers, new Position(start), new Position(end))
        initializer.parent = ret
        if additionalInitializers != null {
            for item: AdditionalInitializer in additionalInitializers
                item.parent = ret
        }

        return(ret)
    }

    function parsePatternInitializerList(): PatternInitializer[] throws ParserError {
        mutable ret: PatternInitializer[]$ = null
        while true {
            let node: PatternInitializer = parsePatternInitializer()
                catch _ break
            if ret == null
                ret = new PatternInitializer[]()
            ret.push(node)
        }

        return(ret)
    }

    function parsePatternInitializer(): PatternInitializer throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let pattern: Pattern = parsePattern() catch _ (error)
            throw error
        let initializer: Initializer = parseInitializer() catch _ null
        let end: Position$ = lexer.getPosition()
        var ret: PatternInitializer = new PatternInitializer(pattern, initializer, new Position(start), new Position(end))
        pattern.parent = ret
        if initializer != null
            initializer.parent = ret

        return(ret)
    }

    function parseAdditionalInitializerList(): AdditionalInitializer[] throws ParserError {
        mutable ret: AdditionalInitializer[]$ = null
        while true {
            let node: AdditionalInitializer = parseAdditionalInitializer()
                catch _ break
            if ret == null
                ret = new AdditionalInitializer[]()
            ret.push(node)
        }

        return(ret)
    }

    function parseAdditionalInitializer(): AdditionalInitializer throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startComma1: Position$ = lexer.getPreviousPosition()
        let successComma1: bool = lexer.parsePunctuation(comma)
        if successComma1
            lexer.advance()
        else
            throw punctuationExpected(new Position(startComma1), new string(comma))

        let pattern: PatternInitializer = parsePatternInitializer() catch _ (error)
            throw error
        let end: Position$ = lexer.getPosition()
        var ret: AdditionalInitializer = new AdditionalInitializer(pattern, new Position(start), new Position(end))
        pattern.parent = ret

        return(ret)
    }

    function parseModifierList(): Modifier[] throws ParserError {
        mutable ret: Modifier[]$ = null
        while true {
            let node: Modifier = parseModifier()
                catch _ break
            if ret == null
                ret = new Modifier[]()
            ret.push(node)
        }

        return(ret)
    }

    function parseModifier(): Modifier throws ParserError {
        mutable errors: ParserError[]$ = new ParserError[]()
        let start: Position$ = lexer.getPreviousPosition()

        {
            let node: OverrideWord = parseOverrideWord() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: StaticWord = parseStaticWord() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        throw unableToParse(new Position(start), new ParserError[](errors))
    }

    function parseOverrideWord(): OverrideWord throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startOverride1: Position$ = lexer.getPreviousPosition()
        let successOverride1: bool = lexer.parseKeyword(overrideKeyword)
        if successOverride1
            lexer.advance()
        else
            throw keywordExpected(new Position(startOverride1), new string(overrideKeyword))

        let end: Position$ = lexer.getPosition()
        var ret: OverrideWord = new OverrideWord(new Position(start), new Position(end))

        return(ret)
    }

    function parseStaticWord(): StaticWord throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startStatic1: Position$ = lexer.getPreviousPosition()
        let successStatic1: bool = lexer.parseKeyword(staticKeyword)
        if successStatic1
            lexer.advance()
        else
            throw keywordExpected(new Position(startStatic1), new string(staticKeyword))

        let end: Position$ = lexer.getPosition()
        var ret: StaticWord = new StaticWord(new Position(start), new Position(end))

        return(ret)
    }

    function parseFunctionSignature(): FunctionSignature throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let parameterClause: ParameterClause = parseParameterClause() catch _ (error)
            throw error
        let result: FunctionResult = parseFunctionResult() catch _ null
        let throwsClause: ThrowsClause = parseThrowsClause() catch _ null
        let end: Position$ = lexer.getPosition()
        var ret: FunctionSignature = new FunctionSignature(parameterClause, result, throwsClause, new Position(start), new Position(end))
        parameterClause.parent = ret
        if result != null
            result.parent = ret
        if throwsClause != null
            throwsClause.parent = ret

        return(ret)
    }

    function parseFunctionResult(): FunctionResult throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startColon1: Position$ = lexer.getPreviousPosition()
        let successColon1: bool = lexer.parsePunctuation(colon)
        if successColon1
            lexer.advance()
        else
            throw punctuationExpected(new Position(startColon1), new string(colon))

        let resultType: Type = parseType() catch _ (error)
            throw error
        let end: Position$ = lexer.getPosition()
        var ret: FunctionResult = new FunctionResult(resultType, new Position(start), new Position(end))
        resultType.parent = ret

        return(ret)
    }

    function parseParameterClauseList(): ParameterClause[] throws ParserError {
        mutable ret: ParameterClause[]$ = null
        while true {
            let node: ParameterClause = parseParameterClause()
                catch _ break
            if ret == null
                ret = new ParameterClause[]()
            ret.push(node)
        }

        return(ret)
    }

    function parseParameterClause(): ParameterClause throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startLeftParen1: Position$ = lexer.getPreviousPosition()
        let successLeftParen1: bool = lexer.parsePunctuation(leftParen)
        if successLeftParen1
            lexer.advance()
        else
            throw punctuationExpected(new Position(startLeftParen1), new string(leftParen))

        let parameters: Parameter[] = parseParameterList() catch _ null
        let startRightParen3: Position$ = lexer.getPreviousPosition()
        let successRightParen3: bool = lexer.parsePunctuation(rightParen)
        if successRightParen3
            lexer.advance()
        else
            throw punctuationExpected(new Position(startRightParen3), new string(rightParen))

        let end: Position$ = lexer.getPosition()
        var ret: ParameterClause = new ParameterClause(parameters, new Position(start), new Position(end))
        if parameters != null {
            for item: Parameter in parameters
                item.parent = ret
        }

        return(ret)
    }

    function parseParameterList(): Parameter[] throws ParserError {
        mutable ret: Parameter[]$ = null
        while true {
            let node: Parameter = parseParameter()
                catch _ break
            if ret == null
                ret = new Parameter[]()
            ret.push(node)
        }

        return(ret)
    }

    function parseParameter(): Parameter throws ParserError {
        mutable errors: ParserError[]$ = new ParserError[]()
        let start: Position$ = lexer.getPreviousPosition()

        {
            let node: ConstParameter = parseConstParameter() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: VarParameter = parseVarParameter() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        throw unableToParse(new Position(start), new ParserError[](errors))
    }

    function parseConstParameter(): ConstParameter throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let successLet1: bool = lexer.parseKeyword(letKeyword)
        if successLet1
            lexer.advance()
        let startName: Position$ = lexer.getPreviousPosition()
        let name: string = lexer.parseIdentifier()
        if (name != null) && isIdentifier(name)
            lexer.advance()
        else
            throw identifierExpected(new Position(startName))

        let startColon3: Position$ = lexer.getPreviousPosition()
        let successColon3: bool = lexer.parsePunctuation(colon)
        if successColon3
            lexer.advance()
        else
            throw punctuationExpected(new Position(startColon3), new string(colon))

        let parameterType: Type = parseType() catch _ (error)
            throw error
        let successComma5: bool = lexer.parsePunctuation(comma)
        if successComma5
            lexer.advance()
        let end: Position$ = lexer.getPosition()
        var ret: ConstParameter = new ConstParameter(name, parameterType, new Position(start), new Position(end))
        parameterType.parent = ret

        return(ret)
    }

    function parseVarParameter(): VarParameter throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startMutable1: Position$ = lexer.getPreviousPosition()
        let successMutable1: bool = lexer.parseKeyword(mutableKeyword)
        if successMutable1
            lexer.advance()
        else
            throw keywordExpected(new Position(startMutable1), new string(mutableKeyword))

        let startName: Position$ = lexer.getPreviousPosition()
        let name: string = lexer.parseIdentifier()
        if (name != null) && isIdentifier(name)
            lexer.advance()
        else
            throw identifierExpected(new Position(startName))

        let startColon3: Position$ = lexer.getPreviousPosition()
        let successColon3: bool = lexer.parsePunctuation(colon)
        if successColon3
            lexer.advance()
        else
            throw punctuationExpected(new Position(startColon3), new string(colon))

        let parameterType: Type = parseType() catch _ (error)
            throw error
        let successComma5: bool = lexer.parsePunctuation(comma)
        if successComma5
            lexer.advance()
        let end: Position$ = lexer.getPosition()
        var ret: VarParameter = new VarParameter(name, parameterType, new Position(start), new Position(end))
        parameterType.parent = ret

        return(ret)
    }

    function parseThrowsClause(): ThrowsClause throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startThrows1: Position$ = lexer.getPreviousPosition()
        let successThrows1: bool = lexer.parseKeyword(throwsKeyword)
        if successThrows1
            lexer.advance()
        else
            throw keywordExpected(new Position(startThrows1), new string(throwsKeyword))

        let throwsType: Type = parseType() catch _ (error)
            throw error
        let end: Position$ = lexer.getPosition()
        var ret: ThrowsClause = new ThrowsClause(throwsType, new Position(start), new Position(end))
        throwsType.parent = ret

        return(ret)
    }

    function parseEnumMemberList(): EnumMember[] throws ParserError {
        mutable ret: EnumMember[]$ = null
        while true {
            let node: EnumMember = parseEnumMember()
                catch _ break
            if ret == null
                ret = new EnumMember[]()
            ret.push(node)
        }

        return(ret)
    }

    function parseEnumMember(): EnumMember throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startCase1: Position$ = lexer.getPreviousPosition()
        let successCase1: bool = lexer.parseKeyword(caseKeyword)
        if successCase1
            lexer.advance()
        else
            throw keywordExpected(new Position(startCase1), new string(caseKeyword))

        let enumCase: EnumCase = parseEnumCase() catch _ (error)
            throw error
        let additionalCases: AdditionalCase[] = parseAdditionalCaseList() catch _ null
        let parameterClause: ParameterClause = parseParameterClause() catch _ null
        let end: Position$ = lexer.getPosition()
        var ret: EnumMember = new EnumMember(enumCase, additionalCases, parameterClause, new Position(start), new Position(end))
        enumCase.parent = ret
        if additionalCases != null {
            for item: AdditionalCase in additionalCases
                item.parent = ret
        }
        if parameterClause != null
            parameterClause.parent = ret

        return(ret)
    }

    function parseEnumCase(): EnumCase throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startName: Position$ = lexer.getPreviousPosition()
        let name: string = lexer.parseIdentifier()
        if (name != null) && isIdentifier(name)
            lexer.advance()
        else
            throw identifierExpected(new Position(startName))

        let end: Position$ = lexer.getPosition()
        var ret: EnumCase = new EnumCase(name, new Position(start), new Position(end))

        return(ret)
    }

    function parseAdditionalCaseList(): AdditionalCase[] throws ParserError {
        mutable ret: AdditionalCase[]$ = null
        while true {
            let node: AdditionalCase = parseAdditionalCase()
                catch _ break
            if ret == null
                ret = new AdditionalCase[]()
            ret.push(node)
        }

        return(ret)
    }

    function parseAdditionalCase(): AdditionalCase throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startComma1: Position$ = lexer.getPreviousPosition()
        let successComma1: bool = lexer.parsePunctuation(comma)
        if successComma1
            lexer.advance()
        else
            throw punctuationExpected(new Position(startComma1), new string(comma))

        let enumCase: EnumCase = parseEnumCase() catch _ (error)
            throw error
        let end: Position$ = lexer.getPosition()
        var ret: AdditionalCase = new AdditionalCase(enumCase, new Position(start), new Position(end))
        enumCase.parent = ret

        return(ret)
    }

    function parseClassBody(): ClassBody throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startLeftCurly1: Position$ = lexer.getPreviousPosition()
        let successLeftCurly1: bool = lexer.parsePunctuation(leftCurly)
        if successLeftCurly1
            lexer.advance()
        else
            throw punctuationExpected(new Position(startLeftCurly1), new string(leftCurly))

        let members: ClassMember[] = parseClassMemberList() catch _ null
        let startRightCurly3: Position$ = lexer.getPreviousPosition()
        let successRightCurly3: bool = lexer.parsePunctuation(rightCurly)
        if successRightCurly3
            lexer.advance()
        else
            throw punctuationExpected(new Position(startRightCurly3), new string(rightCurly))

        let end: Position$ = lexer.getPosition()
        var ret: ClassBody = new ClassBody(members, new Position(start), new Position(end))
        if members != null {
            for item: ClassMember in members
                item.parent = ret
        }

        return(ret)
    }

    function parseClassMemberList(): ClassMember[] throws ParserError {
        mutable ret: ClassMember[]$ = null
        while true {
            let node: ClassMember = parseClassMember()
                catch _ break
            if ret == null
                ret = new ClassMember[]()
            ret.push(node)
        }

        return(ret)
    }

    function parseClassMember(): ClassMember throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let declaration: Declaration = parseDeclaration() catch _ (error)
            throw error
        let end: Position$ = lexer.getPosition()
        var ret: ClassMember = new ClassMember(declaration, new Position(start), new Position(end))
        declaration.parent = ret

        return(ret)
    }

    function parsePrefixExpression(): PrefixExpression throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let prefixOperator: string = lexer.parsePrefixOperator()
        if prefixOperator != null
            lexer.advance()
        let expression: PostfixExpression = parsePostfixExpression() catch _ (error)
            throw error
        let end: Position$ = lexer.getPosition()
        var ret: PrefixExpression = new PrefixExpression(prefixOperator, expression, new Position(start), new Position(end))
        expression.parent = ret

        return(ret)
    }

    function parsePostfixExpression(): PostfixExpression throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let primaryExpression: PrimaryExpression = parsePrimaryExpression() catch _ (error)
            throw error
        let postfixes: Postfix[] = parsePostfixList() catch _ null
        let end: Position$ = lexer.getPosition()
        var ret: PostfixExpression = new PostfixExpression(primaryExpression, postfixes, new Position(start), new Position(end))
        primaryExpression.parent = ret
        if postfixes != null {
            for item: Postfix in postfixes
                item.parent = ret
        }

        return(ret)
    }

    function parseBinaryOpList(): BinaryOp[] throws ParserError {
        mutable ret: BinaryOp[]$ = null
        while true {
            let node: BinaryOp = parseBinaryOp()
                catch _ break
            if ret == null
                ret = new BinaryOp[]()
            ret.push(node)
        }

        return(ret)
    }

    function parseBinaryOp(): BinaryOp throws ParserError {
        mutable errors: ParserError[]$ = new ParserError[]()
        let start: Position$ = lexer.getPreviousPosition()

        {
            let node: BinaryOperation = parseBinaryOperation() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: Assignment = parseAssignment() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: TypeQuery = parseTypeQuery() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: TypeCast = parseTypeCast() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        throw unableToParse(new Position(start), new ParserError[](errors))
    }

    function parseBinaryOperation(): BinaryOperation throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startBinaryOperator: Position$ = lexer.getPreviousPosition()
        let binaryOperator: string = lexer.parseBinaryOperator()
        if binaryOperator != null
            lexer.advance()
        else
            throw operatorExpected(new Position(startBinaryOperator))

        let expression: PrefixExpression = parsePrefixExpression() catch _ (error)
            throw error
        let end: Position$ = lexer.getPosition()
        var ret: BinaryOperation = new BinaryOperation(binaryOperator, expression, new Position(start), new Position(end))
        expression.parent = ret

        return(ret)
    }

    function parseAssignment(): Assignment throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startEqual1: Position$ = lexer.getPreviousPosition()
        let successEqual1: bool = lexer.parsePunctuation(equal)
        if successEqual1
            lexer.advance()
        else
            throw punctuationExpected(new Position(startEqual1), new string(equal))

        let expression: Expression = parseExpression() catch _ (error)
            throw error
        let end: Position$ = lexer.getPosition()
        var ret: Assignment = new Assignment(expression, new Position(start), new Position(end))
        expression.parent = ret

        return(ret)
    }

    function parseTypeQuery(): TypeQuery throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startIs1: Position$ = lexer.getPreviousPosition()
        let successIs1: bool = lexer.parseKeyword(isKeyword)
        if successIs1
            lexer.advance()
        else
            throw keywordExpected(new Position(startIs1), new string(isKeyword))

        let objectType: Type = parseType() catch _ (error)
            throw error
        let end: Position$ = lexer.getPosition()
        var ret: TypeQuery = new TypeQuery(objectType, new Position(start), new Position(end))
        objectType.parent = ret

        return(ret)
    }

    function parseTypeCast(): TypeCast throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startAs1: Position$ = lexer.getPreviousPosition()
        let successAs1: bool = lexer.parseKeyword(asKeyword)
        if successAs1
            lexer.advance()
        else
            throw keywordExpected(new Position(startAs1), new string(asKeyword))

        let objectType: Type = parseType() catch _ (error)
            throw error
        let end: Position$ = lexer.getPosition()
        var ret: TypeCast = new TypeCast(objectType, new Position(start), new Position(end))
        objectType.parent = ret

        return(ret)
    }

    function parseCatchClauseList(): CatchClause[] throws ParserError {
        mutable ret: CatchClause[]$ = null
        while true {
            let node: CatchClause = parseCatchClause()
                catch _ break
            if ret == null
                ret = new CatchClause[]()
            ret.push(node)
        }

        return(ret)
    }

    function parseCatchClause(): CatchClause throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startCatch1: Position$ = lexer.getPreviousPosition()
        let successCatch1: bool = lexer.parseKeyword(catchKeyword)
        if successCatch1
            lexer.advance()
        else
            throw keywordExpected(new Position(startCatch1), new string(catchKeyword))

        let catchPattern: CatchPattern = parseCatchPattern() catch _ (error)
            throw error
        let bindingPattern: TuplePattern = parseTuplePattern() catch _ null
        let expression: Expression = parseExpression() catch _ (error)
            throw error
        let end: Position$ = lexer.getPosition()
        var ret: CatchClause = new CatchClause(catchPattern, bindingPattern, expression, new Position(start), new Position(end))
        catchPattern.parent = ret
        if bindingPattern != null
            bindingPattern.parent = ret
        expression.parent = ret

        return(ret)
    }

    function parseCatchPattern(): CatchPattern throws ParserError {
        mutable errors: ParserError[]$ = new ParserError[]()
        let start: Position$ = lexer.getPreviousPosition()

        {
            let node: WildCardCatchPattern = parseWildCardCatchPattern() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: IdentifierCatchPattern = parseIdentifierCatchPattern() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        throw unableToParse(new Position(start), new ParserError[](errors))
    }

    function parseWildCardCatchPattern(): WildCardCatchPattern throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let pattern: WildcardPattern = parseWildcardPattern() catch _ (error)
            throw error
        let end: Position$ = lexer.getPosition()
        var ret: WildCardCatchPattern = new WildCardCatchPattern(pattern, new Position(start), new Position(end))
        pattern.parent = ret

        return(ret)
    }

    function parseIdentifierCatchPattern(): IdentifierCatchPattern throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startName: Position$ = lexer.getPreviousPosition()
        let name: string = lexer.parseIdentifier()
        if (name != null) && isIdentifier(name)
            lexer.advance()
        else
            throw identifierExpected(new Position(startName))

        let member: MemberExpression = parseMemberExpression() catch _ null
        let end: Position$ = lexer.getPosition()
        var ret: IdentifierCatchPattern = new IdentifierCatchPattern(name, member, new Position(start), new Position(end))
        if member != null
            member.parent = ret

        return(ret)
    }

    function parsePostfixList(): Postfix[] throws ParserError {
        mutable ret: Postfix[]$ = null
        while true {
            let node: Postfix = parsePostfix()
                catch _ break
            if ret == null
                ret = new Postfix[]()
            ret.push(node)
        }

        return(ret)
    }

    function parsePostfix(): Postfix throws ParserError {
        mutable errors: ParserError[]$ = new ParserError[]()
        let start: Position$ = lexer.getPreviousPosition()

        {
            let node: OperatorPostfix = parseOperatorPostfix() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: FunctionCall = parseFunctionCall() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: MemberExpression = parseMemberExpression() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: Subscript = parseSubscript() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        throw unableToParse(new Position(start), new ParserError[](errors))
    }

    function parseOperatorPostfix(): OperatorPostfix throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startPostfixOperator: Position$ = lexer.getPreviousPosition()
        let postfixOperator: string = lexer.parsePostfixOperator()
        if postfixOperator != null
            lexer.advance()
        else
            throw operatorExpected(new Position(startPostfixOperator))

        let end: Position$ = lexer.getPosition()
        var ret: OperatorPostfix = new OperatorPostfix(postfixOperator, new Position(start), new Position(end))

        return(ret)
    }

    function parseFunctionCall(): FunctionCall throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let arguments: ParenthesizedExpression = parseParenthesizedExpression() catch _ (error)
            throw error
        let catchClauses: CatchClause[] = parseCatchClauseList() catch _ null
        let end: Position$ = lexer.getPosition()
        var ret: FunctionCall = new FunctionCall(arguments, catchClauses, new Position(start), new Position(end))
        arguments.parent = ret
        if catchClauses != null {
            for item: CatchClause in catchClauses
                item.parent = ret
        }

        return(ret)
    }

    function parseMemberExpression(): MemberExpression throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startDot1: Position$ = lexer.getPreviousPosition()
        let successDot1: bool = lexer.parsePunctuation(dot)
        if successDot1
            lexer.advance()
        else
            throw punctuationExpected(new Position(startDot1), new string(dot))

        let startMember: Position$ = lexer.getPreviousPosition()
        let member: string = lexer.parseIdentifier()
        if (member != null) && isIdentifier(member)
            lexer.advance()
        else
            throw identifierExpected(new Position(startMember))

        let end: Position$ = lexer.getPosition()
        var ret: MemberExpression = new MemberExpression(member, new Position(start), new Position(end))

        return(ret)
    }

    function parseSubscript(): Subscript throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startLeftBracket1: Position$ = lexer.getPreviousPosition()
        let successLeftBracket1: bool = lexer.parsePunctuation(leftBracket)
        if successLeftBracket1
            lexer.advance()
        else
            throw punctuationExpected(new Position(startLeftBracket1), new string(leftBracket))

        let expressions: ExpressionElement[] = parseExpressionElementList() catch _ (error)
            throw error
        let startRightBracket3: Position$ = lexer.getPreviousPosition()
        let successRightBracket3: bool = lexer.parsePunctuation(rightBracket)
        if successRightBracket3
            lexer.advance()
        else
            throw punctuationExpected(new Position(startRightBracket3), new string(rightBracket))

        let end: Position$ = lexer.getPosition()
        var ret: Subscript = new Subscript(expressions, new Position(start), new Position(end))
        if expressions != null {
            for item: ExpressionElement in expressions
                item.parent = ret
        }

        return(ret)
    }

    function parseExpressionElementList(): ExpressionElement[] throws ParserError {
        mutable ret: ExpressionElement[]$ = null
        while true {
            let node: ExpressionElement = parseExpressionElement()
                catch _ break
            if ret == null
                ret = new ExpressionElement[]()
            ret.push(node)
        }

        return(ret)
    }

    function parseExpressionElement(): ExpressionElement throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let expression: Expression = parseExpression() catch _ (error)
            throw error
        let successComma2: bool = lexer.parsePunctuation(comma)
        if successComma2
            lexer.advance()
        let end: Position$ = lexer.getPosition()
        var ret: ExpressionElement = new ExpressionElement(expression, new Position(start), new Position(end))
        expression.parent = ret

        return(ret)
    }

    function parsePrimaryExpression(): PrimaryExpression throws ParserError {
        mutable errors: ParserError[]$ = new ParserError[]()
        let start: Position$ = lexer.getPreviousPosition()

        {
            let node: IdentifierExpression = parseIdentifierExpression() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: LiteralExpression = parseLiteralExpression() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: IfExpression = parseIfExpression() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: SwitchExpression = parseSwitchExpression() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: ForExpression = parseForExpression() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: WhileExpression = parseWhileExpression() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: DoExpression = parseDoExpression() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: ParenthesizedExpression = parseParenthesizedExpression() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: ReturnExpression = parseReturnExpression() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: ThrowExpression = parseThrowExpression() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: BreakExpression = parseBreakExpression() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: ConstructorCall = parseConstructorCall() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: ThisExpression = parseThisExpression() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: NullExpression = parseNullExpression() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        throw unableToParse(new Position(start), new ParserError[](errors))
    }

    function parseIdentifierExpression(): IdentifierExpression throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startName: Position$ = lexer.getPreviousPosition()
        let name: string = lexer.parseIdentifier()
        if (name != null) && isIdentifier(name)
            lexer.advance()
        else
            throw identifierExpected(new Position(startName))

        let end: Position$ = lexer.getPosition()
        var ret: IdentifierExpression = new IdentifierExpression(name, new Position(start), new Position(end))

        return(ret)
    }

    function parseLiteralExpression(): LiteralExpression throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startLiteral: Position$ = lexer.getPreviousPosition()
        let literal: Literal = lexer.parseLiteral()
        if literal != null
            lexer.advance()
        else
            throw literalExpected(new Position(startLiteral))

        let end: Position$ = lexer.getPosition()
        var ret: LiteralExpression = new LiteralExpression(literal, new Position(start), new Position(end))

        return(ret)
    }

    function parseIfExpression(): IfExpression throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startIf1: Position$ = lexer.getPreviousPosition()
        let successIf1: bool = lexer.parseKeyword(ifKeyword)
        if successIf1
            lexer.advance()
        else
            throw keywordExpected(new Position(startIf1), new string(ifKeyword))

        let condition: Expression = parseExpression() catch _ (error)
            throw error
        let consequent: Expression = parseExpression() catch _ (error)
            throw error
        let elseClause: ElseClause = parseElseClause() catch _ null
        let end: Position$ = lexer.getPosition()
        var ret: IfExpression = new IfExpression(condition, consequent, elseClause, new Position(start), new Position(end))
        condition.parent = ret
        consequent.parent = ret
        if elseClause != null
            elseClause.parent = ret

        return(ret)
    }

    function parseSwitchExpression(): SwitchExpression throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startSwitch1: Position$ = lexer.getPreviousPosition()
        let successSwitch1: bool = lexer.parseKeyword(switchKeyword)
        if successSwitch1
            lexer.advance()
        else
            throw keywordExpected(new Position(startSwitch1), new string(switchKeyword))

        let expression: Expression = parseExpression() catch _ (error)
            throw error
        let body: SwitchBody = parseSwitchBody() catch _ (error)
            throw error
        let end: Position$ = lexer.getPosition()
        var ret: SwitchExpression = new SwitchExpression(expression, body, new Position(start), new Position(end))
        expression.parent = ret
        body.parent = ret

        return(ret)
    }

    function parseForExpression(): ForExpression throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startFor1: Position$ = lexer.getPreviousPosition()
        let successFor1: bool = lexer.parseKeyword(forKeyword)
        if successFor1
            lexer.advance()
        else
            throw keywordExpected(new Position(startFor1), new string(forKeyword))

        let pattern: Pattern = parsePattern() catch _ (error)
            throw error
        let startIn3: Position$ = lexer.getPreviousPosition()
        let successIn3: bool = lexer.parseKeyword(inKeyword)
        if successIn3
            lexer.advance()
        else
            throw keywordExpected(new Position(startIn3), new string(inKeyword))

        let expression: Expression = parseExpression() catch _ (error)
            throw error
        let code: Expression = parseExpression() catch _ (error)
            throw error
        let end: Position$ = lexer.getPosition()
        var ret: ForExpression = new ForExpression(pattern, expression, code, new Position(start), new Position(end))
        pattern.parent = ret
        expression.parent = ret
        code.parent = ret

        return(ret)
    }

    function parseWhileExpression(): WhileExpression throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startWhile1: Position$ = lexer.getPreviousPosition()
        let successWhile1: bool = lexer.parseKeyword(whileKeyword)
        if successWhile1
            lexer.advance()
        else
            throw keywordExpected(new Position(startWhile1), new string(whileKeyword))

        let condition: Expression = parseExpression() catch _ (error)
            throw error
        let code: Expression = parseExpression() catch _ (error)
            throw error
        let end: Position$ = lexer.getPosition()
        var ret: WhileExpression = new WhileExpression(condition, code, new Position(start), new Position(end))
        condition.parent = ret
        code.parent = ret

        return(ret)
    }

    function parseDoExpression(): DoExpression throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startDo1: Position$ = lexer.getPreviousPosition()
        let successDo1: bool = lexer.parseKeyword(doKeyword)
        if successDo1
            lexer.advance()
        else
            throw keywordExpected(new Position(startDo1), new string(doKeyword))

        let code: Expression = parseExpression() catch _ (error)
            throw error
        let startWhile3: Position$ = lexer.getPreviousPosition()
        let successWhile3: bool = lexer.parseKeyword(whileKeyword)
        if successWhile3
            lexer.advance()
        else
            throw keywordExpected(new Position(startWhile3), new string(whileKeyword))

        let condition: Expression = parseExpression() catch _ (error)
            throw error
        let end: Position$ = lexer.getPosition()
        var ret: DoExpression = new DoExpression(code, condition, new Position(start), new Position(end))
        code.parent = ret
        condition.parent = ret

        return(ret)
    }

    function parseParenthesizedExpression(): ParenthesizedExpression throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startLeftParen1: Position$ = lexer.getPreviousPosition()
        let successLeftParen1: bool = lexer.parsePunctuation(leftParen)
        if successLeftParen1
            lexer.advance()
        else
            throw punctuationExpected(new Position(startLeftParen1), new string(leftParen))

        let expressionElements: ExpressionElement[] = parseExpressionElementList() catch _ null
        let startRightParen3: Position$ = lexer.getPreviousPosition()
        let successRightParen3: bool = lexer.parsePunctuation(rightParen)
        if successRightParen3
            lexer.advance()
        else
            throw punctuationExpected(new Position(startRightParen3), new string(rightParen))

        let end: Position$ = lexer.getPosition()
        var ret: ParenthesizedExpression = new ParenthesizedExpression(expressionElements, new Position(start), new Position(end))
        if expressionElements != null {
            for item: ExpressionElement in expressionElements
                item.parent = ret
        }

        return(ret)
    }

    function parseReturnExpression(): ReturnExpression throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startReturn1: Position$ = lexer.getPreviousPosition()
        let successReturn1: bool = lexer.parseKeyword(returnKeyword)
        if successReturn1
            lexer.advance()
        else
            throw keywordExpected(new Position(startReturn1), new string(returnKeyword))

        let expression: ParenthesizedExpression = parseParenthesizedExpression() catch _ null
        let end: Position$ = lexer.getPosition()
        var ret: ReturnExpression = new ReturnExpression(expression, new Position(start), new Position(end))
        if expression != null
            expression.parent = ret

        return(ret)
    }

    function parseThrowExpression(): ThrowExpression throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startThrow1: Position$ = lexer.getPreviousPosition()
        let successThrow1: bool = lexer.parseKeyword(throwKeyword)
        if successThrow1
            lexer.advance()
        else
            throw keywordExpected(new Position(startThrow1), new string(throwKeyword))

        let error: IdentifierExpression = parseIdentifierExpression() catch _ (error)
            throw error
        let arguments: ParenthesizedExpression = parseParenthesizedExpression() catch _ null
        let end: Position$ = lexer.getPosition()
        var ret: ThrowExpression = new ThrowExpression(error, arguments, new Position(start), new Position(end))
        error.parent = ret
        if arguments != null
            arguments.parent = ret

        return(ret)
    }

    function parseBreakExpression(): BreakExpression throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startBreak1: Position$ = lexer.getPreviousPosition()
        let successBreak1: bool = lexer.parseKeyword(breakKeyword)
        if successBreak1
            lexer.advance()
        else
            throw keywordExpected(new Position(startBreak1), new string(breakKeyword))

        let expression: ParenthesizedExpression = parseParenthesizedExpression() catch _ null
        let end: Position$ = lexer.getPosition()
        var ret: BreakExpression = new BreakExpression(expression, new Position(start), new Position(end))
        if expression != null
            expression.parent = ret

        return(ret)
    }

    function parseConstructorCall(): ConstructorCall throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startNew1: Position$ = lexer.getPreviousPosition()
        let successNew1: bool = lexer.parseKeyword(newKeyword)
        if successNew1
            lexer.advance()
        else
            throw keywordExpected(new Position(startNew1), new string(newKeyword))

        let typeToInitialize: Type = parseType() catch _ (error)
            throw error
        let arguments: ParenthesizedExpression = parseParenthesizedExpression() catch _ (error)
            throw error
        let catchClauses: CatchClause[] = parseCatchClauseList() catch _ null
        let end: Position$ = lexer.getPosition()
        var ret: ConstructorCall = new ConstructorCall(typeToInitialize, arguments, catchClauses, new Position(start), new Position(end))
        typeToInitialize.parent = ret
        arguments.parent = ret
        if catchClauses != null {
            for item: CatchClause in catchClauses
                item.parent = ret
        }

        return(ret)
    }

    function parseThisExpression(): ThisExpression throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startThis1: Position$ = lexer.getPreviousPosition()
        let successThis1: bool = lexer.parseKeyword(thisKeyword)
        if successThis1
            lexer.advance()
        else
            throw keywordExpected(new Position(startThis1), new string(thisKeyword))

        let end: Position$ = lexer.getPosition()
        var ret: ThisExpression = new ThisExpression(new Position(start), new Position(end))

        return(ret)
    }

    function parseNullExpression(): NullExpression throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startNull1: Position$ = lexer.getPreviousPosition()
        let successNull1: bool = lexer.parseKeyword(nullKeyword)
        if successNull1
            lexer.advance()
        else
            throw keywordExpected(new Position(startNull1), new string(nullKeyword))

        let end: Position$ = lexer.getPosition()
        var ret: NullExpression = new NullExpression(new Position(start), new Position(end))

        return(ret)
    }

    function parseElseClause(): ElseClause throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startElse1: Position$ = lexer.getPreviousPosition()
        let successElse1: bool = lexer.parseKeyword(elseKeyword)
        if successElse1
            lexer.advance()
        else
            throw keywordExpected(new Position(startElse1), new string(elseKeyword))

        let alternative: Expression = parseExpression() catch _ (error)
            throw error
        let end: Position$ = lexer.getPosition()
        var ret: ElseClause = new ElseClause(alternative, new Position(start), new Position(end))
        alternative.parent = ret

        return(ret)
    }

    function parseSwitchBody(): SwitchBody throws ParserError {
        mutable errors: ParserError[]$ = new ParserError[]()
        let start: Position$ = lexer.getPreviousPosition()

        {
            let node: CurliedSwitchBody = parseCurliedSwitchBody() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: NakedSwitchBody = parseNakedSwitchBody() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        throw unableToParse(new Position(start), new ParserError[](errors))
    }

    function parseCurliedSwitchBody(): CurliedSwitchBody throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startLeftCurly1: Position$ = lexer.getPreviousPosition()
        let successLeftCurly1: bool = lexer.parsePunctuation(leftCurly)
        if successLeftCurly1
            lexer.advance()
        else
            throw punctuationExpected(new Position(startLeftCurly1), new string(leftCurly))

        let cases: SwitchCase[] = parseSwitchCaseList() catch _ (error)
            throw error
        let startRightCurly3: Position$ = lexer.getPreviousPosition()
        let successRightCurly3: bool = lexer.parsePunctuation(rightCurly)
        if successRightCurly3
            lexer.advance()
        else
            throw punctuationExpected(new Position(startRightCurly3), new string(rightCurly))

        let end: Position$ = lexer.getPosition()
        var ret: CurliedSwitchBody = new CurliedSwitchBody(cases, new Position(start), new Position(end))
        if cases != null {
            for item: SwitchCase in cases
                item.parent = ret
        }

        return(ret)
    }

    function parseNakedSwitchBody(): NakedSwitchBody throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let cases: SwitchCase[] = parseSwitchCaseList() catch _ (error)
            throw error
        let end: Position$ = lexer.getPosition()
        var ret: NakedSwitchBody = new NakedSwitchBody(cases, new Position(start), new Position(end))
        if cases != null {
            for item: SwitchCase in cases
                item.parent = ret
        }

        return(ret)
    }

    function parseSwitchCaseList(): SwitchCase[] throws ParserError {
        mutable ret: SwitchCase[]$ = null
        while true {
            let node: SwitchCase = parseSwitchCase()
                catch _ break
            if ret == null
                ret = new SwitchCase[]()
            ret.push(node)
        }

        return(ret)
    }

    function parseSwitchCase(): SwitchCase throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let label: CaseLabel = parseCaseLabel() catch _ (error)
            throw error
        let content: CaseContent = parseCaseContent() catch _ (error)
            throw error
        let end: Position$ = lexer.getPosition()
        var ret: SwitchCase = new SwitchCase(label, content, new Position(start), new Position(end))
        label.parent = ret
        content.parent = ret

        return(ret)
    }

    function parseCaseLabel(): CaseLabel throws ParserError {
        mutable errors: ParserError[]$ = new ParserError[]()
        let start: Position$ = lexer.getPreviousPosition()

        {
            let node: ItemCaseLabel = parseItemCaseLabel() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: DefaultCaseLabel = parseDefaultCaseLabel() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        throw unableToParse(new Position(start), new ParserError[](errors))
    }

    function parseItemCaseLabel(): ItemCaseLabel throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startCase1: Position$ = lexer.getPreviousPosition()
        let successCase1: bool = lexer.parseKeyword(caseKeyword)
        if successCase1
            lexer.advance()
        else
            throw keywordExpected(new Position(startCase1), new string(caseKeyword))

        let pattern: Pattern = parsePattern() catch _ (error)
            throw error
        let additionalPatterns: CaseItem[] = parseCaseItemList() catch _ null
        let startColon4: Position$ = lexer.getPreviousPosition()
        let successColon4: bool = lexer.parsePunctuation(colon)
        if successColon4
            lexer.advance()
        else
            throw punctuationExpected(new Position(startColon4), new string(colon))

        let end: Position$ = lexer.getPosition()
        var ret: ItemCaseLabel = new ItemCaseLabel(pattern, additionalPatterns, new Position(start), new Position(end))
        pattern.parent = ret
        if additionalPatterns != null {
            for item: CaseItem in additionalPatterns
                item.parent = ret
        }

        return(ret)
    }

    function parseDefaultCaseLabel(): DefaultCaseLabel throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startDefault1: Position$ = lexer.getPreviousPosition()
        let successDefault1: bool = lexer.parseKeyword(defaultKeyword)
        if successDefault1
            lexer.advance()
        else
            throw keywordExpected(new Position(startDefault1), new string(defaultKeyword))

        let startColon2: Position$ = lexer.getPreviousPosition()
        let successColon2: bool = lexer.parsePunctuation(colon)
        if successColon2
            lexer.advance()
        else
            throw punctuationExpected(new Position(startColon2), new string(colon))

        let end: Position$ = lexer.getPosition()
        var ret: DefaultCaseLabel = new DefaultCaseLabel(new Position(start), new Position(end))

        return(ret)
    }

    function parseCaseItemList(): CaseItem[] throws ParserError {
        mutable ret: CaseItem[]$ = null
        while true {
            let node: CaseItem = parseCaseItem()
                catch _ break
            if ret == null
                ret = new CaseItem[]()
            ret.push(node)
        }

        return(ret)
    }

    function parseCaseItem(): CaseItem throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startComma1: Position$ = lexer.getPreviousPosition()
        let successComma1: bool = lexer.parsePunctuation(comma)
        if successComma1
            lexer.advance()
        else
            throw punctuationExpected(new Position(startComma1), new string(comma))

        let pattern: Pattern = parsePattern() catch _ (error)
            throw error
        let end: Position$ = lexer.getPosition()
        var ret: CaseItem = new CaseItem(pattern, new Position(start), new Position(end))
        pattern.parent = ret

        return(ret)
    }

    function parsePattern(): Pattern throws ParserError {
        mutable errors: ParserError[]$ = new ParserError[]()
        let start: Position$ = lexer.getPreviousPosition()

        {
            let node: WildcardPattern = parseWildcardPattern() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: IdentifierPattern = parseIdentifierPattern() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: TuplePattern = parseTuplePattern() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: ExpressionPattern = parseExpressionPattern() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        throw unableToParse(new Position(start), new ParserError[](errors))
    }

    function parseWildcardPattern(): WildcardPattern throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startUnderscore1: Position$ = lexer.getPreviousPosition()
        let successUnderscore1: bool = lexer.parsePunctuation(underscore)
        if successUnderscore1
            lexer.advance()
        else
            throw punctuationExpected(new Position(startUnderscore1), new string(underscore))

        let end: Position$ = lexer.getPosition()
        var ret: WildcardPattern = new WildcardPattern(new Position(start), new Position(end))

        return(ret)
    }

    function parseIdentifierPattern(): IdentifierPattern throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startIdentifier: Position$ = lexer.getPreviousPosition()
        let identifier: string = lexer.parseIdentifier()
        if (identifier != null) && isIdentifier(identifier)
            lexer.advance()
        else
            throw identifierExpected(new Position(startIdentifier))

        let annotationForType: TypeAnnotation = parseTypeAnnotation() catch _ null
        let end: Position$ = lexer.getPosition()
        var ret: IdentifierPattern = new IdentifierPattern(identifier, annotationForType, new Position(start), new Position(end))
        if annotationForType != null
            annotationForType.parent = ret

        return(ret)
    }

    function parseTuplePattern(): TuplePattern throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startLeftParen1: Position$ = lexer.getPreviousPosition()
        let successLeftParen1: bool = lexer.parsePunctuation(leftParen)
        if successLeftParen1
            lexer.advance()
        else
            throw punctuationExpected(new Position(startLeftParen1), new string(leftParen))

        let elements: TuplePatternElement[] = parseTuplePatternElementList() catch _ (error)
            throw error
        let startRightParen3: Position$ = lexer.getPreviousPosition()
        let successRightParen3: bool = lexer.parsePunctuation(rightParen)
        if successRightParen3
            lexer.advance()
        else
            throw punctuationExpected(new Position(startRightParen3), new string(rightParen))

        let end: Position$ = lexer.getPosition()
        var ret: TuplePattern = new TuplePattern(elements, new Position(start), new Position(end))
        if elements != null {
            for item: TuplePatternElement in elements
                item.parent = ret
        }

        return(ret)
    }

    function parseExpressionPattern(): ExpressionPattern throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let expression: Expression = parseExpression() catch _ (error)
            throw error
        let end: Position$ = lexer.getPosition()
        var ret: ExpressionPattern = new ExpressionPattern(expression, new Position(start), new Position(end))
        expression.parent = ret

        return(ret)
    }

    function parseTuplePatternElementList(): TuplePatternElement[] throws ParserError {
        mutable ret: TuplePatternElement[]$ = null
        while true {
            let node: TuplePatternElement = parseTuplePatternElement()
                catch _ break
            if ret == null
                ret = new TuplePatternElement[]()
            ret.push(node)
        }

        return(ret)
    }

    function parseTuplePatternElement(): TuplePatternElement throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let pattern: Pattern = parsePattern() catch _ (error)
            throw error
        let successComma2: bool = lexer.parsePunctuation(comma)
        if successComma2
            lexer.advance()
        let end: Position$ = lexer.getPosition()
        var ret: TuplePatternElement = new TuplePatternElement(pattern, new Position(start), new Position(end))
        pattern.parent = ret

        return(ret)
    }

    function parseCaseContent(): CaseContent throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let statements: Statement[] = parseStatementList() catch _ (error)
            throw error
        let end: Position$ = lexer.getPosition()
        var ret: CaseContent = new CaseContent(statements, new Position(start), new Position(end))
        if statements != null {
            for item: Statement in statements
                item.parent = ret
        }

        return(ret)
    }

    function parseType(): Type throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startName: Position$ = lexer.getPreviousPosition()
        let name: string = lexer.parseIdentifier()
        if (name != null) && isIdentifier(name)
            lexer.advance()
        else
            throw identifierExpected(new Position(startName))

        let subType: Subtype = parseSubtype() catch _ null
        let postfixes: TypePostfix[] = parseTypePostfixList() catch _ null
        let lifeTime: LifeTime = parseLifeTime() catch _ null
        let end: Position$ = lexer.getPosition()
        var ret: Type = new Type(name, subType, postfixes, lifeTime, new Position(start), new Position(end))
        if subType != null
            subType.parent = ret
        if postfixes != null {
            for item: TypePostfix in postfixes
                item.parent = ret
        }
        if lifeTime != null
            lifeTime.parent = ret

        return(ret)
    }

    function parseTypeAnnotation(): TypeAnnotation throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startColon1: Position$ = lexer.getPreviousPosition()
        let successColon1: bool = lexer.parsePunctuation(colon)
        if successColon1
            lexer.advance()
        else
            throw punctuationExpected(new Position(startColon1), new string(colon))

        let annotationForType: Type = parseType() catch _ (error)
            throw error
        let end: Position$ = lexer.getPosition()
        var ret: TypeAnnotation = new TypeAnnotation(annotationForType, new Position(start), new Position(end))
        annotationForType.parent = ret

        return(ret)
    }

    function parseSubtype(): Subtype throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startDot1: Position$ = lexer.getPreviousPosition()
        let successDot1: bool = lexer.parsePunctuation(dot)
        if successDot1
            lexer.advance()
        else
            throw punctuationExpected(new Position(startDot1), new string(dot))

        let type: Type = parseType() catch _ (error)
            throw error
        let end: Position$ = lexer.getPosition()
        var ret: Subtype = new Subtype(type, new Position(start), new Position(end))
        type.parent = ret

        return(ret)
    }

    function parseTypePostfixList(): TypePostfix[] throws ParserError {
        mutable ret: TypePostfix[]$ = null
        while true {
            let node: TypePostfix = parseTypePostfix()
                catch _ break
            if ret == null
                ret = new TypePostfix[]()
            ret.push(node)
        }

        return(ret)
    }

    function parseTypePostfix(): TypePostfix throws ParserError {
        mutable errors: ParserError[]$ = new ParserError[]()
        let start: Position$ = lexer.getPreviousPosition()

        {
            let node: IndexedType = parseIndexedType() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: Pointer = parsePointer() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        throw unableToParse(new Position(start), new ParserError[](errors))
    }

    function parseIndexedType(): IndexedType throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startLeftBracket1: Position$ = lexer.getPreviousPosition()
        let successLeftBracket1: bool = lexer.parsePunctuation(leftBracket)
        if successLeftBracket1
            lexer.advance()
        else
            throw punctuationExpected(new Position(startLeftBracket1), new string(leftBracket))

        let key: Type = parseType() catch _ null
        let startRightBracket3: Position$ = lexer.getPreviousPosition()
        let successRightBracket3: bool = lexer.parsePunctuation(rightBracket)
        if successRightBracket3
            lexer.advance()
        else
            throw punctuationExpected(new Position(startRightBracket3), new string(rightBracket))

        let end: Position$ = lexer.getPosition()
        var ret: IndexedType = new IndexedType(key, new Position(start), new Position(end))
        if key != null
            key.parent = ret

        return(ret)
    }

    function parsePointer(): Pointer throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startCircumflex1: Position$ = lexer.getPreviousPosition()
        let successCircumflex1: bool = lexer.parsePunctuation(circumflex)
        if successCircumflex1
            lexer.advance()
        else
            throw punctuationExpected(new Position(startCircumflex1), new string(circumflex))

        let end: Position$ = lexer.getPosition()
        var ret: Pointer = new Pointer(new Position(start), new Position(end))

        return(ret)
    }

    function parseLifeTime(): LifeTime throws ParserError {
        mutable errors: ParserError[]$ = new ParserError[]()
        let start: Position$ = lexer.getPreviousPosition()

        {
            let node: Root = parseRoot() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: Local = parseLocal() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: Reference = parseReference() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        {
            let node: Thrown = parseThrown() catch _ (error) {
                errors.push(error)
            }

            if node != null
                return(node)
        }

        throw unableToParse(new Position(start), new ParserError[](errors))
    }

    function parseRoot(): Root throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startDollar1: Position$ = lexer.getPreviousPosition()
        let successDollar1: bool = lexer.parsePunctuation(dollar)
        if successDollar1
            lexer.advance()
        else
            throw punctuationExpected(new Position(startDollar1), new string(dollar))

        let end: Position$ = lexer.getPosition()
        var ret: Root = new Root(new Position(start), new Position(end))

        return(ret)
    }

    function parseLocal(): Local throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startTilde1: Position$ = lexer.getPreviousPosition()
        let successTilde1: bool = lexer.parsePunctuation(tilde)
        if successTilde1
            lexer.advance()
        else
            throw punctuationExpected(new Position(startTilde1), new string(tilde))

        let startLocation: Position$ = lexer.getPreviousPosition()
        let location: string = lexer.parseIdentifier()
        if (location != null) && isIdentifier(location)
            lexer.advance()
        else
            throw identifierExpected(new Position(startLocation))

        let end: Position$ = lexer.getPosition()
        var ret: Local = new Local(location, new Position(start), new Position(end))

        return(ret)
    }

    function parseReference(): Reference throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startAt1: Position$ = lexer.getPreviousPosition()
        let successAt1: bool = lexer.parsePunctuation(at)
        if successAt1
            lexer.advance()
        else
            throw punctuationExpected(new Position(startAt1), new string(at))

        let age: Literal = lexer.parseLiteral()
        if age != null
            lexer.advance()
        let end: Position$ = lexer.getPosition()
        var ret: Reference = new Reference(age, new Position(start), new Position(end))

        return(ret)
    }

    function parseThrown(): Thrown throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startHash1: Position$ = lexer.getPreviousPosition()
        let successHash1: bool = lexer.parsePunctuation(hash)
        if successHash1
            lexer.advance()
        else
            throw punctuationExpected(new Position(startHash1), new string(hash))

        let end: Position$ = lexer.getPosition()
        var ret: Thrown = new Thrown(new Position(start), new Position(end))

        return(ret)
    }

    function parseTypeInheritanceClause(): TypeInheritanceClause throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let startExtends1: Position$ = lexer.getPreviousPosition()
        let successExtends1: bool = lexer.parseKeyword(extendsKeyword)
        if successExtends1
            lexer.advance()
        else
            throw keywordExpected(new Position(startExtends1), new string(extendsKeyword))

        let inheritances: Inheritance[] = parseInheritanceList() catch _ null
        let end: Position$ = lexer.getPosition()
        var ret: TypeInheritanceClause = new TypeInheritanceClause(inheritances, new Position(start), new Position(end))
        if inheritances != null {
            for item: Inheritance in inheritances
                item.parent = ret
        }

        return(ret)
    }

    function parseInheritanceList(): Inheritance[] throws ParserError {
        mutable ret: Inheritance[]$ = null
        while true {
            let node: Inheritance = parseInheritance()
                catch _ break
            if ret == null
                ret = new Inheritance[]()
            ret.push(node)
        }

        return(ret)
    }

    function parseInheritance(): Inheritance throws ParserError {
        let start: Position$ = lexer.getPreviousPosition()
        let type: Type = parseType() catch _ (error)
            throw error
        let successComma2: bool = lexer.parsePunctuation(comma)
        if successComma2
            lexer.advance()
        let end: Position$ = lexer.getPosition()
        var ret: Inheritance = new Inheritance(type, new Position(start), new Position(end))
        type.parent = ret

        return(ret)
    }

    function isAtEnd(): bool {
        return(lexer.isAtEnd())
    }

    function isIdentifier(id: string): bool {
        if id.equals(classKeyword)
            return(false)

        if id.equals(functionKeyword)
            return(false)

        if id.equals(ifKeyword)
            return(false)

        if id.equals(elseKeyword)
            return(false)

        if id.equals(switchKeyword)
            return(false)

        if id.equals(caseKeyword)
            return(false)

        if id.equals(defaultKeyword)
            return(false)

        if id.equals(catchKeyword)
            return(false)

        if id.equals(forKeyword)
            return(false)

        if id.equals(inKeyword)
            return(false)

        if id.equals(whileKeyword)
            return(false)

        if id.equals(doKeyword)
            return(false)

        if id.equals(returnKeyword)
            return(false)

        if id.equals(throwKeyword)
            return(false)

        if id.equals(breakKeyword)
            return(false)

        if id.equals(throwsKeyword)
            return(false)

        if id.equals(overrideKeyword)
            return(false)

        if id.equals(staticKeyword)
            return(false)

        if id.equals(letKeyword)
            return(false)

        if id.equals(varKeyword)
            return(false)

        if id.equals(mutableKeyword)
            return(false)

        if id.equals(isKeyword)
            return(false)

        if id.equals(asKeyword)
            return(false)

        if id.equals(constructorKeyword)
            return(false)

        if id.equals(enumKeyword)
            return(false)

        if id.equals(thisKeyword)
            return(false)

        if id.equals(nullKeyword)
            return(false)

        if id.equals(newKeyword)
            return(false)

        if id.equals(extendsKeyword)
            return(false)

        return(true)
    }

    mutable lexer: Lexer
    let fileName: string

    let classKeyword: string
    let functionKeyword: string
    let ifKeyword: string
    let elseKeyword: string
    let switchKeyword: string
    let caseKeyword: string
    let defaultKeyword: string
    let catchKeyword: string
    let forKeyword: string
    let inKeyword: string
    let whileKeyword: string
    let doKeyword: string
    let returnKeyword: string
    let throwKeyword: string
    let breakKeyword: string
    let throwsKeyword: string
    let overrideKeyword: string
    let staticKeyword: string
    let letKeyword: string
    let varKeyword: string
    let mutableKeyword: string
    let isKeyword: string
    let asKeyword: string
    let constructorKeyword: string
    let enumKeyword: string
    let thisKeyword: string
    let nullKeyword: string
    let newKeyword: string
    let extendsKeyword: string
    let equal: string
    let comma: string
    let leftParen: string
    let rightParen: string
    let leftCurly: string
    let rightCurly: string
    let leftBracket: string
    let rightBracket: string
    let colon: string
    let dot: string
    let underscore: string
    let circumflex: string
    let dollar: string
    let at: string
    let hash: string
    let tilde: string
}
