class Parser {
    init(text: String) {
        lexer = Lexer(text)
    }

    function parseTopLevelDeclaration() -> TopLevelDeclaration throws ParserError {
        mutable ret: TopLevelDeclaration? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let result: [StatementWithSemicolon] node = parseStatementWithSemicolonList() catch _(error) {
                throw (error)
            }
            if !isAtEnd() {
                let current: Position = lexer.getPreviousPosition()
                throw ParserError.NotAtEnd(current)
            }

            if ret == null
                ret = TopLevelDeclaration(start, lexer.getPosition())

            ret.statements = node
        }

        return ret
    }

    function parseStatementWithSemicolonList() -> [StatementWithSemicolon] throws ParserError {
        mutable ret: [StatementWithSemicolon]? = null

        while true {
            let node: StatementWithSemicolon = parseStatementWithSemicolon()
                catch _ break
            
            if ret == null
                ret = [StatementWithSemicolon]
                
            ret.append(node)
        }

        return ret
    }

    function parseStatementWithSemicolon() -> StatementWithSemicolon throws ParserError {
        mutable ret: StatementWithSemicolon? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let result: Statement node = parseStatement() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = StatementWithSemicolon(start, lexer.getPosition())

            ret.statement = node
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parsePunctuation(semicolon)
            if success
                lexer.advance()

            if ret == null
                ret = StatementWithSemicolon(start, lexer.getPosition())
        }

        return ret
    }

    function parseStatement() -> Statement throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: Declaration = parseDeclaration() catch _(error) {
                errors.append(error)
                break
            }

            return node
        }

        {
            let node: Expression = parseExpression() catch _(error) {
                errors.append(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(start, errors)
    }

    function parseDeclaration() -> Declaration throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: UseDeclaration = parseUseDeclaration() catch _(error) {
                errors.append(error)
                break
            }

            return node
        }

        {
            let node: ConstantDeclaration = parseConstantDeclaration() catch _(error) {
                errors.append(error)
                break
            }

            return node
        }

        {
            let node: VariableDeclaration = parseVariableDeclaration() catch _(error) {
                errors.append(error)
                break
            }

            return node
        }

        {
            let node: FunctionDeclaration = parseFunctionDeclaration() catch _(error) {
                errors.append(error)
                break
            }

            return node
        }

        {
            let node: EnumDeclaration = parseEnumDeclaration() catch _(error) {
                errors.append(error)
                break
            }

            return node
        }

        {
            let node: ClassDeclaration = parseClassDeclaration() catch _(error) {
                errors.append(error)
                break
            }

            return node
        }

        {
            let node: InitializerDeclaration = parseInitializerDeclaration() catch _(error) {
                errors.append(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(start, errors)
    }

    function parseUseDeclaration() -> UseDeclaration throws ParserError {
        mutable ret: UseDeclaration? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parseKeyword(useKeyword)
            if success
                lexer.advance()

            if ret == null
                ret = UseDeclaration(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: PathItem node = parsePathItem() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = UseDeclaration(start, lexer.getPosition())

            ret.importModule = node
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: [PathIdentifier] node = parsePathIdentifierList() catch _(error) {
                 null
            }

            if ret == null
                ret = UseDeclaration(start, lexer.getPosition())

            ret.importExtensions = node
        }

        return ret
    }

    function parsePathIdentifierList() -> [PathIdentifier] throws ParserError {
        mutable ret: [PathIdentifier]? = null

        while true {
            let node: PathIdentifier = parsePathIdentifier()
                catch _ break
            
            if ret == null
                ret = [PathIdentifier]
                
            ret.append(node)
        }

        return ret
    }

    function parsePathIdentifier() -> PathIdentifier throws ParserError {
        mutable ret: PathIdentifier? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parsePunctuation(dot)
            if success
                lexer.advance()

            if ret == null
                ret = PathIdentifier(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: PathItem node = parsePathItem() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = PathIdentifier(start, lexer.getPosition())

            ret.extension = node
        }

        return ret
    }

    function parsePathItem() -> PathItem throws ParserError {
        mutable ret: PathItem? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let name: String? = lexer.parseIdentifier()
            if (name != null) && (name is Identifier)
                lexer.advance()

            if ret == null
                ret = PathItem(start, lexer.getPosition())

            ret.name = name
        }

        return ret
    }

    function parseInitializer() -> Initializer throws ParserError {
        mutable ret: Initializer? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parsePunctuation(equal)
            if success
                lexer.advance()

            if ret == null
                ret = Initializer(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: Expression node = parseExpression() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = Initializer(start, lexer.getPosition())

            ret.expression = node
        }

        return ret
    }

    function parseConstantDeclaration() -> ConstantDeclaration throws ParserError {
        mutable ret: ConstantDeclaration? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parseKeyword(letKeyword)
            if success
                lexer.advance()

            if ret == null
                ret = ConstantDeclaration(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: BindingInitializer node = parseBindingInitializer() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = ConstantDeclaration(start, lexer.getPosition())

            ret.initializer = node
        }

        return ret
    }

    function parseVariableDeclaration() -> VariableDeclaration throws ParserError {
        mutable ret: VariableDeclaration? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parseKeyword(mutableKeyword)
            if success
                lexer.advance()

            if ret == null
                ret = VariableDeclaration(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: BindingInitializer node = parseBindingInitializer() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = VariableDeclaration(start, lexer.getPosition())

            ret.initializer = node
        }

        return ret
    }

    function parseBindingInitializer() -> BindingInitializer throws ParserError {
        mutable ret: BindingInitializer? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let result: PatternInitializer node = parsePatternInitializer() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = BindingInitializer(start, lexer.getPosition())

            ret.initializer = node
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: [AdditionalInitializer] node = parseAdditionalInitializerList() catch _(error) {
                 null
            }

            if ret == null
                ret = BindingInitializer(start, lexer.getPosition())

            ret.additionalInitializers = node
        }

        return ret
    }

    function parsePatternInitializerList() -> [PatternInitializer] throws ParserError {
        mutable ret: [PatternInitializer]? = null

        while true {
            let node: PatternInitializer = parsePatternInitializer()
                catch _ break
            
            if ret == null
                ret = [PatternInitializer]
                
            ret.append(node)
        }

        return ret
    }

    function parsePatternInitializer() -> PatternInitializer throws ParserError {
        mutable ret: PatternInitializer? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let result: Pattern node = parsePattern() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = PatternInitializer(start, lexer.getPosition())

            ret.pattern = node
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: Initializer node = parseInitializer() catch _(error) {
                 null
            }

            if ret == null
                ret = PatternInitializer(start, lexer.getPosition())

            ret.initializer = node
        }

        return ret
    }

    function parseAdditionalInitializerList() -> [AdditionalInitializer] throws ParserError {
        mutable ret: [AdditionalInitializer]? = null

        while true {
            let node: AdditionalInitializer = parseAdditionalInitializer()
                catch _ break
            
            if ret == null
                ret = [AdditionalInitializer]
                
            ret.append(node)
        }

        return ret
    }

    function parseAdditionalInitializer() -> AdditionalInitializer throws ParserError {
        mutable ret: AdditionalInitializer? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parsePunctuation(comma)
            if success
                lexer.advance()

            if ret == null
                ret = AdditionalInitializer(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: PatternInitializer node = parsePatternInitializer() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = AdditionalInitializer(start, lexer.getPosition())

            ret.pattern = node
        }

        return ret
    }

    function parseFunctionDeclaration() -> FunctionDeclaration throws ParserError {
        mutable ret: FunctionDeclaration? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let result: [Modifier] node = parseModifierList() catch _(error) {
                 null
            }

            if ret == null
                ret = FunctionDeclaration(start, lexer.getPosition())

            ret.modifiers = node
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parseKeyword(functionKeyword)
            if success
                lexer.advance()

            if ret == null
                ret = FunctionDeclaration(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: FunctionName node = parseFunctionName() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = FunctionDeclaration(start, lexer.getPosition())

            ret.name = node
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: FunctionSignature node = parseFunctionSignature() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = FunctionDeclaration(start, lexer.getPosition())

            ret.signature = node
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: Expression node = parseExpression() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = FunctionDeclaration(start, lexer.getPosition())

            ret.body = node
        }

        return ret
    }

    function parseInitializerDeclaration() -> InitializerDeclaration throws ParserError {
        mutable ret: InitializerDeclaration? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let result: [Modifier] node = parseModifierList() catch _(error) {
                 null
            }

            if ret == null
                ret = InitializerDeclaration(start, lexer.getPosition())

            ret.modifiers = node
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parseKeyword(initKeyword)
            if success
                lexer.advance()

            if ret == null
                ret = InitializerDeclaration(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: ParameterClause node = parseParameterClause() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = InitializerDeclaration(start, lexer.getPosition())

            ret.parameterClause = node
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: ThrowsClause node = parseThrowsClause() catch _(error) {
                 null
            }

            if ret == null
                ret = InitializerDeclaration(start, lexer.getPosition())

            ret.throwsClause = node
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: Expression node = parseExpression() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = InitializerDeclaration(start, lexer.getPosition())

            ret.body = node
        }

        return ret
    }

    function parseModifierList() -> [Modifier] throws ParserError {
        mutable ret: [Modifier]? = null

        while true {
            let node: Modifier = parseModifier()
                catch _ break
            
            if ret == null
                ret = [Modifier]
                
            ret.append(node)
        }

        return ret
    }

    function parseModifier() -> Modifier throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: Static = parseStatic() catch _(error) {
                errors.append(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(start, errors)
    }

    function parseStatic() -> Static throws ParserError {
        mutable ret: Static? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parseKeyword(staticKeyword)
            if success
                lexer.advance()

            if ret == null
                ret = Static(start, lexer.getPosition())
        }

        return ret
    }

    function parseFunctionName() -> FunctionName throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: IdentifierFunctionName = parseIdentifierFunctionName() catch _(error) {
                errors.append(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(start, errors)
    }

    function parseIdentifierFunctionName() -> IdentifierFunctionName throws ParserError {
        mutable ret: IdentifierFunctionName? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let name: String? = lexer.parseIdentifier()
            if (name != null) && (name is Identifier)
                lexer.advance()

            if ret == null
                ret = IdentifierFunctionName(start, lexer.getPosition())

            ret.name = name
        }

        return ret
    }

    function parseFunctionSignature() -> FunctionSignature throws ParserError {
        mutable ret: FunctionSignature? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let result: ParameterClause node = parseParameterClause() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = FunctionSignature(start, lexer.getPosition())

            ret.parameterClause = node
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: FunctionResult node = parseFunctionResult() catch _(error) {
                 null
            }

            if ret == null
                ret = FunctionSignature(start, lexer.getPosition())

            ret.result = node
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: ThrowsClause node = parseThrowsClause() catch _(error) {
                 null
            }

            if ret == null
                ret = FunctionSignature(start, lexer.getPosition())

            ret.throwsClause = node
        }

        return ret
    }

    function parseFunctionResult() -> FunctionResult throws ParserError {
        mutable ret: FunctionResult? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parsePunctuation(evaluatesTo)
            if success
                lexer.advance()

            if ret == null
                ret = FunctionResult(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: Type node = parseType() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = FunctionResult(start, lexer.getPosition())

            ret.resultType = node
        }

        return ret
    }

    function parseParameterClauseList() -> [ParameterClause] throws ParserError {
        mutable ret: [ParameterClause]? = null

        while true {
            let node: ParameterClause = parseParameterClause()
                catch _ break
            
            if ret == null
                ret = [ParameterClause]
                
            ret.append(node)
        }

        return ret
    }

    function parseParameterClause() -> ParameterClause throws ParserError {
        mutable ret: ParameterClause? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parsePunctuation(leftParen)
            if success
                lexer.advance()

            if ret == null
                ret = ParameterClause(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: [Parameter] node = parseParameterList() catch _(error) {
                 null
            }

            if ret == null
                ret = ParameterClause(start, lexer.getPosition())

            ret.parameters = node
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parsePunctuation(rightParen)
            if success
                lexer.advance()

            if ret == null
                ret = ParameterClause(start, lexer.getPosition())
        }

        return ret
    }

    function parseParameterList() -> [Parameter] throws ParserError {
        mutable ret: [Parameter]? = null

        while true {
            let node: Parameter = parseParameter()
                catch _ break
            
            if ret == null
                ret = [Parameter]
                
            ret.append(node)
        }

        return ret
    }

    function parseParameter() -> Parameter throws ParserError {
        mutable ret: Parameter? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let parameterName: String? = lexer.parseIdentifier()
            if (parameterName != null) && (parameterName is Identifier)
                lexer.advance()

            if ret == null
                ret = Parameter(start, lexer.getPosition())

            ret.parameterName = parameterName
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parsePunctuation(colon)
            if success
                lexer.advance()

            if ret == null
                ret = Parameter(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: Type node = parseType() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = Parameter(start, lexer.getPosition())

            ret.parameterType = node
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parsePunctuation(comma)
            if success
                lexer.advance()

            if ret == null
                ret = Parameter(start, lexer.getPosition())
        }

        return ret
    }

    function parseThrowsClause() -> ThrowsClause throws ParserError {
        mutable ret: ThrowsClause? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parseKeyword(throwsKeyword)
            if success
                lexer.advance()

            if ret == null
                ret = ThrowsClause(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: Type node = parseType() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = ThrowsClause(start, lexer.getPosition())

            ret.throwsType = node
        }

        return ret
    }

    function parseEnumDeclaration() -> EnumDeclaration throws ParserError {
        mutable ret: EnumDeclaration? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parseKeyword(enumKeyword)
            if success
                lexer.advance()

            if ret == null
                ret = EnumDeclaration(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let name: String? = lexer.parseIdentifier()
            if (name != null) && (name is Identifier)
                lexer.advance()

            if ret == null
                ret = EnumDeclaration(start, lexer.getPosition())

            ret.name = name
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parsePunctuation(leftCurly)
            if success
                lexer.advance()

            if ret == null
                ret = EnumDeclaration(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: [EnumMember] node = parseEnumMemberList() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = EnumDeclaration(start, lexer.getPosition())

            ret.members = node
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parsePunctuation(rightCurly)
            if success
                lexer.advance()

            if ret == null
                ret = EnumDeclaration(start, lexer.getPosition())
        }

        return ret
    }

    function parseEnumMemberList() -> [EnumMember] throws ParserError {
        mutable ret: [EnumMember]? = null

        while true {
            let node: EnumMember = parseEnumMember()
                catch _ break
            
            if ret == null
                ret = [EnumMember]
                
            ret.append(node)
        }

        return ret
    }

    function parseEnumMember() -> EnumMember throws ParserError {
        mutable ret: EnumMember? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parseKeyword(caseKeyword)
            if success
                lexer.advance()

            if ret == null
                ret = EnumMember(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: EnumCase node = parseEnumCase() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = EnumMember(start, lexer.getPosition())

            ret.enumCase = node
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: [AdditionalCase] node = parseAdditionalCaseList() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = EnumMember(start, lexer.getPosition())

            ret.additionalCases = node
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: TupleType node = parseTupleType() catch _(error) {
                 null
            }

            if ret == null
                ret = EnumMember(start, lexer.getPosition())

            ret.tupleType = node
        }

        return ret
    }

    function parseTupleType() -> TupleType throws ParserError {
        mutable ret: TupleType? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parsePunctuation(leftParen)
            if success
                lexer.advance()

            if ret == null
                ret = TupleType(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: Type node = parseType() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = TupleType(start, lexer.getPosition())

            ret.tupleType = node
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: [AdditionalType] node = parseAdditionalTypeList() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = TupleType(start, lexer.getPosition())

            ret.additionalTypes = node
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parsePunctuation(rightParen)
            if success
                lexer.advance()

            if ret == null
                ret = TupleType(start, lexer.getPosition())
        }

        return ret
    }

    function parseAdditionalTypeList() -> [AdditionalType] throws ParserError {
        mutable ret: [AdditionalType]? = null

        while true {
            let node: AdditionalType = parseAdditionalType()
                catch _ break
            
            if ret == null
                ret = [AdditionalType]
                
            ret.append(node)
        }

        return ret
    }

    function parseAdditionalType() -> AdditionalType throws ParserError {
        mutable ret: AdditionalType? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parsePunctuation(comma)
            if success
                lexer.advance()

            if ret == null
                ret = AdditionalType(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: Type node = parseType() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = AdditionalType(start, lexer.getPosition())

            ret.enumCase = node
        }

        return ret
    }

    function parseEnumCase() -> EnumCase throws ParserError {
        mutable ret: EnumCase? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let name: String? = lexer.parseIdentifier()
            if (name != null) && (name is Identifier)
                lexer.advance()

            if ret == null
                ret = EnumCase(start, lexer.getPosition())

            ret.name = name
        }

        return ret
    }

    function parseAdditionalCaseList() -> [AdditionalCase] throws ParserError {
        mutable ret: [AdditionalCase]? = null

        while true {
            let node: AdditionalCase = parseAdditionalCase()
                catch _ break
            
            if ret == null
                ret = [AdditionalCase]
                
            ret.append(node)
        }

        return ret
    }

    function parseAdditionalCase() -> AdditionalCase throws ParserError {
        mutable ret: AdditionalCase? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parsePunctuation(comma)
            if success
                lexer.advance()

            if ret == null
                ret = AdditionalCase(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: EnumCase node = parseEnumCase() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = AdditionalCase(start, lexer.getPosition())

            ret.enumCase = node
        }

        return ret
    }

    function parseClassDeclaration() -> ClassDeclaration throws ParserError {
        mutable ret: ClassDeclaration? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parseKeyword(classKeyword)
            if success
                lexer.advance()

            if ret == null
                ret = ClassDeclaration(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let name: String? = lexer.parseIdentifier()
            if (name != null) && (name is Identifier)
                lexer.advance()

            if ret == null
                ret = ClassDeclaration(start, lexer.getPosition())

            ret.name = name
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: GenericArgumentClause node = parseGenericArgumentClause() catch _(error) {
                 null
            }

            if ret == null
                ret = ClassDeclaration(start, lexer.getPosition())

            ret.genericArgumentClause = node
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: TypeInheritanceClause node = parseTypeInheritanceClause() catch _(error) {
                 null
            }

            if ret == null
                ret = ClassDeclaration(start, lexer.getPosition())

            ret.typeInheritanceClause = node
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parsePunctuation(leftCurly)
            if success
                lexer.advance()

            if ret == null
                ret = ClassDeclaration(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: [ClassMember] node = parseClassMemberList() catch _(error) {
                 null
            }

            if ret == null
                ret = ClassDeclaration(start, lexer.getPosition())

            ret.members = node
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parsePunctuation(rightCurly)
            if success
                lexer.advance()

            if ret == null
                ret = ClassDeclaration(start, lexer.getPosition())
        }

        return ret
    }

    function parseGenericArgumentClause() -> GenericArgumentClause throws ParserError {
        mutable ret: GenericArgumentClause? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parsePunctuation(leftAngular)
            if success
                lexer.advance()

            if ret == null
                ret = GenericArgumentClause(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: [GenericParameter] node = parseGenericParameterList() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = GenericArgumentClause(start, lexer.getPosition())

            ret.genericParameters = node
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parsePunctuation(rightAngular)
            if success
                lexer.advance()

            if ret == null
                ret = GenericArgumentClause(start, lexer.getPosition())
        }

        return ret
    }

    function parseGenericParameterList() -> [GenericParameter] throws ParserError {
        mutable ret: [GenericParameter]? = null

        while true {
            let node: GenericParameter = parseGenericParameter()
                catch _ break
            
            if ret == null
                ret = [GenericParameter]
                
            ret.append(node)
        }

        return ret
    }

    function parseGenericParameter() -> GenericParameter throws ParserError {
        mutable ret: GenericParameter? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let typeName: String? = lexer.parseIdentifier()
            if (typeName != null) && (typeName is Identifier)
                lexer.advance()

            if ret == null
                ret = GenericParameter(start, lexer.getPosition())

            ret.typeName = typeName
        }

        return ret
    }

    function parseClassMemberList() -> [ClassMember] throws ParserError {
        mutable ret: [ClassMember]? = null

        while true {
            let node: ClassMember = parseClassMember()
                catch _ break
            
            if ret == null
                ret = [ClassMember]
                
            ret.append(node)
        }

        return ret
    }

    function parseClassMember() -> ClassMember throws ParserError {
        mutable ret: ClassMember? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let result: Declaration node = parseDeclaration() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = ClassMember(start, lexer.getPosition())

            ret.declaration = node
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parsePunctuation(semicolon)
            if success
                lexer.advance()

            if ret == null
                ret = ClassMember(start, lexer.getPosition())
        }

        return ret
    }

    function parseExpression() -> Expression throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: SimpleExpression = parseSimpleExpression() catch _(error) {
                errors.append(error)
                break
            }

            return node
        }

        {
            let node: CodeBlock = parseCodeBlock() catch _(error) {
                errors.append(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(start, errors)
    }

    function parseCodeBlock() -> CodeBlock throws ParserError {
        mutable ret: CodeBlock? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parsePunctuation(leftCurly)
            if success
                lexer.advance()

            if ret == null
                ret = CodeBlock(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: [StatementWithSemicolon] node = parseStatementWithSemicolonList() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = CodeBlock(start, lexer.getPosition())

            ret.statements = node
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parsePunctuation(rightCurly)
            if success
                lexer.advance()

            if ret == null
                ret = CodeBlock(start, lexer.getPosition())
        }

        return ret
    }

    function parseSimpleExpression() -> SimpleExpression throws ParserError {
        mutable ret: SimpleExpression? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let result: PrefixExpression node = parsePrefixExpression() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = SimpleExpression(start, lexer.getPosition())

            ret.prefixExpression = node
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: [BinaryOp] node = parseBinaryOpList() catch _(error) {
                 null
            }

            if ret == null
                ret = SimpleExpression(start, lexer.getPosition())

            ret.binaryOps = node
        }

        return ret
    }

    function parsePrefixExpression() -> PrefixExpression throws ParserError {
        mutable ret: PrefixExpression? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let prefixOperator: String? = lexer.parsePrefixOperator()
            if prefixOperator != null
                lexer.advance()

            if ret == null
                ret = PrefixExpression(start, lexer.getPosition())

            ret.prefixOperator = prefixOperator
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: PostfixExpression node = parsePostfixExpression() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = PrefixExpression(start, lexer.getPosition())

            ret.expression = node
        }

        return ret
    }

    function parsePostfixExpression() -> PostfixExpression throws ParserError {
        mutable ret: PostfixExpression? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let result: PrimaryExpression node = parsePrimaryExpression() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = PostfixExpression(start, lexer.getPosition())

            ret.primaryExpression = node
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: [Postfix] node = parsePostfixList() catch _(error) {
                 null
            }

            if ret == null
                ret = PostfixExpression(start, lexer.getPosition())

            ret.postfixes = node
        }

        return ret
    }

    function parseBinaryOpList() -> [BinaryOp] throws ParserError {
        mutable ret: [BinaryOp]? = null

        while true {
            let node: BinaryOp = parseBinaryOp()
                catch _ break
            
            if ret == null
                ret = [BinaryOp]
                
            ret.append(node)
        }

        return ret
    }

    function parseBinaryOp() -> BinaryOp throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: BinaryOperation = parseBinaryOperation() catch _(error) {
                errors.append(error)
                break
            }

            return node
        }

        {
            let node: Assignment = parseAssignment() catch _(error) {
                errors.append(error)
                break
            }

            return node
        }

        {
            let node: TypeQuery = parseTypeQuery() catch _(error) {
                errors.append(error)
                break
            }

            return node
        }

        {
            let node: TypeCast = parseTypeCast() catch _(error) {
                errors.append(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(start, errors)
    }

    function parseBinaryOperation() -> BinaryOperation throws ParserError {
        mutable ret: BinaryOperation? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let binaryOperator: String? = lexer.parseBinaryOperator()
            if binaryOperator != null
                lexer.advance()

            if ret == null
                ret = BinaryOperation(start, lexer.getPosition())

            ret.binaryOperator = binaryOperator
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: PrefixExpression node = parsePrefixExpression() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = BinaryOperation(start, lexer.getPosition())

            ret.expression = node
        }

        return ret
    }

    function parseAssignment() -> Assignment throws ParserError {
        mutable ret: Assignment? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parsePunctuation(equal)
            if success
                lexer.advance()

            if ret == null
                ret = Assignment(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: PrefixExpression node = parsePrefixExpression() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = Assignment(start, lexer.getPosition())

            ret.expression = node
        }

        return ret
    }

    function parseTypeQuery() -> TypeQuery throws ParserError {
        mutable ret: TypeQuery? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parseKeyword(isKeyword)
            if success
                lexer.advance()

            if ret == null
                ret = TypeQuery(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: Type node = parseType() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = TypeQuery(start, lexer.getPosition())

            ret.objectType = node
        }

        return ret
    }

    function parseTypeCast() -> TypeCast throws ParserError {
        mutable ret: TypeCast? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parseKeyword(asKeyword)
            if success
                lexer.advance()

            if ret == null
                ret = TypeCast(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: Type node = parseType() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = TypeCast(start, lexer.getPosition())

            ret.objectType = node
        }

        return ret
    }

    function parseCatchClauseList() -> [CatchClause] throws ParserError {
        mutable ret: [CatchClause]? = null

        while true {
            let node: CatchClause = parseCatchClause()
                catch _ break
            
            if ret == null
                ret = [CatchClause]
                
            ret.append(node)
        }

        return ret
    }

    function parseCatchClause() -> CatchClause throws ParserError {
        mutable ret: CatchClause? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parseKeyword(catchKeyword)
            if success
                lexer.advance()

            if ret == null
                ret = CatchClause(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: CatchPattern node = parseCatchPattern() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = CatchClause(start, lexer.getPosition())

            ret.catchPattern = node
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: TuplePattern node = parseTuplePattern() catch _(error) {
                 null
            }

            if ret == null
                ret = CatchClause(start, lexer.getPosition())

            ret.bindingPattern = node
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: Expression node = parseExpression() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = CatchClause(start, lexer.getPosition())

            ret.expression = node
        }

        return ret
    }

    function parseCatchPattern() -> CatchPattern throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: WildCardCatchPattern = parseWildCardCatchPattern() catch _(error) {
                errors.append(error)
                break
            }

            return node
        }

        {
            let node: PathItemCatchPattern = parsePathItemCatchPattern() catch _(error) {
                errors.append(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(start, errors)
    }

    function parseWildCardCatchPattern() -> WildCardCatchPattern throws ParserError {
        mutable ret: WildCardCatchPattern? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let result: WildcardPattern node = parseWildcardPattern() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = WildCardCatchPattern(start, lexer.getPosition())

            ret.pattern = node
        }

        return ret
    }

    function parsePathItemCatchPattern() -> PathItemCatchPattern throws ParserError {
        mutable ret: PathItemCatchPattern? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let result: PathItem node = parsePathItem() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = PathItemCatchPattern(start, lexer.getPosition())

            ret.catchCase = node
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: [PathIdentifier] node = parsePathIdentifierList() catch _(error) {
                 null
            }

            if ret == null
                ret = PathItemCatchPattern(start, lexer.getPosition())

            ret.catchCaseExtensions = node
        }

        return ret
    }

    function parsePostfixList() -> [Postfix] throws ParserError {
        mutable ret: [Postfix]? = null

        while true {
            let node: Postfix = parsePostfix()
                catch _ break
            
            if ret == null
                ret = [Postfix]
                
            ret.append(node)
        }

        return ret
    }

    function parsePostfix() -> Postfix throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: OperatorPostfix = parseOperatorPostfix() catch _(error) {
                errors.append(error)
                break
            }

            return node
        }

        {
            let node: FunctionCall = parseFunctionCall() catch _(error) {
                errors.append(error)
                break
            }

            return node
        }

        {
            let node: ExplicitMemberExpression = parseExplicitMemberExpression() catch _(error) {
                errors.append(error)
                break
            }

            return node
        }

        {
            let node: Subscript = parseSubscript() catch _(error) {
                errors.append(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(start, errors)
    }

    function parseOperatorPostfix() -> OperatorPostfix throws ParserError {
        mutable ret: OperatorPostfix? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let postfixOperator: String? = lexer.parsePostfixOperator()
            if postfixOperator != null
                lexer.advance()

            if ret == null
                ret = OperatorPostfix(start, lexer.getPosition())

            ret.postfixOperator = postfixOperator
        }

        return ret
    }

    function parseFunctionCall() -> FunctionCall throws ParserError {
        mutable ret: FunctionCall? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let result: ParenthesizedExpression node = parseParenthesizedExpression() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = FunctionCall(start, lexer.getPosition())

            ret.arguments = node
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: [CatchClause] node = parseCatchClauseList() catch _(error) {
                 null
            }

            if ret == null
                ret = FunctionCall(start, lexer.getPosition())

            ret.catchClauses = node
        }

        return ret
    }

    function parseExplicitMemberExpression() -> ExplicitMemberExpression throws ParserError {
        mutable ret: ExplicitMemberExpression? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parsePunctuation(dot)
            if success
                lexer.advance()

            if ret == null
                ret = ExplicitMemberExpression(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: MemberPostfix node = parseMemberPostfix() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = ExplicitMemberExpression(start, lexer.getPosition())

            ret.memberPostfix = node
        }

        return ret
    }

    function parseSubscript() -> Subscript throws ParserError {
        mutable ret: Subscript? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parsePunctuation(leftBracket)
            if success
                lexer.advance()

            if ret == null
                ret = Subscript(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: [ExpressionElement] node = parseExpressionElementList() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = Subscript(start, lexer.getPosition())

            ret.expressions = node
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parsePunctuation(rightBracket)
            if success
                lexer.advance()

            if ret == null
                ret = Subscript(start, lexer.getPosition())
        }

        return ret
    }

    function parseExpressionElementList() -> [ExpressionElement] throws ParserError {
        mutable ret: [ExpressionElement]? = null

        while true {
            let node: ExpressionElement = parseExpressionElement()
                catch _ break
            
            if ret == null
                ret = [ExpressionElement]
                
            ret.append(node)
        }

        return ret
    }

    function parseExpressionElement() -> ExpressionElement throws ParserError {
        mutable ret: ExpressionElement? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let result: Expression node = parseExpression() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = ExpressionElement(start, lexer.getPosition())

            ret.expression = node
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parsePunctuation(comma)
            if success
                lexer.advance()

            if ret == null
                ret = ExpressionElement(start, lexer.getPosition())
        }

        return ret
    }

    function parseMemberPostfix() -> MemberPostfix throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: NamedMemberPostfix = parseNamedMemberPostfix() catch _(error) {
                errors.append(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(start, errors)
    }

    function parseNamedMemberPostfix() -> NamedMemberPostfix throws ParserError {
        mutable ret: NamedMemberPostfix? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let result: IdentifierExpression node = parseIdentifierExpression() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = NamedMemberPostfix(start, lexer.getPosition())

            ret.identifier = node
        }

        return ret
    }

    function parsePrimaryExpression() -> PrimaryExpression throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: IdentifierExpression = parseIdentifierExpression() catch _(error) {
                errors.append(error)
                break
            }

            return node
        }

        {
            let node: LiteralExpression = parseLiteralExpression() catch _(error) {
                errors.append(error)
                break
            }

            return node
        }

        {
            let node: IfExpression = parseIfExpression() catch _(error) {
                errors.append(error)
                break
            }

            return node
        }

        {
            let node: SwitchExpression = parseSwitchExpression() catch _(error) {
                errors.append(error)
                break
            }

            return node
        }

        {
            let node: ParenthesizedExpression = parseParenthesizedExpression() catch _(error) {
                errors.append(error)
                break
            }

            return node
        }

        {
            let node: ReturnExpression = parseReturnExpression() catch _(error) {
                errors.append(error)
                break
            }

            return node
        }

        {
            let node: ThrowExpression = parseThrowExpression() catch _(error) {
                errors.append(error)
                break
            }

            return node
        }

        {
            let node: BreakExpression = parseBreakExpression() catch _(error) {
                errors.append(error)
                break
            }

            return node
        }

        {
            let node: InitializerCall = parseInitializerCall() catch _(error) {
                errors.append(error)
                break
            }

            return node
        }

        {
            let node: ThisExpression = parseThisExpression() catch _(error) {
                errors.append(error)
                break
            }

            return node
        }

        {
            let node: SuperExpression = parseSuperExpression() catch _(error) {
                errors.append(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(start, errors)
    }

    function parseParenthesizedExpression() -> ParenthesizedExpression throws ParserError {
        mutable ret: ParenthesizedExpression? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parsePunctuation(leftParen)
            if success
                lexer.advance()

            if ret == null
                ret = ParenthesizedExpression(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: [ExpressionElement] node = parseExpressionElementList() catch _(error) {
                 null
            }

            if ret == null
                ret = ParenthesizedExpression(start, lexer.getPosition())

            ret.expressionElements = node
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parsePunctuation(rightParen)
            if success
                lexer.advance()

            if ret == null
                ret = ParenthesizedExpression(start, lexer.getPosition())
        }

        return ret
    }

    function parseLiteralExpression() -> LiteralExpression throws ParserError {
        mutable ret: LiteralExpression? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let literal: Literal? = lexer.parseLiteral()
            if literal != null
                lexer.advance()

            if ret == null
                ret = LiteralExpression(start, lexer.getPosition())

            ret.literal = literal
        }

        return ret
    }

    function parseIdentifierExpression() -> IdentifierExpression throws ParserError {
        mutable ret: IdentifierExpression? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let name: String? = lexer.parseIdentifier()
            if (name != null) && (name is Identifier)
                lexer.advance()

            if ret == null
                ret = IdentifierExpression(start, lexer.getPosition())

            ret.name = name
        }

        return ret
    }

    function parseIfExpression() -> IfExpression throws ParserError {
        mutable ret: IfExpression? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parseKeyword(ifKeyword)
            if success
                lexer.advance()

            if ret == null
                ret = IfExpression(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: Expression node = parseExpression() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = IfExpression(start, lexer.getPosition())

            ret.condition = node
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: Expression node = parseExpression() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = IfExpression(start, lexer.getPosition())

            ret.consequent = node
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: ElseClause node = parseElseClause() catch _(error) {
                 null
            }

            if ret == null
                ret = IfExpression(start, lexer.getPosition())

            ret.elseClause = node
        }

        return ret
    }

    function parseElseClause() -> ElseClause throws ParserError {
        mutable ret: ElseClause? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parseKeyword(elseKeyword)
            if success
                lexer.advance()

            if ret == null
                ret = ElseClause(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: Expression node = parseExpression() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = ElseClause(start, lexer.getPosition())

            ret.alternative = node
        }

        return ret
    }

    function parseSwitchExpression() -> SwitchExpression throws ParserError {
        mutable ret: SwitchExpression? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parseKeyword(switchKeyword)
            if success
                lexer.advance()

            if ret == null
                ret = SwitchExpression(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: Expression node = parseExpression() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = SwitchExpression(start, lexer.getPosition())

            ret.expression = node
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: SwitchBody node = parseSwitchBody() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = SwitchExpression(start, lexer.getPosition())

            ret.body = node
        }

        return ret
    }

    function parseSwitchBody() -> SwitchBody throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: CurliedSwitchBody = parseCurliedSwitchBody() catch _(error) {
                errors.append(error)
                break
            }

            return node
        }

        {
            let node: NakedSwitchBody = parseNakedSwitchBody() catch _(error) {
                errors.append(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(start, errors)
    }

    function parseCurliedSwitchBody() -> CurliedSwitchBody throws ParserError {
        mutable ret: CurliedSwitchBody? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parsePunctuation(leftCurly)
            if success
                lexer.advance()

            if ret == null
                ret = CurliedSwitchBody(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: [SwitchCase] node = parseSwitchCaseList() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = CurliedSwitchBody(start, lexer.getPosition())

            ret.cases = node
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parsePunctuation(rightCurly)
            if success
                lexer.advance()

            if ret == null
                ret = CurliedSwitchBody(start, lexer.getPosition())
        }

        return ret
    }

    function parseNakedSwitchBody() -> NakedSwitchBody throws ParserError {
        mutable ret: NakedSwitchBody? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let result: [SwitchCase] node = parseSwitchCaseList() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = NakedSwitchBody(start, lexer.getPosition())

            ret.cases = node
        }

        return ret
    }

    function parseSwitchCaseList() -> [SwitchCase] throws ParserError {
        mutable ret: [SwitchCase]? = null

        while true {
            let node: SwitchCase = parseSwitchCase()
                catch _ break
            
            if ret == null
                ret = [SwitchCase]
                
            ret.append(node)
        }

        return ret
    }

    function parseSwitchCase() -> SwitchCase throws ParserError {
        mutable ret: SwitchCase? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let result: CaseLabel node = parseCaseLabel() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = SwitchCase(start, lexer.getPosition())

            ret.label = node
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: CaseContent node = parseCaseContent() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = SwitchCase(start, lexer.getPosition())

            ret.content = node
        }

        return ret
    }

    function parseCaseLabel() -> CaseLabel throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: ItemCaseLabel = parseItemCaseLabel() catch _(error) {
                errors.append(error)
                break
            }

            return node
        }

        {
            let node: DefaultCaseLabel = parseDefaultCaseLabel() catch _(error) {
                errors.append(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(start, errors)
    }

    function parseItemCaseLabel() -> ItemCaseLabel throws ParserError {
        mutable ret: ItemCaseLabel? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parseKeyword(caseKeyword)
            if success
                lexer.advance()

            if ret == null
                ret = ItemCaseLabel(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: Pattern node = parsePattern() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = ItemCaseLabel(start, lexer.getPosition())

            ret.pattern = node
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: [CaseItem] node = parseCaseItemList() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = ItemCaseLabel(start, lexer.getPosition())

            ret.additionalPatterns = node
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parsePunctuation(colon)
            if success
                lexer.advance()

            if ret == null
                ret = ItemCaseLabel(start, lexer.getPosition())
        }

        return ret
    }

    function parseCaseItemList() -> [CaseItem] throws ParserError {
        mutable ret: [CaseItem]? = null

        while true {
            let node: CaseItem = parseCaseItem()
                catch _ break
            
            if ret == null
                ret = [CaseItem]
                
            ret.append(node)
        }

        return ret
    }

    function parseCaseItem() -> CaseItem throws ParserError {
        mutable ret: CaseItem? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parsePunctuation(comma)
            if success
                lexer.advance()

            if ret == null
                ret = CaseItem(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: Pattern node = parsePattern() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = CaseItem(start, lexer.getPosition())

            ret.pattern = node
        }

        return ret
    }

    function parseReturnExpression() -> ReturnExpression throws ParserError {
        mutable ret: ReturnExpression? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parseKeyword(returnKeyword)
            if success
                lexer.advance()

            if ret == null
                ret = ReturnExpression(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: Expression node = parseExpression() catch _(error) {
                 null
            }

            if ret == null
                ret = ReturnExpression(start, lexer.getPosition())

            ret.expression = node
        }

        return ret
    }

    function parseThrowExpression() -> ThrowExpression throws ParserError {
        mutable ret: ThrowExpression? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parseKeyword(throwKeyword)
            if success
                lexer.advance()

            if ret == null
                ret = ThrowExpression(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: Expression node = parseExpression() catch _(error) {
                 null
            }

            if ret == null
                ret = ThrowExpression(start, lexer.getPosition())

            ret.expression = node
        }

        return ret
    }

    function parseBreakExpression() -> BreakExpression throws ParserError {
        mutable ret: BreakExpression? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parseKeyword(breakKeyword)
            if success
                lexer.advance()

            if ret == null
                ret = BreakExpression(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: Expression node = parseExpression() catch _(error) {
                 null
            }

            if ret == null
                ret = BreakExpression(start, lexer.getPosition())

            ret.expression = node
        }

        return ret
    }

    function parsePattern() -> Pattern throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: WildcardPattern = parseWildcardPattern() catch _(error) {
                errors.append(error)
                break
            }

            return node
        }

        {
            let node: IdentifierPattern = parseIdentifierPattern() catch _(error) {
                errors.append(error)
                break
            }

            return node
        }

        {
            let node: TuplePattern = parseTuplePattern() catch _(error) {
                errors.append(error)
                break
            }

            return node
        }

        {
            let node: ExpressionPattern = parseExpressionPattern() catch _(error) {
                errors.append(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(start, errors)
    }

    function parseWildcardPattern() -> WildcardPattern throws ParserError {
        mutable ret: WildcardPattern? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parsePunctuation(underscore)
            if success
                lexer.advance()

            if ret == null
                ret = WildcardPattern(start, lexer.getPosition())
        }

        return ret
    }

    function parseIdentifierPattern() -> IdentifierPattern throws ParserError {
        mutable ret: IdentifierPattern? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let identifier: String? = lexer.parseIdentifier()
            if (identifier != null) && (identifier is Identifier)
                lexer.advance()

            if ret == null
                ret = IdentifierPattern(start, lexer.getPosition())

            ret.identifier = identifier
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: TypeAnnotation node = parseTypeAnnotation() catch _(error) {
                 null
            }

            if ret == null
                ret = IdentifierPattern(start, lexer.getPosition())

            ret.typeAnnotation = node
        }

        return ret
    }

    function parseTuplePattern() -> TuplePattern throws ParserError {
        mutable ret: TuplePattern? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parsePunctuation(leftParen)
            if success
                lexer.advance()

            if ret == null
                ret = TuplePattern(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: [TuplePatternElement] node = parseTuplePatternElementList() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = TuplePattern(start, lexer.getPosition())

            ret.elements = node
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parsePunctuation(rightParen)
            if success
                lexer.advance()

            if ret == null
                ret = TuplePattern(start, lexer.getPosition())
        }

        return ret
    }

    function parseTuplePatternElementList() -> [TuplePatternElement] throws ParserError {
        mutable ret: [TuplePatternElement]? = null

        while true {
            let node: TuplePatternElement = parseTuplePatternElement()
                catch _ break
            
            if ret == null
                ret = [TuplePatternElement]
                
            ret.append(node)
        }

        return ret
    }

    function parseTuplePatternElement() -> TuplePatternElement throws ParserError {
        mutable ret: TuplePatternElement? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let result: Pattern node = parsePattern() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = TuplePatternElement(start, lexer.getPosition())

            ret.pattern = node
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parsePunctuation(comma)
            if success
                lexer.advance()

            if ret == null
                ret = TuplePatternElement(start, lexer.getPosition())
        }

        return ret
    }

    function parseExpressionPattern() -> ExpressionPattern throws ParserError {
        mutable ret: ExpressionPattern? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let result: Expression node = parseExpression() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = ExpressionPattern(start, lexer.getPosition())

            ret.expression = node
        }

        return ret
    }

    function parseDefaultCaseLabel() -> DefaultCaseLabel throws ParserError {
        mutable ret: DefaultCaseLabel? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parseKeyword(defaultKeyword)
            if success
                lexer.advance()

            if ret == null
                ret = DefaultCaseLabel(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parsePunctuation(colon)
            if success
                lexer.advance()

            if ret == null
                ret = DefaultCaseLabel(start, lexer.getPosition())
        }

        return ret
    }

    function parseCaseContent() -> CaseContent throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: BlockCaseContent = parseBlockCaseContent() catch _(error) {
                errors.append(error)
                break
            }

            return node
        }

        {
            let node: EmptyCaseContent = parseEmptyCaseContent() catch _(error) {
                errors.append(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(start, errors)
    }

    function parseBlockCaseContent() -> BlockCaseContent throws ParserError {
        mutable ret: BlockCaseContent? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let result: [StatementWithSemicolon] node = parseStatementWithSemicolonList() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = BlockCaseContent(start, lexer.getPosition())

            ret.statements = node
        }

        return ret
    }

    function parseEmptyCaseContent() -> EmptyCaseContent throws ParserError {
        mutable ret: EmptyCaseContent? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parsePunctuation(semicolon)
            if success
                lexer.advance()

            if ret == null
                ret = EmptyCaseContent(start, lexer.getPosition())
        }

        return ret
    }

    function parseInitializerCall() -> InitializerCall throws ParserError {
        mutable ret: InitializerCall? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let result: Type node = parseType() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = InitializerCall(start, lexer.getPosition())

            ret.typeToInitialize = node
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: ParenthesizedExpression node = parseParenthesizedExpression() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = InitializerCall(start, lexer.getPosition())

            ret.arguments = node
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: [CatchClause] node = parseCatchClauseList() catch _(error) {
                 null
            }

            if ret == null
                ret = InitializerCall(start, lexer.getPosition())

            ret.catchClauses = node
        }

        return ret
    }

    function parseThisExpression() -> ThisExpression throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: ThisDot = parseThisDot() catch _(error) {
                errors.append(error)
                break
            }

            return node
        }

        {
            let node: ThisSubscript = parseThisSubscript() catch _(error) {
                errors.append(error)
                break
            }

            return node
        }

        {
            let node: This = parseThis() catch _(error) {
                errors.append(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(start, errors)
    }

    function parseThisDot() -> ThisDot throws ParserError {
        mutable ret: ThisDot? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parseKeyword(thisKeyword)
            if success
                lexer.advance()

            if ret == null
                ret = ThisDot(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parsePunctuation(dot)
            if success
                lexer.advance()

            if ret == null
                ret = ThisDot(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: CommonThisMember node = parseCommonThisMember() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = ThisDot(start, lexer.getPosition())

            ret.member = node
        }

        return ret
    }

    function parseThisSubscript() -> ThisSubscript throws ParserError {
        mutable ret: ThisSubscript? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parseKeyword(thisKeyword)
            if success
                lexer.advance()

            if ret == null
                ret = ThisSubscript(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: Subscript node = parseSubscript() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = ThisSubscript(start, lexer.getPosition())

            ret.subscript = node
        }

        return ret
    }

    function parseThis() -> This throws ParserError {
        mutable ret: This? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parseKeyword(thisKeyword)
            if success
                lexer.advance()

            if ret == null
                ret = This(start, lexer.getPosition())
        }

        return ret
    }

    function parseCommonThisMember() -> CommonThisMember throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: ThisInit = parseThisInit() catch _(error) {
                errors.append(error)
                break
            }

            return node
        }

        {
            let node: ThisMember = parseThisMember() catch _(error) {
                errors.append(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(start, errors)
    }

    function parseThisInit() -> ThisInit throws ParserError {
        mutable ret: ThisInit? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parseKeyword(initKeyword)
            if success
                lexer.advance()

            if ret == null
                ret = ThisInit(start, lexer.getPosition())
        }

        return ret
    }

    function parseThisMember() -> ThisMember throws ParserError {
        mutable ret: ThisMember? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let name: String? = lexer.parseIdentifier()
            if (name != null) && (name is Identifier)
                lexer.advance()

            if ret == null
                ret = ThisMember(start, lexer.getPosition())

            ret.name = name
        }

        return ret
    }

    function parseSuperExpression() -> SuperExpression throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: SuperDot = parseSuperDot() catch _(error) {
                errors.append(error)
                break
            }

            return node
        }

        {
            let node: SuperSubscript = parseSuperSubscript() catch _(error) {
                errors.append(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(start, errors)
    }

    function parseSuperDot() -> SuperDot throws ParserError {
        mutable ret: SuperDot? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parseKeyword(superKeyword)
            if success
                lexer.advance()

            if ret == null
                ret = SuperDot(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parsePunctuation(dot)
            if success
                lexer.advance()

            if ret == null
                ret = SuperDot(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: CommonSuperMember node = parseCommonSuperMember() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = SuperDot(start, lexer.getPosition())

            ret.member = node
        }

        return ret
    }

    function parseSuperSubscript() -> SuperSubscript throws ParserError {
        mutable ret: SuperSubscript? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parseKeyword(superKeyword)
            if success
                lexer.advance()

            if ret == null
                ret = SuperSubscript(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: Subscript node = parseSubscript() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = SuperSubscript(start, lexer.getPosition())

            ret.subscript = node
        }

        return ret
    }

    function parseCommonSuperMember() -> CommonSuperMember throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: SuperInit = parseSuperInit() catch _(error) {
                errors.append(error)
                break
            }

            return node
        }

        {
            let node: SuperMember = parseSuperMember() catch _(error) {
                errors.append(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(start, errors)
    }

    function parseSuperInit() -> SuperInit throws ParserError {
        mutable ret: SuperInit? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parseKeyword(initKeyword)
            if success
                lexer.advance()

            if ret == null
                ret = SuperInit(start, lexer.getPosition())
        }

        return ret
    }

    function parseSuperMember() -> SuperMember throws ParserError {
        mutable ret: SuperMember? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let name: String? = lexer.parseIdentifier()
            if (name != null) && (name is Identifier)
                lexer.advance()

            if ret == null
                ret = SuperMember(start, lexer.getPosition())

            ret.name = name
        }

        return ret
    }

    function parseType() -> Type throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: ArrayType = parseArrayType() catch _(error) {
                errors.append(error)
                break
            }

            return node
        }

        {
            let node: TypeIdentifier = parseTypeIdentifier() catch _(error) {
                errors.append(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(start, errors)
    }

    function parseTypeAnnotation() -> TypeAnnotation throws ParserError {
        mutable ret: TypeAnnotation? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parsePunctuation(colon)
            if success
                lexer.advance()

            if ret == null
                ret = TypeAnnotation(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: Type node = parseType() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = TypeAnnotation(start, lexer.getPosition())

            ret.typeAnnotation = node
        }

        return ret
    }

    function parseTypeIdentifier() -> TypeIdentifier throws ParserError {
        mutable ret: TypeIdentifier? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let name: String? = lexer.parseIdentifier()
            if (name != null) && (name is Identifier)
                lexer.advance()

            if ret == null
                ret = TypeIdentifier(start, lexer.getPosition())

            ret.name = name
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: SubtypeIdentifier node = parseSubtypeIdentifier() catch _(error) {
                 null
            }

            if ret == null
                ret = TypeIdentifier(start, lexer.getPosition())

            ret.subType = node
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: [TypePostfix] node = parseTypePostfixList() catch _(error) {
                 null
            }

            if ret == null
                ret = TypeIdentifier(start, lexer.getPosition())

            ret.postfixes = node
        }

        return ret
    }

    function parseSubtypeIdentifier() -> SubtypeIdentifier throws ParserError {
        mutable ret: SubtypeIdentifier? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parsePunctuation(dot)
            if success
                lexer.advance()

            if ret == null
                ret = SubtypeIdentifier(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: TypeIdentifier node = parseTypeIdentifier() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = SubtypeIdentifier(start, lexer.getPosition())

            ret.typeIdentifier = node
        }

        return ret
    }

    function parseTypePostfixList() -> [TypePostfix] throws ParserError {
        mutable ret: [TypePostfix]? = null

        while true {
            let node: TypePostfix = parseTypePostfix()
                catch _ break
            
            if ret == null
                ret = [TypePostfix]
                
            ret.append(node)
        }

        return ret
    }

    function parseTypePostfix() -> TypePostfix throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: OptionalType = parseOptionalType() catch _(error) {
                errors.append(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(start, errors)
    }

    function parseArrayType() -> ArrayType throws ParserError {
        mutable ret: ArrayType? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parsePunctuation(leftBracket)
            if success
                lexer.advance()

            if ret == null
                ret = ArrayType(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: Type node = parseType() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = ArrayType(start, lexer.getPosition())

            ret.elementType = node
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parsePunctuation(rightBracket)
            if success
                lexer.advance()

            if ret == null
                ret = ArrayType(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: [TypePostfix] node = parseTypePostfixList() catch _(error) {
                 null
            }

            if ret == null
                ret = ArrayType(start, lexer.getPosition())

            ret.postfixes = node
        }

        return ret
    }

    function parseOptionalType() -> OptionalType throws ParserError {
        mutable ret: OptionalType? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parsePunctuation(questionMark)
            if success
                lexer.advance()

            if ret == null
                ret = OptionalType(start, lexer.getPosition())
        }

        return ret
    }

    function parseTypeInheritanceClause() -> TypeInheritanceClause throws ParserError {
        mutable ret: TypeInheritanceClause? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parsePunctuation(colon)
            if success
                lexer.advance()

            if ret == null
                ret = TypeInheritanceClause(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let result: [Inheritance] node = parseInheritanceList() catch _(error) {
                 null
            }

            if ret == null
                ret = TypeInheritanceClause(start, lexer.getPosition())

            ret.inheritances = node
        }

        return ret
    }

    function parseInheritanceList() -> [Inheritance] throws ParserError {
        mutable ret: [Inheritance]? = null

        while true {
            let node: Inheritance = parseInheritance()
                catch _ break
            
            if ret == null
                ret = [Inheritance]
                
            ret.append(node)
        }

        return ret
    }

    function parseInheritance() -> Inheritance throws ParserError {
        mutable ret: Inheritance? = null
        {
            let start: Position = lexer.getPreviousPosition()
            let result: TypeIdentifier node = parseTypeIdentifier() catch _(error) {
                throw (error)
            }

            if ret == null
                ret = Inheritance(start, lexer.getPosition())

            ret.name = node
        }
        {
            let start: Position = lexer.getPreviousPosition()
            let success: bool = lexer.parsePunctuation(comma)
            if success
                lexer.advance()

            if ret == null
                ret = Inheritance(start, lexer.getPosition())
        }

        return ret
    }

    function isAtEnd() -> bool {
        lexer.isAtEnd()
    }
    
    function isIdentifier(id: String) -> bool {
        if id == useKeyword
            return false

        if id == classKeyword
            return false

        if id == functionKeyword
            return false

        if id == ifKeyword
            return false

        if id == elseKeyword
            return false

        if id == switchKeyword
            return false

        if id == caseKeyword
            return false

        if id == defaultKeyword
            return false

        if id == catchKeyword
            return false

        if id == returnKeyword
            return false

        if id == throwKeyword
            return false

        if id == breakKeyword
            return false

        if id == throwsKeyword
            return false

        if id == staticKeyword
            return false

        if id == letKeyword
            return false

        if id == mutableKeyword
            return false

        if id == isKeyword
            return false

        if id == asKeyword
            return false

        if id == initKeyword
            return false

        if id == enumKeyword
            return false

        if id == superKeyword
            return false

        if id == thisKeyword
            return false

        true
    }

    mutable lexer: Lexer

    let useKeyword: string = "use"
    let classKeyword: string = "class"
    let functionKeyword: string = "function"
    let ifKeyword: string = "if"
    let elseKeyword: string = "else"
    let switchKeyword: string = "switch"
    let caseKeyword: string = "case"
    let defaultKeyword: string = "default"
    let catchKeyword: string = "catch"
    let returnKeyword: string = "return"
    let throwKeyword: string = "throw"
    let breakKeyword: string = "break"
    let throwsKeyword: string = "throws"
    let staticKeyword: string = "static"
    let letKeyword: string = "let"
    let mutableKeyword: string = "mutable"
    let isKeyword: string = "is"
    let asKeyword: string = "as"
    let initKeyword: string = "init"
    let enumKeyword: string = "enum"
    let superKeyword: string = "super"
    let thisKeyword: string = "this"
    let semicolon: string = ";"
    let equal: string = "="
    let leftAngular: string = "<"
    let rightAngular: string = ">"
    let comma: string = ","
    let leftParen: string = "("
    let rightParen: string = ")"
    let leftCurly: string = "{"
    let rightCurly: string = "}"
    let leftBracket: string = "["
    let rightBracket: string = "]"
    let colon: string = ":"
    let dot: string = "."
    let questionMark: string = "?"
    let underscore: string = "_"
    let evaluatesTo: string = "->"
}
