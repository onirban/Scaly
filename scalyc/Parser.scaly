class Parser {
    init(fileName: String, text: String) {
        lexer = Lexer(text)
    }

    function parseCompilationUnit() -> CompilationUnit throws ParserError {
        mutable compilationUnit: CompilationUnit? = null
        {
            let start: Position = lexer.getPosition()
            let result: [StatementWithSemicolon] node = parseStatementWithSemicolonList() catch _(error) {
                 null
            }
            if !isAtEnd() {
                let current: Position = lexer.getPreviousPosition()
                throw ParserError.NotAtEnd(current)
            }

            if compilationUnit == null
                compilationUnit = CompilationUnit(start, lexer.getPosition())

            compilationUnit.statements = node
        }

        compilationUnit.fileName = fileName;
        return compilationUnit
    }

    function parseStatementWithSemicolonList() -> [StatementWithSemicolon] throws ParserError {
        mutable (string-firstchar-downcase statementWithSemicolon): [StatementWithSemicolon]? = [StatementWithSemicolon]()
        while true
            statementWithSemicolon.push(parseStatementWithSemicolon() catch _ break)
        return statementWithSemicolon
    }

    function parseStatementWithSemicolon() -> StatementWithSemicolon throws ParserError {
        mutable statementWithSemicolon: StatementWithSemicolon? = null
        {
            let start: Position = lexer.getPosition()
            let result: Statement node = parseStatement() catch _(error) {
                throw (error)
            }

            if statementWithSemicolon == null
                statementWithSemicolon = StatementWithSemicolon(start, lexer.getPosition())

            statementWithSemicolon.statement = node
        }
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parsePunctuation(semicolon)
            if success
                lexer.advance()

            if statementWithSemicolon == null
                statementWithSemicolon = StatementWithSemicolon(start, lexer.getPosition())
        }

        return statementWithSemicolon
    }

    function parseStatement() -> Statement throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: Declaration = parseDeclaration() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: Expression = parseExpression() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(start, errors)
    }

    function parseDeclaration() -> Declaration throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: UseDeclaration = parseUseDeclaration() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: ConstantDeclaration = parseConstantDeclaration() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: VariableDeclaration = parseVariableDeclaration() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: FunctionDeclaration = parseFunctionDeclaration() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: EnumDeclaration = parseEnumDeclaration() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: ClassDeclaration = parseClassDeclaration() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: InitializerDeclaration = parseInitializerDeclaration() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(start, errors)
    }

    function parseUseDeclaration() -> UseDeclaration throws ParserError {
        mutable useDeclaration: UseDeclaration? = null
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parseKeyword(useKeyword)
            if success
                lexer.advance()

            if useDeclaration == null
                useDeclaration = UseDeclaration(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPosition()
            let result: PathItem node = parsePathItem() catch _(error) {
                throw (error)
            }

            if useDeclaration == null
                useDeclaration = UseDeclaration(start, lexer.getPosition())

            useDeclaration.importModule = node
        }
        {
            let start: Position = lexer.getPosition()
            let result: [PathIdentifier] node = parsePathIdentifierList() catch _(error) {
                 null
            }

            if useDeclaration == null
                useDeclaration = UseDeclaration(start, lexer.getPosition())

            useDeclaration.importExtensions = node
        }

        return useDeclaration
    }

    function parseConstantDeclaration() -> ConstantDeclaration throws ParserError {
        mutable constantDeclaration: ConstantDeclaration? = null
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parseKeyword(letKeyword)
            if success
                lexer.advance()

            if constantDeclaration == null
                constantDeclaration = ConstantDeclaration(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPosition()
            let result: BindingInitializer node = parseBindingInitializer() catch _(error) {
                throw (error)
            }

            if constantDeclaration == null
                constantDeclaration = ConstantDeclaration(start, lexer.getPosition())

            constantDeclaration.initializer = node
        }

        return constantDeclaration
    }

    function parseVariableDeclaration() -> VariableDeclaration throws ParserError {
        mutable variableDeclaration: VariableDeclaration? = null
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parseKeyword(mutableKeyword)
            if success
                lexer.advance()

            if variableDeclaration == null
                variableDeclaration = VariableDeclaration(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPosition()
            let result: BindingInitializer node = parseBindingInitializer() catch _(error) {
                throw (error)
            }

            if variableDeclaration == null
                variableDeclaration = VariableDeclaration(start, lexer.getPosition())

            variableDeclaration.initializer = node
        }

        return variableDeclaration
    }

    function parseFunctionDeclaration() -> FunctionDeclaration throws ParserError {
        mutable functionDeclaration: FunctionDeclaration? = null
        {
            let start: Position = lexer.getPosition()
            let result: [Modifier] node = parseModifierList() catch _(error) {
                 null
            }

            if functionDeclaration == null
                functionDeclaration = FunctionDeclaration(start, lexer.getPosition())

            functionDeclaration.modifiers = node
        }
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parseKeyword(functionKeyword)
            if success
                lexer.advance()

            if functionDeclaration == null
                functionDeclaration = FunctionDeclaration(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPosition()
            let result: FunctionName node = parseFunctionName() catch _(error) {
                throw (error)
            }

            if functionDeclaration == null
                functionDeclaration = FunctionDeclaration(start, lexer.getPosition())

            functionDeclaration.name = node
        }
        {
            let start: Position = lexer.getPosition()
            let result: FunctionSignature node = parseFunctionSignature() catch _(error) {
                throw (error)
            }

            if functionDeclaration == null
                functionDeclaration = FunctionDeclaration(start, lexer.getPosition())

            functionDeclaration.signature = node
        }
        {
            let start: Position = lexer.getPosition()
            let result: Expression node = parseExpression() catch _(error) {
                 null
            }

            if functionDeclaration == null
                functionDeclaration = FunctionDeclaration(start, lexer.getPosition())

            functionDeclaration.body = node
        }

        return functionDeclaration
    }

    function parseEnumDeclaration() -> EnumDeclaration throws ParserError {
        mutable enumDeclaration: EnumDeclaration? = null
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parseKeyword(enumKeyword)
            if success
                lexer.advance()

            if enumDeclaration == null
                enumDeclaration = EnumDeclaration(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPosition()
            let name: String? = lexer.parseIdentifier()
            if (name != null) && (name is Identifier)
                lexer.advance()

            if enumDeclaration == null
                enumDeclaration = EnumDeclaration(start, lexer.getPosition())

            enumDeclaration.name = name
        }
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parsePunctuation(leftCurly)
            if success
                lexer.advance()

            if enumDeclaration == null
                enumDeclaration = EnumDeclaration(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPosition()
            let result: [EnumMember] node = parseEnumMemberList() catch _(error) {
                throw (error)
            }

            if enumDeclaration == null
                enumDeclaration = EnumDeclaration(start, lexer.getPosition())

            enumDeclaration.members = node
        }
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parsePunctuation(rightCurly)
            if success
                lexer.advance()

            if enumDeclaration == null
                enumDeclaration = EnumDeclaration(start, lexer.getPosition())
        }

        return enumDeclaration
    }

    function parseClassDeclaration() -> ClassDeclaration throws ParserError {
        mutable classDeclaration: ClassDeclaration? = null
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parseKeyword(classKeyword)
            if success
                lexer.advance()

            if classDeclaration == null
                classDeclaration = ClassDeclaration(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPosition()
            let name: String? = lexer.parseIdentifier()
            if (name != null) && (name is Identifier)
                lexer.advance()

            if classDeclaration == null
                classDeclaration = ClassDeclaration(start, lexer.getPosition())

            classDeclaration.name = name
        }
        {
            let start: Position = lexer.getPosition()
            let result: GenericArgumentClause node = parseGenericArgumentClause() catch _(error) {
                 null
            }

            if classDeclaration == null
                classDeclaration = ClassDeclaration(start, lexer.getPosition())

            classDeclaration.genericArgumentClause = node
        }
        {
            let start: Position = lexer.getPosition()
            let result: TypeInheritanceClause node = parseTypeInheritanceClause() catch _(error) {
                 null
            }

            if classDeclaration == null
                classDeclaration = ClassDeclaration(start, lexer.getPosition())

            classDeclaration.typeInheritanceClause = node
        }
        {
            let start: Position = lexer.getPosition()
            let result: ClassBody node = parseClassBody() catch _(error) {
                 null
            }

            if classDeclaration == null
                classDeclaration = ClassDeclaration(start, lexer.getPosition())

            classDeclaration.body = node
        }

        return classDeclaration
    }

    function parseInitializerDeclaration() -> InitializerDeclaration throws ParserError {
        mutable initializerDeclaration: InitializerDeclaration? = null
        {
            let start: Position = lexer.getPosition()
            let result: [Modifier] node = parseModifierList() catch _(error) {
                 null
            }

            if initializerDeclaration == null
                initializerDeclaration = InitializerDeclaration(start, lexer.getPosition())

            initializerDeclaration.modifiers = node
        }
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parseKeyword(initKeyword)
            if success
                lexer.advance()

            if initializerDeclaration == null
                initializerDeclaration = InitializerDeclaration(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPosition()
            let result: ParameterClause node = parseParameterClause() catch _(error) {
                throw (error)
            }

            if initializerDeclaration == null
                initializerDeclaration = InitializerDeclaration(start, lexer.getPosition())

            initializerDeclaration.parameterClause = node
        }
        {
            let start: Position = lexer.getPosition()
            let result: ThrowsClause node = parseThrowsClause() catch _(error) {
                 null
            }

            if initializerDeclaration == null
                initializerDeclaration = InitializerDeclaration(start, lexer.getPosition())

            initializerDeclaration.throwsClause = node
        }
        {
            let start: Position = lexer.getPosition()
            let result: Expression node = parseExpression() catch _(error) {
                throw (error)
            }

            if initializerDeclaration == null
                initializerDeclaration = InitializerDeclaration(start, lexer.getPosition())

            initializerDeclaration.body = node
        }

        return initializerDeclaration
    }

    function parseExpression() -> Expression throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: CodeBlock = parseCodeBlock() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: SimpleExpression = parseSimpleExpression() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(start, errors)
    }

    function parseCodeBlock() -> CodeBlock throws ParserError {
        mutable codeBlock: CodeBlock? = null
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parsePunctuation(leftCurly)
            if success
                lexer.advance()

            if codeBlock == null
                codeBlock = CodeBlock(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPosition()
            let result: [StatementWithSemicolon] node = parseStatementWithSemicolonList() catch _(error) {
                throw (error)
            }

            if codeBlock == null
                codeBlock = CodeBlock(start, lexer.getPosition())

            codeBlock.statements = node
        }
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parsePunctuation(rightCurly)
            if success
                lexer.advance()

            if codeBlock == null
                codeBlock = CodeBlock(start, lexer.getPosition())
        }

        return codeBlock
    }

    function parseSimpleExpression() -> SimpleExpression throws ParserError {
        mutable simpleExpression: SimpleExpression? = null
        {
            let start: Position = lexer.getPosition()
            let result: PrefixExpression node = parsePrefixExpression() catch _(error) {
                throw (error)
            }

            if simpleExpression == null
                simpleExpression = SimpleExpression(start, lexer.getPosition())

            simpleExpression.prefixExpression = node
        }
        {
            let start: Position = lexer.getPosition()
            let result: [BinaryOp] node = parseBinaryOpList() catch _(error) {
                 null
            }

            if simpleExpression == null
                simpleExpression = SimpleExpression(start, lexer.getPosition())

            simpleExpression.binaryOps = node
        }

        return simpleExpression
    }

    function parsePathIdentifierList() -> [PathIdentifier] throws ParserError {
        mutable (string-firstchar-downcase pathIdentifier): [PathIdentifier]? = [PathIdentifier]()
        while true
            pathIdentifier.push(parsePathIdentifier() catch _ break)
        return pathIdentifier
    }

    function parsePathIdentifier() -> PathIdentifier throws ParserError {
        mutable pathIdentifier: PathIdentifier? = null
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parsePunctuation(dot)
            if success
                lexer.advance()

            if pathIdentifier == null
                pathIdentifier = PathIdentifier(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPosition()
            let result: PathItem node = parsePathItem() catch _(error) {
                throw (error)
            }

            if pathIdentifier == null
                pathIdentifier = PathIdentifier(start, lexer.getPosition())

            pathIdentifier.extension = node
        }

        return pathIdentifier
    }

    function parsePathItem() -> PathItem throws ParserError {
        mutable pathItem: PathItem? = null
        {
            let start: Position = lexer.getPosition()
            let name: String? = lexer.parseIdentifier()
            if (name != null) && (name is Identifier)
                lexer.advance()

            if pathItem == null
                pathItem = PathItem(start, lexer.getPosition())

            pathItem.name = name
        }

        return pathItem
    }

    function parseInitializer() -> Initializer throws ParserError {
        mutable initializer: Initializer? = null
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parsePunctuation(equal)
            if success
                lexer.advance()

            if initializer == null
                initializer = Initializer(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPosition()
            let result: Expression node = parseExpression() catch _(error) {
                throw (error)
            }

            if initializer == null
                initializer = Initializer(start, lexer.getPosition())

            initializer.expression = node
        }

        return initializer
    }

    function parseBindingInitializer() -> BindingInitializer throws ParserError {
        mutable bindingInitializer: BindingInitializer? = null
        {
            let start: Position = lexer.getPosition()
            let result: PatternInitializer node = parsePatternInitializer() catch _(error) {
                throw (error)
            }

            if bindingInitializer == null
                bindingInitializer = BindingInitializer(start, lexer.getPosition())

            bindingInitializer.initializer = node
        }
        {
            let start: Position = lexer.getPosition()
            let result: [AdditionalInitializer] node = parseAdditionalInitializerList() catch _(error) {
                 null
            }

            if bindingInitializer == null
                bindingInitializer = BindingInitializer(start, lexer.getPosition())

            bindingInitializer.additionalInitializers = node
        }

        return bindingInitializer
    }

    function parsePatternInitializerList() -> [PatternInitializer] throws ParserError {
        mutable (string-firstchar-downcase patternInitializer): [PatternInitializer]? = [PatternInitializer]()
        while true
            patternInitializer.push(parsePatternInitializer() catch _ break)
        return patternInitializer
    }

    function parsePatternInitializer() -> PatternInitializer throws ParserError {
        mutable patternInitializer: PatternInitializer? = null
        {
            let start: Position = lexer.getPosition()
            let result: Pattern node = parsePattern() catch _(error) {
                throw (error)
            }

            if patternInitializer == null
                patternInitializer = PatternInitializer(start, lexer.getPosition())

            patternInitializer.pattern = node
        }
        {
            let start: Position = lexer.getPosition()
            let result: Initializer node = parseInitializer() catch _(error) {
                 null
            }

            if patternInitializer == null
                patternInitializer = PatternInitializer(start, lexer.getPosition())

            patternInitializer.initializer = node
        }

        return patternInitializer
    }

    function parseAdditionalInitializerList() -> [AdditionalInitializer] throws ParserError {
        mutable (string-firstchar-downcase additionalInitializer): [AdditionalInitializer]? = [AdditionalInitializer]()
        while true
            additionalInitializer.push(parseAdditionalInitializer() catch _ break)
        return additionalInitializer
    }

    function parseAdditionalInitializer() -> AdditionalInitializer throws ParserError {
        mutable additionalInitializer: AdditionalInitializer? = null
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parsePunctuation(comma)
            if success
                lexer.advance()

            if additionalInitializer == null
                additionalInitializer = AdditionalInitializer(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPosition()
            let result: PatternInitializer node = parsePatternInitializer() catch _(error) {
                throw (error)
            }

            if additionalInitializer == null
                additionalInitializer = AdditionalInitializer(start, lexer.getPosition())

            additionalInitializer.pattern = node
        }

        return additionalInitializer
    }

    function parseModifierList() -> [Modifier] throws ParserError {
        mutable (string-firstchar-downcase modifier): [Modifier]? = [Modifier]()
        while true
            modifier.push(parseModifier() catch _ break)
        return modifier
    }

    function parseModifier() -> Modifier throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: OverrideWord = parseOverrideWord() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: StaticWord = parseStaticWord() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(start, errors)
    }

    function parseOverrideWord() -> OverrideWord throws ParserError {
        mutable overrideWord: OverrideWord? = null
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parseKeyword(overrideKeyword)
            if success
                lexer.advance()

            if overrideWord == null
                overrideWord = OverrideWord(start, lexer.getPosition())
        }

        return overrideWord
    }

    function parseStaticWord() -> StaticWord throws ParserError {
        mutable staticWord: StaticWord? = null
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parseKeyword(staticKeyword)
            if success
                lexer.advance()

            if staticWord == null
                staticWord = StaticWord(start, lexer.getPosition())
        }

        return staticWord
    }

    function parseFunctionName() -> FunctionName throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: IdentifierFunction = parseIdentifierFunction() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(start, errors)
    }

    function parseIdentifierFunction() -> IdentifierFunction throws ParserError {
        mutable identifierFunction: IdentifierFunction? = null
        {
            let start: Position = lexer.getPosition()
            let name: String? = lexer.parseIdentifier()
            if (name != null) && (name is Identifier)
                lexer.advance()

            if identifierFunction == null
                identifierFunction = IdentifierFunction(start, lexer.getPosition())

            identifierFunction.name = name
        }

        return identifierFunction
    }

    function parseFunctionSignature() -> FunctionSignature throws ParserError {
        mutable functionSignature: FunctionSignature? = null
        {
            let start: Position = lexer.getPosition()
            let result: ParameterClause node = parseParameterClause() catch _(error) {
                throw (error)
            }

            if functionSignature == null
                functionSignature = FunctionSignature(start, lexer.getPosition())

            functionSignature.parameterClause = node
        }
        {
            let start: Position = lexer.getPosition()
            let result: FunctionResult node = parseFunctionResult() catch _(error) {
                 null
            }

            if functionSignature == null
                functionSignature = FunctionSignature(start, lexer.getPosition())

            functionSignature.result = node
        }
        {
            let start: Position = lexer.getPosition()
            let result: ThrowsClause node = parseThrowsClause() catch _(error) {
                 null
            }

            if functionSignature == null
                functionSignature = FunctionSignature(start, lexer.getPosition())

            functionSignature.throwsClause = node
        }

        return functionSignature
    }

    function parseFunctionResult() -> FunctionResult throws ParserError {
        mutable functionResult: FunctionResult? = null
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parsePunctuation(evaluatesTo)
            if success
                lexer.advance()

            if functionResult == null
                functionResult = FunctionResult(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPosition()
            let result: Type node = parseType() catch _(error) {
                throw (error)
            }

            if functionResult == null
                functionResult = FunctionResult(start, lexer.getPosition())

            functionResult.resultType = node
        }

        return functionResult
    }

    function parseParameterClauseList() -> [ParameterClause] throws ParserError {
        mutable (string-firstchar-downcase parameterClause): [ParameterClause]? = [ParameterClause]()
        while true
            parameterClause.push(parseParameterClause() catch _ break)
        return parameterClause
    }

    function parseParameterClause() -> ParameterClause throws ParserError {
        mutable parameterClause: ParameterClause? = null
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parsePunctuation(leftParen)
            if success
                lexer.advance()

            if parameterClause == null
                parameterClause = ParameterClause(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPosition()
            let result: [Parameter] node = parseParameterList() catch _(error) {
                 null
            }

            if parameterClause == null
                parameterClause = ParameterClause(start, lexer.getPosition())

            parameterClause.parameters = node
        }
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parsePunctuation(rightParen)
            if success
                lexer.advance()

            if parameterClause == null
                parameterClause = ParameterClause(start, lexer.getPosition())
        }

        return parameterClause
    }

    function parseParameterList() -> [Parameter] throws ParserError {
        mutable (string-firstchar-downcase parameter): [Parameter]? = [Parameter]()
        while true
            parameter.push(parseParameter() catch _ break)
        return parameter
    }

    function parseParameter() -> Parameter throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: ConstParameter = parseConstParameter() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: VarParameter = parseVarParameter() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(start, errors)
    }

    function parseConstParameter() -> ConstParameter throws ParserError {
        mutable constParameter: ConstParameter? = null
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parseKeyword(letKeyword)
            if success
                lexer.advance()

            if constParameter == null
                constParameter = ConstParameter(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPosition()
            let name: String? = lexer.parseIdentifier()
            if (name != null) && (name is Identifier)
                lexer.advance()

            if constParameter == null
                constParameter = ConstParameter(start, lexer.getPosition())

            constParameter.name = name
        }
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parsePunctuation(colon)
            if success
                lexer.advance()

            if constParameter == null
                constParameter = ConstParameter(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPosition()
            let result: Type node = parseType() catch _(error) {
                throw (error)
            }

            if constParameter == null
                constParameter = ConstParameter(start, lexer.getPosition())

            constParameter.parameterType = node
        }
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parsePunctuation(comma)
            if success
                lexer.advance()

            if constParameter == null
                constParameter = ConstParameter(start, lexer.getPosition())
        }

        return constParameter
    }

    function parseVarParameter() -> VarParameter throws ParserError {
        mutable varParameter: VarParameter? = null
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parseKeyword(mutableKeyword)
            if success
                lexer.advance()

            if varParameter == null
                varParameter = VarParameter(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPosition()
            let name: String? = lexer.parseIdentifier()
            if (name != null) && (name is Identifier)
                lexer.advance()

            if varParameter == null
                varParameter = VarParameter(start, lexer.getPosition())

            varParameter.name = name
        }
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parsePunctuation(colon)
            if success
                lexer.advance()

            if varParameter == null
                varParameter = VarParameter(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPosition()
            let result: Type node = parseType() catch _(error) {
                throw (error)
            }

            if varParameter == null
                varParameter = VarParameter(start, lexer.getPosition())

            varParameter.parameterType = node
        }
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parsePunctuation(comma)
            if success
                lexer.advance()

            if varParameter == null
                varParameter = VarParameter(start, lexer.getPosition())
        }

        return varParameter
    }

    function parseThrowsClause() -> ThrowsClause throws ParserError {
        mutable throwsClause: ThrowsClause? = null
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parseKeyword(throwsKeyword)
            if success
                lexer.advance()

            if throwsClause == null
                throwsClause = ThrowsClause(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPosition()
            let result: Type node = parseType() catch _(error) {
                throw (error)
            }

            if throwsClause == null
                throwsClause = ThrowsClause(start, lexer.getPosition())

            throwsClause.throwsType = node
        }

        return throwsClause
    }

    function parseEnumMemberList() -> [EnumMember] throws ParserError {
        mutable (string-firstchar-downcase enumMember): [EnumMember]? = [EnumMember]()
        while true
            enumMember.push(parseEnumMember() catch _ break)
        return enumMember
    }

    function parseEnumMember() -> EnumMember throws ParserError {
        mutable enumMember: EnumMember? = null
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parseKeyword(caseKeyword)
            if success
                lexer.advance()

            if enumMember == null
                enumMember = EnumMember(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPosition()
            let result: EnumCase node = parseEnumCase() catch _(error) {
                throw (error)
            }

            if enumMember == null
                enumMember = EnumMember(start, lexer.getPosition())

            enumMember.enumCase = node
        }
        {
            let start: Position = lexer.getPosition()
            let result: [AdditionalCase] node = parseAdditionalCaseList() catch _(error) {
                 null
            }

            if enumMember == null
                enumMember = EnumMember(start, lexer.getPosition())

            enumMember.additionalCases = node
        }
        {
            let start: Position = lexer.getPosition()
            let result: TupleType node = parseTupleType() catch _(error) {
                 null
            }

            if enumMember == null
                enumMember = EnumMember(start, lexer.getPosition())

            enumMember.typeOfTuple = node
        }

        return enumMember
    }

    function parseTupleType() -> TupleType throws ParserError {
        mutable tupleType: TupleType? = null
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parsePunctuation(leftParen)
            if success
                lexer.advance()

            if tupleType == null
                tupleType = TupleType(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPosition()
            let result: Type node = parseType() catch _(error) {
                throw (error)
            }

            if tupleType == null
                tupleType = TupleType(start, lexer.getPosition())

            tupleType.typeOfTuple = node
        }
        {
            let start: Position = lexer.getPosition()
            let result: [AdditionalType] node = parseAdditionalTypeList() catch _(error) {
                 null
            }

            if tupleType == null
                tupleType = TupleType(start, lexer.getPosition())

            tupleType.additionalTypes = node
        }
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parsePunctuation(rightParen)
            if success
                lexer.advance()

            if tupleType == null
                tupleType = TupleType(start, lexer.getPosition())
        }

        return tupleType
    }

    function parseAdditionalTypeList() -> [AdditionalType] throws ParserError {
        mutable (string-firstchar-downcase additionalType): [AdditionalType]? = [AdditionalType]()
        while true
            additionalType.push(parseAdditionalType() catch _ break)
        return additionalType
    }

    function parseAdditionalType() -> AdditionalType throws ParserError {
        mutable additionalType: AdditionalType? = null
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parsePunctuation(comma)
            if success
                lexer.advance()

            if additionalType == null
                additionalType = AdditionalType(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPosition()
            let result: Type node = parseType() catch _(error) {
                throw (error)
            }

            if additionalType == null
                additionalType = AdditionalType(start, lexer.getPosition())

            additionalType.enumCase = node
        }

        return additionalType
    }

    function parseEnumCase() -> EnumCase throws ParserError {
        mutable enumCase: EnumCase? = null
        {
            let start: Position = lexer.getPosition()
            let name: String? = lexer.parseIdentifier()
            if (name != null) && (name is Identifier)
                lexer.advance()

            if enumCase == null
                enumCase = EnumCase(start, lexer.getPosition())

            enumCase.name = name
        }

        return enumCase
    }

    function parseAdditionalCaseList() -> [AdditionalCase] throws ParserError {
        mutable (string-firstchar-downcase additionalCase): [AdditionalCase]? = [AdditionalCase]()
        while true
            additionalCase.push(parseAdditionalCase() catch _ break)
        return additionalCase
    }

    function parseAdditionalCase() -> AdditionalCase throws ParserError {
        mutable additionalCase: AdditionalCase? = null
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parsePunctuation(comma)
            if success
                lexer.advance()

            if additionalCase == null
                additionalCase = AdditionalCase(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPosition()
            let result: EnumCase node = parseEnumCase() catch _(error) {
                throw (error)
            }

            if additionalCase == null
                additionalCase = AdditionalCase(start, lexer.getPosition())

            additionalCase.enumCase = node
        }

        return additionalCase
    }

    function parseClassBody() -> ClassBody throws ParserError {
        mutable classBody: ClassBody? = null
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parsePunctuation(leftCurly)
            if success
                lexer.advance()

            if classBody == null
                classBody = ClassBody(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPosition()
            let result: [ClassMember] node = parseClassMemberList() catch _(error) {
                 null
            }

            if classBody == null
                classBody = ClassBody(start, lexer.getPosition())

            classBody.members = node
        }
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parsePunctuation(rightCurly)
            if success
                lexer.advance()

            if classBody == null
                classBody = ClassBody(start, lexer.getPosition())
        }

        return classBody
    }

    function parseGenericArgumentClause() -> GenericArgumentClause throws ParserError {
        mutable genericArgumentClause: GenericArgumentClause? = null
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parsePunctuation(leftAngular)
            if success
                lexer.advance()

            if genericArgumentClause == null
                genericArgumentClause = GenericArgumentClause(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPosition()
            let result: [GenericParameter] node = parseGenericParameterList() catch _(error) {
                throw (error)
            }

            if genericArgumentClause == null
                genericArgumentClause = GenericArgumentClause(start, lexer.getPosition())

            genericArgumentClause.genericParameters = node
        }
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parsePunctuation(rightAngular)
            if success
                lexer.advance()

            if genericArgumentClause == null
                genericArgumentClause = GenericArgumentClause(start, lexer.getPosition())
        }

        return genericArgumentClause
    }

    function parseGenericParameterList() -> [GenericParameter] throws ParserError {
        mutable (string-firstchar-downcase genericParameter): [GenericParameter]? = [GenericParameter]()
        while true
            genericParameter.push(parseGenericParameter() catch _ break)
        return genericParameter
    }

    function parseGenericParameter() -> GenericParameter throws ParserError {
        mutable genericParameter: GenericParameter? = null
        {
            let start: Position = lexer.getPosition()
            let typeName: String? = lexer.parseIdentifier()
            if (typeName != null) && (typeName is Identifier)
                lexer.advance()

            if genericParameter == null
                genericParameter = GenericParameter(start, lexer.getPosition())

            genericParameter.typeName = typeName
        }

        return genericParameter
    }

    function parseClassMemberList() -> [ClassMember] throws ParserError {
        mutable (string-firstchar-downcase classMember): [ClassMember]? = [ClassMember]()
        while true
            classMember.push(parseClassMember() catch _ break)
        return classMember
    }

    function parseClassMember() -> ClassMember throws ParserError {
        mutable classMember: ClassMember? = null
        {
            let start: Position = lexer.getPosition()
            let result: Declaration node = parseDeclaration() catch _(error) {
                throw (error)
            }

            if classMember == null
                classMember = ClassMember(start, lexer.getPosition())

            classMember.declaration = node
        }
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parsePunctuation(semicolon)
            if success
                lexer.advance()

            if classMember == null
                classMember = ClassMember(start, lexer.getPosition())
        }

        return classMember
    }

    function parsePrefixExpression() -> PrefixExpression throws ParserError {
        mutable prefixExpression: PrefixExpression? = null
        {
            let start: Position = lexer.getPosition()
            let prefixOperator: String? = lexer.parsePrefixOperator()
            if prefixOperator != null
                lexer.advance()

            if prefixExpression == null
                prefixExpression = PrefixExpression(start, lexer.getPosition())

            prefixExpression.prefixOperator = prefixOperator
        }
        {
            let start: Position = lexer.getPosition()
            let result: PostfixExpression node = parsePostfixExpression() catch _(error) {
                throw (error)
            }

            if prefixExpression == null
                prefixExpression = PrefixExpression(start, lexer.getPosition())

            prefixExpression.expression = node
        }

        return prefixExpression
    }

    function parsePostfixExpression() -> PostfixExpression throws ParserError {
        mutable postfixExpression: PostfixExpression? = null
        {
            let start: Position = lexer.getPosition()
            let result: PrimaryExpression node = parsePrimaryExpression() catch _(error) {
                throw (error)
            }

            if postfixExpression == null
                postfixExpression = PostfixExpression(start, lexer.getPosition())

            postfixExpression.primaryExpression = node
        }
        {
            let start: Position = lexer.getPosition()
            let result: [Postfix] node = parsePostfixList() catch _(error) {
                 null
            }

            if postfixExpression == null
                postfixExpression = PostfixExpression(start, lexer.getPosition())

            postfixExpression.postfixes = node
        }

        return postfixExpression
    }

    function parseBinaryOpList() -> [BinaryOp] throws ParserError {
        mutable (string-firstchar-downcase binaryOp): [BinaryOp]? = [BinaryOp]()
        while true
            binaryOp.push(parseBinaryOp() catch _ break)
        return binaryOp
    }

    function parseBinaryOp() -> BinaryOp throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: BinaryOperation = parseBinaryOperation() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: Assignment = parseAssignment() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: TypeQuery = parseTypeQuery() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: TypeCast = parseTypeCast() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(start, errors)
    }

    function parseBinaryOperation() -> BinaryOperation throws ParserError {
        mutable binaryOperation: BinaryOperation? = null
        {
            let start: Position = lexer.getPosition()
            let binaryOperator: String? = lexer.parseBinaryOperator()
            if binaryOperator != null
                lexer.advance()

            if binaryOperation == null
                binaryOperation = BinaryOperation(start, lexer.getPosition())

            binaryOperation.binaryOperator = binaryOperator
        }
        {
            let start: Position = lexer.getPosition()
            let result: PrefixExpression node = parsePrefixExpression() catch _(error) {
                throw (error)
            }

            if binaryOperation == null
                binaryOperation = BinaryOperation(start, lexer.getPosition())

            binaryOperation.expression = node
        }

        return binaryOperation
    }

    function parseAssignment() -> Assignment throws ParserError {
        mutable assignment: Assignment? = null
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parsePunctuation(equal)
            if success
                lexer.advance()

            if assignment == null
                assignment = Assignment(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPosition()
            let result: PrefixExpression node = parsePrefixExpression() catch _(error) {
                throw (error)
            }

            if assignment == null
                assignment = Assignment(start, lexer.getPosition())

            assignment.expression = node
        }

        return assignment
    }

    function parseTypeQuery() -> TypeQuery throws ParserError {
        mutable typeQuery: TypeQuery? = null
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parseKeyword(isKeyword)
            if success
                lexer.advance()

            if typeQuery == null
                typeQuery = TypeQuery(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPosition()
            let result: Type node = parseType() catch _(error) {
                throw (error)
            }

            if typeQuery == null
                typeQuery = TypeQuery(start, lexer.getPosition())

            typeQuery.objectType = node
        }

        return typeQuery
    }

    function parseTypeCast() -> TypeCast throws ParserError {
        mutable typeCast: TypeCast? = null
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parseKeyword(asKeyword)
            if success
                lexer.advance()

            if typeCast == null
                typeCast = TypeCast(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPosition()
            let result: Type node = parseType() catch _(error) {
                throw (error)
            }

            if typeCast == null
                typeCast = TypeCast(start, lexer.getPosition())

            typeCast.objectType = node
        }

        return typeCast
    }

    function parseCatchClauseList() -> [CatchClause] throws ParserError {
        mutable (string-firstchar-downcase catchClause): [CatchClause]? = [CatchClause]()
        while true
            catchClause.push(parseCatchClause() catch _ break)
        return catchClause
    }

    function parseCatchClause() -> CatchClause throws ParserError {
        mutable catchClause: CatchClause? = null
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parseKeyword(catchKeyword)
            if success
                lexer.advance()

            if catchClause == null
                catchClause = CatchClause(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPosition()
            let result: CatchPattern node = parseCatchPattern() catch _(error) {
                throw (error)
            }

            if catchClause == null
                catchClause = CatchClause(start, lexer.getPosition())

            catchClause.catchPattern = node
        }
        {
            let start: Position = lexer.getPosition()
            let result: TuplePattern node = parseTuplePattern() catch _(error) {
                 null
            }

            if catchClause == null
                catchClause = CatchClause(start, lexer.getPosition())

            catchClause.bindingPattern = node
        }
        {
            let start: Position = lexer.getPosition()
            let result: Expression node = parseExpression() catch _(error) {
                throw (error)
            }

            if catchClause == null
                catchClause = CatchClause(start, lexer.getPosition())

            catchClause.expression = node
        }

        return catchClause
    }

    function parseCatchPattern() -> CatchPattern throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: WildCardCatchPattern = parseWildCardCatchPattern() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: PathItemCatchPattern = parsePathItemCatchPattern() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(start, errors)
    }

    function parseWildCardCatchPattern() -> WildCardCatchPattern throws ParserError {
        mutable wildCardCatchPattern: WildCardCatchPattern? = null
        {
            let start: Position = lexer.getPosition()
            let result: WildcardPattern node = parseWildcardPattern() catch _(error) {
                throw (error)
            }

            if wildCardCatchPattern == null
                wildCardCatchPattern = WildCardCatchPattern(start, lexer.getPosition())

            wildCardCatchPattern.pattern = node
        }

        return wildCardCatchPattern
    }

    function parsePathItemCatchPattern() -> PathItemCatchPattern throws ParserError {
        mutable pathItemCatchPattern: PathItemCatchPattern? = null
        {
            let start: Position = lexer.getPosition()
            let result: PathItem node = parsePathItem() catch _(error) {
                throw (error)
            }

            if pathItemCatchPattern == null
                pathItemCatchPattern = PathItemCatchPattern(start, lexer.getPosition())

            pathItemCatchPattern.catchCase = node
        }
        {
            let start: Position = lexer.getPosition()
            let result: [PathIdentifier] node = parsePathIdentifierList() catch _(error) {
                 null
            }

            if pathItemCatchPattern == null
                pathItemCatchPattern = PathItemCatchPattern(start, lexer.getPosition())

            pathItemCatchPattern.catchCaseExtensions = node
        }

        return pathItemCatchPattern
    }

    function parsePostfixList() -> [Postfix] throws ParserError {
        mutable (string-firstchar-downcase postfix): [Postfix]? = [Postfix]()
        while true
            postfix.push(parsePostfix() catch _ break)
        return postfix
    }

    function parsePostfix() -> Postfix throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: OperatorPostfix = parseOperatorPostfix() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: FunctionCall = parseFunctionCall() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: ExplicitMemberExpression = parseExplicitMemberExpression() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: Subscript = parseSubscript() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(start, errors)
    }

    function parseOperatorPostfix() -> OperatorPostfix throws ParserError {
        mutable operatorPostfix: OperatorPostfix? = null
        {
            let start: Position = lexer.getPosition()
            let postfixOperator: String? = lexer.parsePostfixOperator()
            if postfixOperator != null
                lexer.advance()

            if operatorPostfix == null
                operatorPostfix = OperatorPostfix(start, lexer.getPosition())

            operatorPostfix.postfixOperator = postfixOperator
        }

        return operatorPostfix
    }

    function parseFunctionCall() -> FunctionCall throws ParserError {
        mutable functionCall: FunctionCall? = null
        {
            let start: Position = lexer.getPosition()
            let result: ParenthesizedExpression node = parseParenthesizedExpression() catch _(error) {
                throw (error)
            }

            if functionCall == null
                functionCall = FunctionCall(start, lexer.getPosition())

            functionCall.arguments = node
        }
        {
            let start: Position = lexer.getPosition()
            let result: [CatchClause] node = parseCatchClauseList() catch _(error) {
                 null
            }

            if functionCall == null
                functionCall = FunctionCall(start, lexer.getPosition())

            functionCall.catchClauses = node
        }

        return functionCall
    }

    function parseExplicitMemberExpression() -> ExplicitMemberExpression throws ParserError {
        mutable explicitMemberExpression: ExplicitMemberExpression? = null
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parsePunctuation(dot)
            if success
                lexer.advance()

            if explicitMemberExpression == null
                explicitMemberExpression = ExplicitMemberExpression(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPosition()
            let result: MemberPostfix node = parseMemberPostfix() catch _(error) {
                throw (error)
            }

            if explicitMemberExpression == null
                explicitMemberExpression = ExplicitMemberExpression(start, lexer.getPosition())

            explicitMemberExpression.memberPostfix = node
        }

        return explicitMemberExpression
    }

    function parseSubscript() -> Subscript throws ParserError {
        mutable subscript: Subscript? = null
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parsePunctuation(leftBracket)
            if success
                lexer.advance()

            if subscript == null
                subscript = Subscript(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPosition()
            let result: [ExpressionElement] node = parseExpressionElementList() catch _(error) {
                throw (error)
            }

            if subscript == null
                subscript = Subscript(start, lexer.getPosition())

            subscript.expressions = node
        }
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parsePunctuation(rightBracket)
            if success
                lexer.advance()

            if subscript == null
                subscript = Subscript(start, lexer.getPosition())
        }

        return subscript
    }

    function parseExpressionElementList() -> [ExpressionElement] throws ParserError {
        mutable (string-firstchar-downcase expressionElement): [ExpressionElement]? = [ExpressionElement]()
        while true
            expressionElement.push(parseExpressionElement() catch _ break)
        return expressionElement
    }

    function parseExpressionElement() -> ExpressionElement throws ParserError {
        mutable expressionElement: ExpressionElement? = null
        {
            let start: Position = lexer.getPosition()
            let result: Expression node = parseExpression() catch _(error) {
                throw (error)
            }

            if expressionElement == null
                expressionElement = ExpressionElement(start, lexer.getPosition())

            expressionElement.expression = node
        }
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parsePunctuation(comma)
            if success
                lexer.advance()

            if expressionElement == null
                expressionElement = ExpressionElement(start, lexer.getPosition())
        }

        return expressionElement
    }

    function parseMemberPostfix() -> MemberPostfix throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: NamedMemberPostfix = parseNamedMemberPostfix() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(start, errors)
    }

    function parseNamedMemberPostfix() -> NamedMemberPostfix throws ParserError {
        mutable namedMemberPostfix: NamedMemberPostfix? = null
        {
            let start: Position = lexer.getPosition()
            let result: IdentifierExpression node = parseIdentifierExpression() catch _(error) {
                throw (error)
            }

            if namedMemberPostfix == null
                namedMemberPostfix = NamedMemberPostfix(start, lexer.getPosition())

            namedMemberPostfix.identifier = node
        }

        return namedMemberPostfix
    }

    function parsePrimaryExpression() -> PrimaryExpression throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: IdentifierExpression = parseIdentifierExpression() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: LiteralExpression = parseLiteralExpression() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: IfExpression = parseIfExpression() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: SwitchExpression = parseSwitchExpression() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: ForExpression = parseForExpression() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: ParenthesizedExpression = parseParenthesizedExpression() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: ReturnExpression = parseReturnExpression() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: ThrowExpression = parseThrowExpression() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: BreakExpression = parseBreakExpression() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: InitializerCall = parseInitializerCall() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: ThisExpression = parseThisExpression() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: SuperExpression = parseSuperExpression() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(start, errors)
    }

    function parseParenthesizedExpression() -> ParenthesizedExpression throws ParserError {
        mutable parenthesizedExpression: ParenthesizedExpression? = null
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parsePunctuation(leftParen)
            if success
                lexer.advance()

            if parenthesizedExpression == null
                parenthesizedExpression = ParenthesizedExpression(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPosition()
            let result: [ExpressionElement] node = parseExpressionElementList() catch _(error) {
                 null
            }

            if parenthesizedExpression == null
                parenthesizedExpression = ParenthesizedExpression(start, lexer.getPosition())

            parenthesizedExpression.expressionElements = node
        }
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parsePunctuation(rightParen)
            if success
                lexer.advance()

            if parenthesizedExpression == null
                parenthesizedExpression = ParenthesizedExpression(start, lexer.getPosition())
        }

        return parenthesizedExpression
    }

    function parseLiteralExpression() -> LiteralExpression throws ParserError {
        mutable literalExpression: LiteralExpression? = null
        {
            let start: Position = lexer.getPosition()
            let literal: Literal? = lexer.parseLiteral()
            if literal != null
                lexer.advance()

            if literalExpression == null
                literalExpression = LiteralExpression(start, lexer.getPosition())

            literalExpression.literal = literal
        }

        return literalExpression
    }

    function parseIdentifierExpression() -> IdentifierExpression throws ParserError {
        mutable identifierExpression: IdentifierExpression? = null
        {
            let start: Position = lexer.getPosition()
            let name: String? = lexer.parseIdentifier()
            if (name != null) && (name is Identifier)
                lexer.advance()

            if identifierExpression == null
                identifierExpression = IdentifierExpression(start, lexer.getPosition())

            identifierExpression.name = name
        }

        return identifierExpression
    }

    function parseIfExpression() -> IfExpression throws ParserError {
        mutable ifExpression: IfExpression? = null
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parseKeyword(ifKeyword)
            if success
                lexer.advance()

            if ifExpression == null
                ifExpression = IfExpression(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPosition()
            let result: Expression node = parseExpression() catch _(error) {
                throw (error)
            }

            if ifExpression == null
                ifExpression = IfExpression(start, lexer.getPosition())

            ifExpression.condition = node
        }
        {
            let start: Position = lexer.getPosition()
            let result: Expression node = parseExpression() catch _(error) {
                throw (error)
            }

            if ifExpression == null
                ifExpression = IfExpression(start, lexer.getPosition())

            ifExpression.consequent = node
        }
        {
            let start: Position = lexer.getPosition()
            let result: ElseClause node = parseElseClause() catch _(error) {
                 null
            }

            if ifExpression == null
                ifExpression = IfExpression(start, lexer.getPosition())

            ifExpression.elseClause = node
        }

        return ifExpression
    }

    function parseSwitchExpression() -> SwitchExpression throws ParserError {
        mutable switchExpression: SwitchExpression? = null
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parseKeyword(switchKeyword)
            if success
                lexer.advance()

            if switchExpression == null
                switchExpression = SwitchExpression(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPosition()
            let result: Expression node = parseExpression() catch _(error) {
                throw (error)
            }

            if switchExpression == null
                switchExpression = SwitchExpression(start, lexer.getPosition())

            switchExpression.expression = node
        }
        {
            let start: Position = lexer.getPosition()
            let result: SwitchBody node = parseSwitchBody() catch _(error) {
                throw (error)
            }

            if switchExpression == null
                switchExpression = SwitchExpression(start, lexer.getPosition())

            switchExpression.body = node
        }

        return switchExpression
    }

    function parseForExpression() -> ForExpression throws ParserError {
        mutable forExpression: ForExpression? = null
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parseKeyword(forKeyword)
            if success
                lexer.advance()

            if forExpression == null
                forExpression = ForExpression(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPosition()
            let result: ForLoop node = parseForLoop() catch _(error) {
                throw (error)
            }

            if forExpression == null
                forExpression = ForExpression(start, lexer.getPosition())

            forExpression.loop = node
        }

        return forExpression
    }

    function parseReturnExpression() -> ReturnExpression throws ParserError {
        mutable returnExpression: ReturnExpression? = null
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parseKeyword(returnKeyword)
            if success
                lexer.advance()

            if returnExpression == null
                returnExpression = ReturnExpression(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPosition()
            let result: Expression node = parseExpression() catch _(error) {
                 null
            }

            if returnExpression == null
                returnExpression = ReturnExpression(start, lexer.getPosition())

            returnExpression.expression = node
        }

        return returnExpression
    }

    function parseThrowExpression() -> ThrowExpression throws ParserError {
        mutable throwExpression: ThrowExpression? = null
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parseKeyword(throwKeyword)
            if success
                lexer.advance()

            if throwExpression == null
                throwExpression = ThrowExpression(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPosition()
            let result: Expression node = parseExpression() catch _(error) {
                 null
            }

            if throwExpression == null
                throwExpression = ThrowExpression(start, lexer.getPosition())

            throwExpression.expression = node
        }

        return throwExpression
    }

    function parseBreakExpression() -> BreakExpression throws ParserError {
        mutable breakExpression: BreakExpression? = null
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parseKeyword(breakKeyword)
            if success
                lexer.advance()

            if breakExpression == null
                breakExpression = BreakExpression(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPosition()
            let result: Expression node = parseExpression() catch _(error) {
                 null
            }

            if breakExpression == null
                breakExpression = BreakExpression(start, lexer.getPosition())

            breakExpression.expression = node
        }

        return breakExpression
    }

    function parseInitializerCall() -> InitializerCall throws ParserError {
        mutable initializerCall: InitializerCall? = null
        {
            let start: Position = lexer.getPosition()
            let result: Type node = parseType() catch _(error) {
                throw (error)
            }

            if initializerCall == null
                initializerCall = InitializerCall(start, lexer.getPosition())

            initializerCall.typeToInitialize = node
        }
        {
            let start: Position = lexer.getPosition()
            let result: ParenthesizedExpression node = parseParenthesizedExpression() catch _(error) {
                throw (error)
            }

            if initializerCall == null
                initializerCall = InitializerCall(start, lexer.getPosition())

            initializerCall.arguments = node
        }
        {
            let start: Position = lexer.getPosition()
            let result: [CatchClause] node = parseCatchClauseList() catch _(error) {
                 null
            }

            if initializerCall == null
                initializerCall = InitializerCall(start, lexer.getPosition())

            initializerCall.catchClauses = node
        }

        return initializerCall
    }

    function parseThisExpression() -> ThisExpression throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: ThisDot = parseThisDot() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: ThisSubscript = parseThisSubscript() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: ThisWord = parseThisWord() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(start, errors)
    }

    function parseThisDot() -> ThisDot throws ParserError {
        mutable thisDot: ThisDot? = null
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parseKeyword(thisKeyword)
            if success
                lexer.advance()

            if thisDot == null
                thisDot = ThisDot(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parsePunctuation(dot)
            if success
                lexer.advance()

            if thisDot == null
                thisDot = ThisDot(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPosition()
            let result: CommonThisMember node = parseCommonThisMember() catch _(error) {
                throw (error)
            }

            if thisDot == null
                thisDot = ThisDot(start, lexer.getPosition())

            thisDot.member = node
        }

        return thisDot
    }

    function parseThisSubscript() -> ThisSubscript throws ParserError {
        mutable thisSubscript: ThisSubscript? = null
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parseKeyword(thisKeyword)
            if success
                lexer.advance()

            if thisSubscript == null
                thisSubscript = ThisSubscript(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPosition()
            let result: Subscript node = parseSubscript() catch _(error) {
                throw (error)
            }

            if thisSubscript == null
                thisSubscript = ThisSubscript(start, lexer.getPosition())

            thisSubscript.subscript = node
        }

        return thisSubscript
    }

    function parseThisWord() -> ThisWord throws ParserError {
        mutable thisWord: ThisWord? = null
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parseKeyword(thisKeyword)
            if success
                lexer.advance()

            if thisWord == null
                thisWord = ThisWord(start, lexer.getPosition())
        }

        return thisWord
    }

    function parseSuperExpression() -> SuperExpression throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: SuperDot = parseSuperDot() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: SuperSubscript = parseSuperSubscript() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(start, errors)
    }

    function parseSuperDot() -> SuperDot throws ParserError {
        mutable superDot: SuperDot? = null
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parseKeyword(superKeyword)
            if success
                lexer.advance()

            if superDot == null
                superDot = SuperDot(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parsePunctuation(dot)
            if success
                lexer.advance()

            if superDot == null
                superDot = SuperDot(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPosition()
            let result: CommonSuperMember node = parseCommonSuperMember() catch _(error) {
                throw (error)
            }

            if superDot == null
                superDot = SuperDot(start, lexer.getPosition())

            superDot.member = node
        }

        return superDot
    }

    function parseSuperSubscript() -> SuperSubscript throws ParserError {
        mutable superSubscript: SuperSubscript? = null
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parseKeyword(superKeyword)
            if success
                lexer.advance()

            if superSubscript == null
                superSubscript = SuperSubscript(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPosition()
            let result: Subscript node = parseSubscript() catch _(error) {
                throw (error)
            }

            if superSubscript == null
                superSubscript = SuperSubscript(start, lexer.getPosition())

            superSubscript.subscript = node
        }

        return superSubscript
    }

    function parseElseClause() -> ElseClause throws ParserError {
        mutable elseClause: ElseClause? = null
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parseKeyword(elseKeyword)
            if success
                lexer.advance()

            if elseClause == null
                elseClause = ElseClause(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPosition()
            let result: Expression node = parseExpression() catch _(error) {
                throw (error)
            }

            if elseClause == null
                elseClause = ElseClause(start, lexer.getPosition())

            elseClause.alternative = node
        }

        return elseClause
    }

    function parseSwitchBody() -> SwitchBody throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: CurliedSwitchBody = parseCurliedSwitchBody() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: NakedSwitchBody = parseNakedSwitchBody() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(start, errors)
    }

    function parseCurliedSwitchBody() -> CurliedSwitchBody throws ParserError {
        mutable curliedSwitchBody: CurliedSwitchBody? = null
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parsePunctuation(leftCurly)
            if success
                lexer.advance()

            if curliedSwitchBody == null
                curliedSwitchBody = CurliedSwitchBody(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPosition()
            let result: [SwitchCase] node = parseSwitchCaseList() catch _(error) {
                throw (error)
            }

            if curliedSwitchBody == null
                curliedSwitchBody = CurliedSwitchBody(start, lexer.getPosition())

            curliedSwitchBody.cases = node
        }
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parsePunctuation(rightCurly)
            if success
                lexer.advance()

            if curliedSwitchBody == null
                curliedSwitchBody = CurliedSwitchBody(start, lexer.getPosition())
        }

        return curliedSwitchBody
    }

    function parseNakedSwitchBody() -> NakedSwitchBody throws ParserError {
        mutable nakedSwitchBody: NakedSwitchBody? = null
        {
            let start: Position = lexer.getPosition()
            let result: [SwitchCase] node = parseSwitchCaseList() catch _(error) {
                throw (error)
            }

            if nakedSwitchBody == null
                nakedSwitchBody = NakedSwitchBody(start, lexer.getPosition())

            nakedSwitchBody.cases = node
        }

        return nakedSwitchBody
    }

    function parseSwitchCaseList() -> [SwitchCase] throws ParserError {
        mutable (string-firstchar-downcase switchCase): [SwitchCase]? = [SwitchCase]()
        while true
            switchCase.push(parseSwitchCase() catch _ break)
        return switchCase
    }

    function parseSwitchCase() -> SwitchCase throws ParserError {
        mutable switchCase: SwitchCase? = null
        {
            let start: Position = lexer.getPosition()
            let result: CaseLabel node = parseCaseLabel() catch _(error) {
                throw (error)
            }

            if switchCase == null
                switchCase = SwitchCase(start, lexer.getPosition())

            switchCase.label = node
        }
        {
            let start: Position = lexer.getPosition()
            let result: CaseContent node = parseCaseContent() catch _(error) {
                throw (error)
            }

            if switchCase == null
                switchCase = SwitchCase(start, lexer.getPosition())

            switchCase.content = node
        }

        return switchCase
    }

    function parseCaseLabel() -> CaseLabel throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: ItemCaseLabel = parseItemCaseLabel() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: DefaultCaseLabel = parseDefaultCaseLabel() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(start, errors)
    }

    function parseItemCaseLabel() -> ItemCaseLabel throws ParserError {
        mutable itemCaseLabel: ItemCaseLabel? = null
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parseKeyword(caseKeyword)
            if success
                lexer.advance()

            if itemCaseLabel == null
                itemCaseLabel = ItemCaseLabel(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPosition()
            let result: Pattern node = parsePattern() catch _(error) {
                throw (error)
            }

            if itemCaseLabel == null
                itemCaseLabel = ItemCaseLabel(start, lexer.getPosition())

            itemCaseLabel.pattern = node
        }
        {
            let start: Position = lexer.getPosition()
            let result: [CaseItem] node = parseCaseItemList() catch _(error) {
                 null
            }

            if itemCaseLabel == null
                itemCaseLabel = ItemCaseLabel(start, lexer.getPosition())

            itemCaseLabel.additionalPatterns = node
        }
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parsePunctuation(colon)
            if success
                lexer.advance()

            if itemCaseLabel == null
                itemCaseLabel = ItemCaseLabel(start, lexer.getPosition())
        }

        return itemCaseLabel
    }

    function parseDefaultCaseLabel() -> DefaultCaseLabel throws ParserError {
        mutable defaultCaseLabel: DefaultCaseLabel? = null
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parseKeyword(defaultKeyword)
            if success
                lexer.advance()

            if defaultCaseLabel == null
                defaultCaseLabel = DefaultCaseLabel(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parsePunctuation(colon)
            if success
                lexer.advance()

            if defaultCaseLabel == null
                defaultCaseLabel = DefaultCaseLabel(start, lexer.getPosition())
        }

        return defaultCaseLabel
    }

    function parseCaseItemList() -> [CaseItem] throws ParserError {
        mutable (string-firstchar-downcase caseItem): [CaseItem]? = [CaseItem]()
        while true
            caseItem.push(parseCaseItem() catch _ break)
        return caseItem
    }

    function parseCaseItem() -> CaseItem throws ParserError {
        mutable caseItem: CaseItem? = null
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parsePunctuation(comma)
            if success
                lexer.advance()

            if caseItem == null
                caseItem = CaseItem(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPosition()
            let result: Pattern node = parsePattern() catch _(error) {
                throw (error)
            }

            if caseItem == null
                caseItem = CaseItem(start, lexer.getPosition())

            caseItem.pattern = node
        }

        return caseItem
    }

    function parseForLoop() -> ForLoop throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: ForEach = parseForEach() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: PlainFor = parsePlainFor() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(start, errors)
    }

    function parseForEach() -> ForEach throws ParserError {
        mutable forEach: ForEach? = null
        {
            let start: Position = lexer.getPosition()
            let result: Pattern node = parsePattern() catch _(error) {
                throw (error)
            }

            if forEach == null
                forEach = ForEach(start, lexer.getPosition())

            forEach.pattern = node
        }
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parseKeyword(inKeyword)
            if success
                lexer.advance()

            if forEach == null
                forEach = ForEach(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPosition()
            let result: Expression node = parseExpression() catch _(error) {
                throw (error)
            }

            if forEach == null
                forEach = ForEach(start, lexer.getPosition())

            forEach.expression = node
        }
        {
            let start: Position = lexer.getPosition()
            let result: Expression node = parseExpression() catch _(error) {
                throw (error)
            }

            if forEach == null
                forEach = ForEach(start, lexer.getPosition())

            forEach.code = node
        }

        return forEach
    }

    function parsePlainFor() -> PlainFor throws ParserError {
        mutable plainFor: PlainFor? = null
        {
            let start: Position = lexer.getPosition()
            let result: VariableDeclaration node = parseVariableDeclaration() catch _(error) {
                 null
            }

            if plainFor == null
                plainFor = PlainFor(start, lexer.getPosition())

            plainFor.forInit = node
        }
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parsePunctuation(semicolon)
            if success
                lexer.advance()

            if plainFor == null
                plainFor = PlainFor(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPosition()
            let result: Expression node = parseExpression() catch _(error) {
                 null
            }

            if plainFor == null
                plainFor = PlainFor(start, lexer.getPosition())

            plainFor.forCheck = node
        }
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parsePunctuation(semicolon)
            if success
                lexer.advance()

            if plainFor == null
                plainFor = PlainFor(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPosition()
            let result: Expression node = parseExpression() catch _(error) {
                throw (error)
            }

            if plainFor == null
                plainFor = PlainFor(start, lexer.getPosition())

            plainFor.forNext = node
        }
        {
            let start: Position = lexer.getPosition()
            let result: Expression node = parseExpression() catch _(error) {
                throw (error)
            }

            if plainFor == null
                plainFor = PlainFor(start, lexer.getPosition())

            plainFor.code = node
        }

        return plainFor
    }

    function parsePattern() -> Pattern throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: WildcardPattern = parseWildcardPattern() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: IdentifierPattern = parseIdentifierPattern() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: TuplePattern = parseTuplePattern() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: ExpressionPattern = parseExpressionPattern() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(start, errors)
    }

    function parseWildcardPattern() -> WildcardPattern throws ParserError {
        mutable wildcardPattern: WildcardPattern? = null
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parsePunctuation(underscore)
            if success
                lexer.advance()

            if wildcardPattern == null
                wildcardPattern = WildcardPattern(start, lexer.getPosition())
        }

        return wildcardPattern
    }

    function parseIdentifierPattern() -> IdentifierPattern throws ParserError {
        mutable identifierPattern: IdentifierPattern? = null
        {
            let start: Position = lexer.getPosition()
            let identifier: String? = lexer.parseIdentifier()
            if (identifier != null) && (identifier is Identifier)
                lexer.advance()

            if identifierPattern == null
                identifierPattern = IdentifierPattern(start, lexer.getPosition())

            identifierPattern.identifier = identifier
        }
        {
            let start: Position = lexer.getPosition()
            let result: TypeAnnotation node = parseTypeAnnotation() catch _(error) {
                 null
            }

            if identifierPattern == null
                identifierPattern = IdentifierPattern(start, lexer.getPosition())

            identifierPattern.annotationForType = node
        }

        return identifierPattern
    }

    function parseTuplePattern() -> TuplePattern throws ParserError {
        mutable tuplePattern: TuplePattern? = null
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parsePunctuation(leftParen)
            if success
                lexer.advance()

            if tuplePattern == null
                tuplePattern = TuplePattern(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPosition()
            let result: [TuplePatternElement] node = parseTuplePatternElementList() catch _(error) {
                throw (error)
            }

            if tuplePattern == null
                tuplePattern = TuplePattern(start, lexer.getPosition())

            tuplePattern.elements = node
        }
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parsePunctuation(rightParen)
            if success
                lexer.advance()

            if tuplePattern == null
                tuplePattern = TuplePattern(start, lexer.getPosition())
        }

        return tuplePattern
    }

    function parseExpressionPattern() -> ExpressionPattern throws ParserError {
        mutable expressionPattern: ExpressionPattern? = null
        {
            let start: Position = lexer.getPosition()
            let result: Expression node = parseExpression() catch _(error) {
                throw (error)
            }

            if expressionPattern == null
                expressionPattern = ExpressionPattern(start, lexer.getPosition())

            expressionPattern.expression = node
        }

        return expressionPattern
    }

    function parseTuplePatternElementList() -> [TuplePatternElement] throws ParserError {
        mutable (string-firstchar-downcase tuplePatternElement): [TuplePatternElement]? = [TuplePatternElement]()
        while true
            tuplePatternElement.push(parseTuplePatternElement() catch _ break)
        return tuplePatternElement
    }

    function parseTuplePatternElement() -> TuplePatternElement throws ParserError {
        mutable tuplePatternElement: TuplePatternElement? = null
        {
            let start: Position = lexer.getPosition()
            let result: Pattern node = parsePattern() catch _(error) {
                throw (error)
            }

            if tuplePatternElement == null
                tuplePatternElement = TuplePatternElement(start, lexer.getPosition())

            tuplePatternElement.pattern = node
        }
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parsePunctuation(comma)
            if success
                lexer.advance()

            if tuplePatternElement == null
                tuplePatternElement = TuplePatternElement(start, lexer.getPosition())
        }

        return tuplePatternElement
    }

    function parseCaseContent() -> CaseContent throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: BlockCaseContent = parseBlockCaseContent() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: EmptyCaseContent = parseEmptyCaseContent() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(start, errors)
    }

    function parseBlockCaseContent() -> BlockCaseContent throws ParserError {
        mutable blockCaseContent: BlockCaseContent? = null
        {
            let start: Position = lexer.getPosition()
            let result: [StatementWithSemicolon] node = parseStatementWithSemicolonList() catch _(error) {
                throw (error)
            }

            if blockCaseContent == null
                blockCaseContent = BlockCaseContent(start, lexer.getPosition())

            blockCaseContent.statements = node
        }

        return blockCaseContent
    }

    function parseEmptyCaseContent() -> EmptyCaseContent throws ParserError {
        mutable emptyCaseContent: EmptyCaseContent? = null
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parsePunctuation(semicolon)
            if success
                lexer.advance()

            if emptyCaseContent == null
                emptyCaseContent = EmptyCaseContent(start, lexer.getPosition())
        }

        return emptyCaseContent
    }

    function parseCommonThisMember() -> CommonThisMember throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: ThisInit = parseThisInit() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: ThisMember = parseThisMember() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(start, errors)
    }

    function parseThisInit() -> ThisInit throws ParserError {
        mutable thisInit: ThisInit? = null
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parseKeyword(initKeyword)
            if success
                lexer.advance()

            if thisInit == null
                thisInit = ThisInit(start, lexer.getPosition())
        }

        return thisInit
    }

    function parseThisMember() -> ThisMember throws ParserError {
        mutable thisMember: ThisMember? = null
        {
            let start: Position = lexer.getPosition()
            let name: String? = lexer.parseIdentifier()
            if (name != null) && (name is Identifier)
                lexer.advance()

            if thisMember == null
                thisMember = ThisMember(start, lexer.getPosition())

            thisMember.name = name
        }

        return thisMember
    }

    function parseCommonSuperMember() -> CommonSuperMember throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: SuperInit = parseSuperInit() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: SuperMember = parseSuperMember() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(start, errors)
    }

    function parseSuperInit() -> SuperInit throws ParserError {
        mutable superInit: SuperInit? = null
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parseKeyword(initKeyword)
            if success
                lexer.advance()

            if superInit == null
                superInit = SuperInit(start, lexer.getPosition())
        }

        return superInit
    }

    function parseSuperMember() -> SuperMember throws ParserError {
        mutable superMember: SuperMember? = null
        {
            let start: Position = lexer.getPosition()
            let name: String? = lexer.parseIdentifier()
            if (name != null) && (name is Identifier)
                lexer.advance()

            if superMember == null
                superMember = SuperMember(start, lexer.getPosition())

            superMember.name = name
        }

        return superMember
    }

    function parseType() -> Type throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: ArrayType = parseArrayType() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: TypeIdentifier = parseTypeIdentifier() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(start, errors)
    }

    function parseTypeIdentifier() -> TypeIdentifier throws ParserError {
        mutable typeIdentifier: TypeIdentifier? = null
        {
            let start: Position = lexer.getPosition()
            let name: String? = lexer.parseIdentifier()
            if (name != null) && (name is Identifier)
                lexer.advance()

            if typeIdentifier == null
                typeIdentifier = TypeIdentifier(start, lexer.getPosition())

            typeIdentifier.name = name
        }
        {
            let start: Position = lexer.getPosition()
            let result: SubtypeIdentifier node = parseSubtypeIdentifier() catch _(error) {
                 null
            }

            if typeIdentifier == null
                typeIdentifier = TypeIdentifier(start, lexer.getPosition())

            typeIdentifier.subType = node
        }
        {
            let start: Position = lexer.getPosition()
            let result: [TypePostfix] node = parseTypePostfixList() catch _(error) {
                 null
            }

            if typeIdentifier == null
                typeIdentifier = TypeIdentifier(start, lexer.getPosition())

            typeIdentifier.postfixes = node
        }

        return typeIdentifier
    }

    function parseArrayType() -> ArrayType throws ParserError {
        mutable arrayType: ArrayType? = null
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parsePunctuation(leftBracket)
            if success
                lexer.advance()

            if arrayType == null
                arrayType = ArrayType(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPosition()
            let result: Type node = parseType() catch _(error) {
                throw (error)
            }

            if arrayType == null
                arrayType = ArrayType(start, lexer.getPosition())

            arrayType.elementType = node
        }
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parsePunctuation(rightBracket)
            if success
                lexer.advance()

            if arrayType == null
                arrayType = ArrayType(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPosition()
            let result: [TypePostfix] node = parseTypePostfixList() catch _(error) {
                 null
            }

            if arrayType == null
                arrayType = ArrayType(start, lexer.getPosition())

            arrayType.postfixes = node
        }

        return arrayType
    }

    function parseTypeAnnotation() -> TypeAnnotation throws ParserError {
        mutable typeAnnotation: TypeAnnotation? = null
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parsePunctuation(colon)
            if success
                lexer.advance()

            if typeAnnotation == null
                typeAnnotation = TypeAnnotation(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPosition()
            let result: Type node = parseType() catch _(error) {
                throw (error)
            }

            if typeAnnotation == null
                typeAnnotation = TypeAnnotation(start, lexer.getPosition())

            typeAnnotation.annotationForType = node
        }

        return typeAnnotation
    }

    function parseSubtypeIdentifier() -> SubtypeIdentifier throws ParserError {
        mutable subtypeIdentifier: SubtypeIdentifier? = null
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parsePunctuation(dot)
            if success
                lexer.advance()

            if subtypeIdentifier == null
                subtypeIdentifier = SubtypeIdentifier(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPosition()
            let result: TypeIdentifier node = parseTypeIdentifier() catch _(error) {
                throw (error)
            }

            if subtypeIdentifier == null
                subtypeIdentifier = SubtypeIdentifier(start, lexer.getPosition())

            subtypeIdentifier.typeIdentifier = node
        }

        return subtypeIdentifier
    }

    function parseTypePostfixList() -> [TypePostfix] throws ParserError {
        mutable (string-firstchar-downcase typePostfix): [TypePostfix]? = [TypePostfix]()
        while true
            typePostfix.push(parseTypePostfix() catch _ break)
        return typePostfix
    }

    function parseTypePostfix() -> TypePostfix throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: OptionalType = parseOptionalType() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(start, errors)
    }

    function parseOptionalType() -> OptionalType throws ParserError {
        mutable optionalType: OptionalType? = null
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parsePunctuation(questionMark)
            if success
                lexer.advance()

            if optionalType == null
                optionalType = OptionalType(start, lexer.getPosition())
        }

        return optionalType
    }

    function parseTypeInheritanceClause() -> TypeInheritanceClause throws ParserError {
        mutable typeInheritanceClause: TypeInheritanceClause? = null
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parsePunctuation(colon)
            if success
                lexer.advance()

            if typeInheritanceClause == null
                typeInheritanceClause = TypeInheritanceClause(start, lexer.getPosition())
        }
        {
            let start: Position = lexer.getPosition()
            let result: [Inheritance] node = parseInheritanceList() catch _(error) {
                 null
            }

            if typeInheritanceClause == null
                typeInheritanceClause = TypeInheritanceClause(start, lexer.getPosition())

            typeInheritanceClause.inheritances = node
        }

        return typeInheritanceClause
    }

    function parseInheritanceList() -> [Inheritance] throws ParserError {
        mutable (string-firstchar-downcase inheritance): [Inheritance]? = [Inheritance]()
        while true
            inheritance.push(parseInheritance() catch _ break)
        return inheritance
    }

    function parseInheritance() -> Inheritance throws ParserError {
        mutable inheritance: Inheritance? = null
        {
            let start: Position = lexer.getPosition()
            let result: TypeIdentifier node = parseTypeIdentifier() catch _(error) {
                throw (error)
            }

            if inheritance == null
                inheritance = Inheritance(start, lexer.getPosition())

            inheritance.typeIdentifier = node
        }
        {
            let start: Position = lexer.getPosition()
            let success: bool = lexer.parsePunctuation(comma)
            if success
                lexer.advance()

            if inheritance == null
                inheritance = Inheritance(start, lexer.getPosition())
        }

        return inheritance
    }

    function isAtEnd() -> bool {
        lexer.isAtEnd()
    }

    function isIdentifier(id: String) -> bool {
        if id == useKeyword
            return false

        if id == classKeyword
            return false

        if id == functionKeyword
            return false

        if id == ifKeyword
            return false

        if id == elseKeyword
            return false

        if id == switchKeyword
            return false

        if id == caseKeyword
            return false

        if id == defaultKeyword
            return false

        if id == catchKeyword
            return false

        if id == forKeyword
            return false

        if id == inKeyword
            return false

        if id == returnKeyword
            return false

        if id == throwKeyword
            return false

        if id == breakKeyword
            return false

        if id == throwsKeyword
            return false

        if id == overrideKeyword
            return false

        if id == staticKeyword
            return false

        if id == letKeyword
            return false

        if id == mutableKeyword
            return false

        if id == isKeyword
            return false

        if id == asKeyword
            return false

        if id == initKeyword
            return false

        if id == enumKeyword
            return false

        if id == superKeyword
            return false

        if id == thisKeyword
            return false

        true
    }

    mutable lexer: Lexer

    let useKeyword: string = "use"
    let classKeyword: string = "class"
    let functionKeyword: string = "function"
    let ifKeyword: string = "if"
    let elseKeyword: string = "else"
    let switchKeyword: string = "switch"
    let caseKeyword: string = "case"
    let defaultKeyword: string = "default"
    let catchKeyword: string = "catch"
    let forKeyword: string = "for"
    let inKeyword: string = "in"
    let returnKeyword: string = "return"
    let throwKeyword: string = "throw"
    let breakKeyword: string = "break"
    let throwsKeyword: string = "throws"
    let overrideKeyword: string = "override"
    let staticKeyword: string = "static"
    let letKeyword: string = "let"
    let mutableKeyword: string = "mutable"
    let isKeyword: string = "is"
    let asKeyword: string = "as"
    let initKeyword: string = "init"
    let enumKeyword: string = "enum"
    let superKeyword: string = "super"
    let thisKeyword: string = "this"
    let semicolon: string = ";"
    let equal: string = "="
    let leftAngular: string = "<"
    let rightAngular: string = ">"
    let comma: string = ","
    let leftParen: string = "("
    let rightParen: string = ")"
    let leftCurly: string = "{"
    let rightCurly: string = "}"
    let leftBracket: string = "["
    let rightBracket: string = "]"
    let colon: string = ":"
    let dot: string = "."
    let questionMark: string = "?"
    let underscore: string = "_"
    let evaluatesTo: string = "->"
}
