class Parser {
    init(theFileName: String, text: String) {
        lexer = Lexer(text)
        fileName = theFileName
        useKeyword = String("use")
        classKeyword = String("class")
        functionKeyword = String("function")
        ifKeyword = String("if")
        elseKeyword = String("else")
        switchKeyword = String("switch")
        caseKeyword = String("case")
        defaultKeyword = String("default")
        catchKeyword = String("catch")
        forKeyword = String("for")
        inKeyword = String("in")
        whileKeyword = String("while")
        repeatKeyword = String("repeat")
        returnKeyword = String("return")
        throwKeyword = String("throw")
        breakKeyword = String("break")
        throwsKeyword = String("throws")
        existingKeyword = String("existing")
        overrideKeyword = String("override")
        staticKeyword = String("static")
        letKeyword = String("let")
        varKeyword = String("var")
        mutableKeyword = String("mutable")
        isKeyword = String("is")
        asKeyword = String("as")
        initKeyword = String("init")
        enumKeyword = String("enum")
        superKeyword = String("super")
        thisKeyword = String("this")
        nullKeyword = String("null")
        semicolon = String(";")
        equal = String("=")
        leftAngular = String("<")
        rightAngular = String(">")
        comma = String(",")
        leftParen = String("(")
        rightParen = String(")")
        leftCurly = String("{")
        rightCurly = String("}")
        leftBracket = String("[")
        rightBracket = String("]")
        colon = String(":")
        dot = String(".")
        questionMark = String("?")
        underscore = String("_")
        evaluatesTo = String("->")
    }

    function parseCompilationUnit() -> CompilationUnit throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let statements: [TerminatedStatement] = parseTerminatedStatementList() catch _(error) null
        if statements != null {
            if !isAtEnd() {
                mutable current: Position = lexer.getPosition()
                throw notAtEnd(Position(current))
            }
        }
        mutable ret: CompilationUnit = CompilationUnit(statements, Position(start), lexer.getPosition())
        ret.fileName = fileName;
        if statements != null {
            for item in statements
                item.parent = ret
        }

        ret.fileName = fileName;
        return ret
    }

    function parseTerminatedStatementList() -> [TerminatedStatement] throws ParserError {
        mutable ret: [TerminatedStatement]? = [TerminatedStatement]()
        while true
            ret.push(parseTerminatedStatement() catch _ break)
        return ret
    }

    function parseTerminatedStatement() -> TerminatedStatement throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let statement: Statement = parseStatement() catch _(error)
            throw (error)
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(semicolon)
        if success
            lexer.advance()
        mutable ret: TerminatedStatement = TerminatedStatement(statement, Position(start), lexer.getPosition())
       statement.parent = ret

        return ret
    }

    function parseStatement() -> Statement throws ParserError {
        let errors: [ParserError] = [ParserError]()
        mutable start: Position = lexer.getPreviousPosition()

        {
            let node: Declaration = parseDeclaration() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: Expression = parseExpression() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(Position(start), errors)
    }

    function parseDeclaration() -> Declaration throws ParserError {
        let errors: [ParserError] = [ParserError]()
        mutable start: Position = lexer.getPreviousPosition()

        {
            let node: UseDeclaration = parseUseDeclaration() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: ConstantDeclaration = parseConstantDeclaration() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: VariableDeclaration = parseVariableDeclaration() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: MutableDeclaration = parseMutableDeclaration() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: FunctionDeclaration = parseFunctionDeclaration() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: EnumDeclaration = parseEnumDeclaration() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: ClassDeclaration = parseClassDeclaration() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: InitializerDeclaration = parseInitializerDeclaration() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(Position(start), errors)
    }

    function parseExpression() -> Expression throws ParserError {
        let errors: [ParserError] = [ParserError]()
        mutable start: Position = lexer.getPreviousPosition()

        {
            let node: CodeBlock = parseCodeBlock() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: SimpleExpression = parseSimpleExpression() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(Position(start), errors)
    }

    function parseUseDeclaration() -> UseDeclaration throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(useKeyword)
        if success
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let importModule: PathItem = parsePathItem() catch _(error)
            throw (error)
        mutable start: Position = lexer.getPreviousPosition()
        let importExtensions: [PathIdentifier] = parsePathIdentifierList() catch _(error) null
        mutable ret: UseDeclaration = UseDeclaration(importModule, importExtensions, Position(start), lexer.getPosition())
       importModule.parent = ret
        if importExtensions != null {
            for item in importExtensions
                item.parent = ret
        }

        return ret
    }

    function parseConstantDeclaration() -> ConstantDeclaration throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(letKeyword)
        if success
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let initializer: BindingInitializer = parseBindingInitializer() catch _(error)
            throw (error)
        mutable ret: ConstantDeclaration = ConstantDeclaration(initializer, Position(start), lexer.getPosition())
       initializer.parent = ret

        return ret
    }

    function parseVariableDeclaration() -> VariableDeclaration throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(varKeyword)
        if success
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let initializer: BindingInitializer = parseBindingInitializer() catch _(error)
            throw (error)
        mutable ret: VariableDeclaration = VariableDeclaration(initializer, Position(start), lexer.getPosition())
       initializer.parent = ret

        return ret
    }

    function parseMutableDeclaration() -> MutableDeclaration throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(mutableKeyword)
        if success
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let initializer: BindingInitializer = parseBindingInitializer() catch _(error)
            throw (error)
        mutable ret: MutableDeclaration = MutableDeclaration(initializer, Position(start), lexer.getPosition())
       initializer.parent = ret

        return ret
    }

    function parseFunctionDeclaration() -> FunctionDeclaration throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let modifiers: [Modifier] = parseModifierList() catch _(error) null
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(functionKeyword)
        if success
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let name: FunctionName = parseFunctionName() catch _(error)
            throw (error)
        mutable start: Position = lexer.getPreviousPosition()
        let signature: FunctionSignature = parseFunctionSignature() catch _(error)
            throw (error)
        mutable start: Position = lexer.getPreviousPosition()
        let body: Expression = parseExpression() catch _(error) null
        mutable ret: FunctionDeclaration = FunctionDeclaration(modifiers, name, signature, body, Position(start), lexer.getPosition())
        if modifiers != null {
            for item in modifiers
                item.parent = ret
        }
       name.parent = ret
       signature.parent = ret
       if body != null
           body.parent = ret

        return ret
    }

    function parseEnumDeclaration() -> EnumDeclaration throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(enumKeyword)
        if success
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let name: String? = lexer.parseIdentifier()
        if (name != null) && (name is Identifier)
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(leftCurly)
        if success
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let members: [EnumMember] = parseEnumMemberList() catch _(error)
            throw (error)
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(rightCurly)
        if success
            lexer.advance()
        mutable ret: EnumDeclaration = EnumDeclaration(name, members, Position(start), lexer.getPosition())
        if members != null {
            for item in members
                item.parent = ret
        }

        return ret
    }

    function parseClassDeclaration() -> ClassDeclaration throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(classKeyword)
        if success
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let name: String? = lexer.parseIdentifier()
        if (name != null) && (name is Identifier)
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let genericArgumentClause: GenericArgumentClause = parseGenericArgumentClause() catch _(error) null
        mutable start: Position = lexer.getPreviousPosition()
        let typeInheritanceClause: TypeInheritanceClause = parseTypeInheritanceClause() catch _(error) null
        mutable start: Position = lexer.getPreviousPosition()
        let body: ClassBody = parseClassBody() catch _(error) null
        mutable ret: ClassDeclaration = ClassDeclaration(name, genericArgumentClause, typeInheritanceClause, body, Position(start), lexer.getPosition())
       if genericArgumentClause != null
           genericArgumentClause.parent = ret
       if typeInheritanceClause != null
           typeInheritanceClause.parent = ret
       if body != null
           body.parent = ret

        return ret
    }

    function parseInitializerDeclaration() -> InitializerDeclaration throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let modifiers: [Modifier] = parseModifierList() catch _(error) null
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(initKeyword)
        if success
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let parameterClause: ParameterClause = parseParameterClause() catch _(error)
            throw (error)
        mutable start: Position = lexer.getPreviousPosition()
        let throwsClause: ThrowsClause = parseThrowsClause() catch _(error) null
        mutable start: Position = lexer.getPreviousPosition()
        let body: Expression = parseExpression() catch _(error)
            throw (error)
        mutable ret: InitializerDeclaration = InitializerDeclaration(modifiers, parameterClause, throwsClause, body, Position(start), lexer.getPosition())
        if modifiers != null {
            for item in modifiers
                item.parent = ret
        }
       parameterClause.parent = ret
       if throwsClause != null
           throwsClause.parent = ret
       body.parent = ret

        return ret
    }

    function parseCodeBlock() -> CodeBlock throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(leftCurly)
        if success
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let statements: [TerminatedStatement] = parseTerminatedStatementList() catch _(error)
            throw (error)
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(rightCurly)
        if success
            lexer.advance()
        mutable ret: CodeBlock = CodeBlock(statements, Position(start), lexer.getPosition())
        if statements != null {
            for item in statements
                item.parent = ret
        }

        return ret
    }

    function parseSimpleExpression() -> SimpleExpression throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let prefixExpression: PrefixExpression = parsePrefixExpression() catch _(error)
            throw (error)
        mutable start: Position = lexer.getPreviousPosition()
        let binaryOps: [BinaryOp] = parseBinaryOpList() catch _(error) null
        mutable ret: SimpleExpression = SimpleExpression(prefixExpression, binaryOps, Position(start), lexer.getPosition())
       prefixExpression.parent = ret
        if binaryOps != null {
            for item in binaryOps
                item.parent = ret
        }

        return ret
    }

    function parsePathIdentifierList() -> [PathIdentifier] throws ParserError {
        mutable ret: [PathIdentifier]? = [PathIdentifier]()
        while true
            ret.push(parsePathIdentifier() catch _ break)
        return ret
    }

    function parsePathIdentifier() -> PathIdentifier throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(dot)
        if success
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let extension: PathItem = parsePathItem() catch _(error)
            throw (error)
        mutable ret: PathIdentifier = PathIdentifier(extension, Position(start), lexer.getPosition())
       extension.parent = ret

        return ret
    }

    function parsePathItem() -> PathItem throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let name: String? = lexer.parseIdentifier()
        if (name != null) && (name is Identifier)
            lexer.advance()
        mutable ret: PathItem = PathItem(name, Position(start), lexer.getPosition())

        return ret
    }

    function parseInitializer() -> Initializer throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(equal)
        if success
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let expression: Expression = parseExpression() catch _(error)
            throw (error)
        mutable ret: Initializer = Initializer(expression, Position(start), lexer.getPosition())
       expression.parent = ret

        return ret
    }

    function parseBindingInitializer() -> BindingInitializer throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let initializer: PatternInitializer = parsePatternInitializer() catch _(error)
            throw (error)
        mutable start: Position = lexer.getPreviousPosition()
        let additionalInitializers: [AdditionalInitializer] = parseAdditionalInitializerList() catch _(error) null
        mutable ret: BindingInitializer = BindingInitializer(initializer, additionalInitializers, Position(start), lexer.getPosition())
       initializer.parent = ret
        if additionalInitializers != null {
            for item in additionalInitializers
                item.parent = ret
        }

        return ret
    }

    function parsePatternInitializerList() -> [PatternInitializer] throws ParserError {
        mutable ret: [PatternInitializer]? = [PatternInitializer]()
        while true
            ret.push(parsePatternInitializer() catch _ break)
        return ret
    }

    function parsePatternInitializer() -> PatternInitializer throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let pattern: Pattern = parsePattern() catch _(error)
            throw (error)
        mutable start: Position = lexer.getPreviousPosition()
        let initializer: Initializer = parseInitializer() catch _(error) null
        mutable ret: PatternInitializer = PatternInitializer(pattern, initializer, Position(start), lexer.getPosition())
       pattern.parent = ret
       if initializer != null
           initializer.parent = ret

        return ret
    }

    function parseAdditionalInitializerList() -> [AdditionalInitializer] throws ParserError {
        mutable ret: [AdditionalInitializer]? = [AdditionalInitializer]()
        while true
            ret.push(parseAdditionalInitializer() catch _ break)
        return ret
    }

    function parseAdditionalInitializer() -> AdditionalInitializer throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(comma)
        if success
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let pattern: PatternInitializer = parsePatternInitializer() catch _(error)
            throw (error)
        mutable ret: AdditionalInitializer = AdditionalInitializer(pattern, Position(start), lexer.getPosition())
       pattern.parent = ret

        return ret
    }

    function parseModifierList() -> [Modifier] throws ParserError {
        mutable ret: [Modifier]? = [Modifier]()
        while true
            ret.push(parseModifier() catch _ break)
        return ret
    }

    function parseModifier() -> Modifier throws ParserError {
        let errors: [ParserError] = [ParserError]()
        mutable start: Position = lexer.getPreviousPosition()

        {
            let node: OverrideWord = parseOverrideWord() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: StaticWord = parseStaticWord() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(Position(start), errors)
    }

    function parseOverrideWord() -> OverrideWord throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(overrideKeyword)
        if success
            lexer.advance()
        mutable ret: OverrideWord = OverrideWord(Position(start), lexer.getPosition())

        return ret
    }

    function parseStaticWord() -> StaticWord throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(staticKeyword)
        if success
            lexer.advance()
        mutable ret: StaticWord = StaticWord(Position(start), lexer.getPosition())

        return ret
    }

    function parseFunctionName() -> FunctionName throws ParserError {
        let errors: [ParserError] = [ParserError]()
        mutable start: Position = lexer.getPreviousPosition()

        {
            let node: IdentifierFunction = parseIdentifierFunction() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(Position(start), errors)
    }

    function parseIdentifierFunction() -> IdentifierFunction throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let name: String? = lexer.parseIdentifier()
        if (name != null) && (name is Identifier)
            lexer.advance()
        mutable ret: IdentifierFunction = IdentifierFunction(name, Position(start), lexer.getPosition())

        return ret
    }

    function parseFunctionSignature() -> FunctionSignature throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let parameterClause: ParameterClause = parseParameterClause() catch _(error)
            throw (error)
        mutable start: Position = lexer.getPreviousPosition()
        let result: FunctionResult = parseFunctionResult() catch _(error) null
        mutable start: Position = lexer.getPreviousPosition()
        let throwsClause: ThrowsClause = parseThrowsClause() catch _(error) null
        mutable ret: FunctionSignature = FunctionSignature(parameterClause, result, throwsClause, Position(start), lexer.getPosition())
       parameterClause.parent = ret
       if result != null
           result.parent = ret
       if throwsClause != null
           throwsClause.parent = ret

        return ret
    }

    function parseFunctionResult() -> FunctionResult throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(evaluatesTo)
        if success
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let existingObject: ExistingClause = parseExistingClause() catch _(error) null
        mutable start: Position = lexer.getPreviousPosition()
        let resultType: Type = parseType() catch _(error)
            throw (error)
        mutable ret: FunctionResult = FunctionResult(existingObject, resultType, Position(start), lexer.getPosition())
       if existingObject != null
           existingObject.parent = ret
       resultType.parent = ret

        return ret
    }

    function parseExistingClause() -> ExistingClause throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(existingKeyword)
        if success
            lexer.advance()
        mutable ret: ExistingClause = ExistingClause(Position(start), lexer.getPosition())

        return ret
    }

    function parseParameterClauseList() -> [ParameterClause] throws ParserError {
        mutable ret: [ParameterClause]? = [ParameterClause]()
        while true
            ret.push(parseParameterClause() catch _ break)
        return ret
    }

    function parseParameterClause() -> ParameterClause throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(leftParen)
        if success
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let parameters: [Parameter] = parseParameterList() catch _(error) null
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(rightParen)
        if success
            lexer.advance()
        mutable ret: ParameterClause = ParameterClause(parameters, Position(start), lexer.getPosition())
        if parameters != null {
            for item in parameters
                item.parent = ret
        }

        return ret
    }

    function parseParameterList() -> [Parameter] throws ParserError {
        mutable ret: [Parameter]? = [Parameter]()
        while true
            ret.push(parseParameter() catch _ break)
        return ret
    }

    function parseParameter() -> Parameter throws ParserError {
        let errors: [ParserError] = [ParserError]()
        mutable start: Position = lexer.getPreviousPosition()

        {
            let node: ConstParameter = parseConstParameter() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: VarParameter = parseVarParameter() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(Position(start), errors)
    }

    function parseConstParameter() -> ConstParameter throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(letKeyword)
        if success
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let name: String? = lexer.parseIdentifier()
        if (name != null) && (name is Identifier)
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(colon)
        if success
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let parameterType: Type = parseType() catch _(error)
            throw (error)
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(comma)
        if success
            lexer.advance()
        mutable ret: ConstParameter = ConstParameter(name, parameterType, Position(start), lexer.getPosition())
       parameterType.parent = ret

        return ret
    }

    function parseVarParameter() -> VarParameter throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(mutableKeyword)
        if success
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let name: String? = lexer.parseIdentifier()
        if (name != null) && (name is Identifier)
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(colon)
        if success
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let parameterType: Type = parseType() catch _(error)
            throw (error)
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(comma)
        if success
            lexer.advance()
        mutable ret: VarParameter = VarParameter(name, parameterType, Position(start), lexer.getPosition())
       parameterType.parent = ret

        return ret
    }

    function parseThrowsClause() -> ThrowsClause throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(throwsKeyword)
        if success
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let throwsType: Type = parseType() catch _(error)
            throw (error)
        mutable ret: ThrowsClause = ThrowsClause(throwsType, Position(start), lexer.getPosition())
       throwsType.parent = ret

        return ret
    }

    function parseEnumMemberList() -> [EnumMember] throws ParserError {
        mutable ret: [EnumMember]? = [EnumMember]()
        while true
            ret.push(parseEnumMember() catch _ break)
        return ret
    }

    function parseEnumMember() -> EnumMember throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(caseKeyword)
        if success
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let enumCase: EnumCase = parseEnumCase() catch _(error)
            throw (error)
        mutable start: Position = lexer.getPreviousPosition()
        let additionalCases: [AdditionalCase] = parseAdditionalCaseList() catch _(error) null
        mutable start: Position = lexer.getPreviousPosition()
        let parameterClause: ParameterClause = parseParameterClause() catch _(error) null
        mutable ret: EnumMember = EnumMember(enumCase, additionalCases, parameterClause, Position(start), lexer.getPosition())
       enumCase.parent = ret
        if additionalCases != null {
            for item in additionalCases
                item.parent = ret
        }
       if parameterClause != null
           parameterClause.parent = ret

        return ret
    }

    function parseEnumCase() -> EnumCase throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let name: String? = lexer.parseIdentifier()
        if (name != null) && (name is Identifier)
            lexer.advance()
        mutable ret: EnumCase = EnumCase(name, Position(start), lexer.getPosition())

        return ret
    }

    function parseAdditionalCaseList() -> [AdditionalCase] throws ParserError {
        mutable ret: [AdditionalCase]? = [AdditionalCase]()
        while true
            ret.push(parseAdditionalCase() catch _ break)
        return ret
    }

    function parseAdditionalCase() -> AdditionalCase throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(comma)
        if success
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let enumCase: EnumCase = parseEnumCase() catch _(error)
            throw (error)
        mutable ret: AdditionalCase = AdditionalCase(enumCase, Position(start), lexer.getPosition())
       enumCase.parent = ret

        return ret
    }

    function parseClassBody() -> ClassBody throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(leftCurly)
        if success
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let members: [ClassMember] = parseClassMemberList() catch _(error) null
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(rightCurly)
        if success
            lexer.advance()
        mutable ret: ClassBody = ClassBody(members, Position(start), lexer.getPosition())
        if members != null {
            for item in members
                item.parent = ret
        }

        return ret
    }

    function parseGenericArgumentClause() -> GenericArgumentClause throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(leftAngular)
        if success
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let genericParameters: [GenericParameter] = parseGenericParameterList() catch _(error)
            throw (error)
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(rightAngular)
        if success
            lexer.advance()
        mutable ret: GenericArgumentClause = GenericArgumentClause(genericParameters, Position(start), lexer.getPosition())
        if genericParameters != null {
            for item in genericParameters
                item.parent = ret
        }

        return ret
    }

    function parseGenericParameterList() -> [GenericParameter] throws ParserError {
        mutable ret: [GenericParameter]? = [GenericParameter]()
        while true
            ret.push(parseGenericParameter() catch _ break)
        return ret
    }

    function parseGenericParameter() -> GenericParameter throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let typeName: String? = lexer.parseIdentifier()
        if (typeName != null) && (typeName is Identifier)
            lexer.advance()
        mutable ret: GenericParameter = GenericParameter(typeName, Position(start), lexer.getPosition())

        return ret
    }

    function parseClassMemberList() -> [ClassMember] throws ParserError {
        mutable ret: [ClassMember]? = [ClassMember]()
        while true
            ret.push(parseClassMember() catch _ break)
        return ret
    }

    function parseClassMember() -> ClassMember throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let declaration: Declaration = parseDeclaration() catch _(error)
            throw (error)
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(semicolon)
        if success
            lexer.advance()
        mutable ret: ClassMember = ClassMember(declaration, Position(start), lexer.getPosition())
       declaration.parent = ret

        return ret
    }

    function parsePrefixExpression() -> PrefixExpression throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let prefixOperator: String? = lexer.parsePrefixOperator()
        if prefixOperator != null
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let expression: PostfixExpression = parsePostfixExpression() catch _(error)
            throw (error)
        mutable ret: PrefixExpression = PrefixExpression(prefixOperator, expression, Position(start), lexer.getPosition())
       expression.parent = ret

        return ret
    }

    function parsePostfixExpression() -> PostfixExpression throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let primaryExpression: PrimaryExpression = parsePrimaryExpression() catch _(error)
            throw (error)
        mutable start: Position = lexer.getPreviousPosition()
        let postfixes: [Postfix] = parsePostfixList() catch _(error) null
        mutable ret: PostfixExpression = PostfixExpression(primaryExpression, postfixes, Position(start), lexer.getPosition())
       primaryExpression.parent = ret
        if postfixes != null {
            for item in postfixes
                item.parent = ret
        }

        return ret
    }

    function parseBinaryOpList() -> [BinaryOp] throws ParserError {
        mutable ret: [BinaryOp]? = [BinaryOp]()
        while true
            ret.push(parseBinaryOp() catch _ break)
        return ret
    }

    function parseBinaryOp() -> BinaryOp throws ParserError {
        let errors: [ParserError] = [ParserError]()
        mutable start: Position = lexer.getPreviousPosition()

        {
            let node: BinaryOperation = parseBinaryOperation() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: Assignment = parseAssignment() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: TypeQuery = parseTypeQuery() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: TypeCast = parseTypeCast() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(Position(start), errors)
    }

    function parseBinaryOperation() -> BinaryOperation throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let binaryOperator: String? = lexer.parseBinaryOperator()
        if binaryOperator != null
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let expression: PrefixExpression = parsePrefixExpression() catch _(error)
            throw (error)
        mutable ret: BinaryOperation = BinaryOperation(binaryOperator, expression, Position(start), lexer.getPosition())
       expression.parent = ret

        return ret
    }

    function parseAssignment() -> Assignment throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(equal)
        if success
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let expression: PrefixExpression = parsePrefixExpression() catch _(error)
            throw (error)
        mutable ret: Assignment = Assignment(expression, Position(start), lexer.getPosition())
       expression.parent = ret

        return ret
    }

    function parseTypeQuery() -> TypeQuery throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(isKeyword)
        if success
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let objectType: Type = parseType() catch _(error)
            throw (error)
        mutable ret: TypeQuery = TypeQuery(objectType, Position(start), lexer.getPosition())
       objectType.parent = ret

        return ret
    }

    function parseTypeCast() -> TypeCast throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(asKeyword)
        if success
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let objectType: Type = parseType() catch _(error)
            throw (error)
        mutable ret: TypeCast = TypeCast(objectType, Position(start), lexer.getPosition())
       objectType.parent = ret

        return ret
    }

    function parseCatchClauseList() -> [CatchClause] throws ParserError {
        mutable ret: [CatchClause]? = [CatchClause]()
        while true
            ret.push(parseCatchClause() catch _ break)
        return ret
    }

    function parseCatchClause() -> CatchClause throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(catchKeyword)
        if success
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let catchPattern: CatchPattern = parseCatchPattern() catch _(error)
            throw (error)
        mutable start: Position = lexer.getPreviousPosition()
        let bindingPattern: TuplePattern = parseTuplePattern() catch _(error) null
        mutable start: Position = lexer.getPreviousPosition()
        let expression: Expression = parseExpression() catch _(error)
            throw (error)
        mutable ret: CatchClause = CatchClause(catchPattern, bindingPattern, expression, Position(start), lexer.getPosition())
       catchPattern.parent = ret
       if bindingPattern != null
           bindingPattern.parent = ret
       expression.parent = ret

        return ret
    }

    function parseCatchPattern() -> CatchPattern throws ParserError {
        let errors: [ParserError] = [ParserError]()
        mutable start: Position = lexer.getPreviousPosition()

        {
            let node: WildCardCatchPattern = parseWildCardCatchPattern() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: PathItemCatchPattern = parsePathItemCatchPattern() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(Position(start), errors)
    }

    function parseWildCardCatchPattern() -> WildCardCatchPattern throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let pattern: WildcardPattern = parseWildcardPattern() catch _(error)
            throw (error)
        mutable ret: WildCardCatchPattern = WildCardCatchPattern(pattern, Position(start), lexer.getPosition())
       pattern.parent = ret

        return ret
    }

    function parsePathItemCatchPattern() -> PathItemCatchPattern throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let catchCase: PathItem = parsePathItem() catch _(error)
            throw (error)
        mutable start: Position = lexer.getPreviousPosition()
        let catchCaseExtensions: [PathIdentifier] = parsePathIdentifierList() catch _(error) null
        mutable ret: PathItemCatchPattern = PathItemCatchPattern(catchCase, catchCaseExtensions, Position(start), lexer.getPosition())
       catchCase.parent = ret
        if catchCaseExtensions != null {
            for item in catchCaseExtensions
                item.parent = ret
        }

        return ret
    }

    function parsePostfixList() -> [Postfix] throws ParserError {
        mutable ret: [Postfix]? = [Postfix]()
        while true
            ret.push(parsePostfix() catch _ break)
        return ret
    }

    function parsePostfix() -> Postfix throws ParserError {
        let errors: [ParserError] = [ParserError]()
        mutable start: Position = lexer.getPreviousPosition()

        {
            let node: OperatorPostfix = parseOperatorPostfix() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: FunctionCall = parseFunctionCall() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: ExplicitMemberExpression = parseExplicitMemberExpression() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: Subscript = parseSubscript() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(Position(start), errors)
    }

    function parseOperatorPostfix() -> OperatorPostfix throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let postfixOperator: String? = lexer.parsePostfixOperator()
        if postfixOperator != null
            lexer.advance()
        mutable ret: OperatorPostfix = OperatorPostfix(postfixOperator, Position(start), lexer.getPosition())

        return ret
    }

    function parseFunctionCall() -> FunctionCall throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let arguments: ParenthesizedExpression = parseParenthesizedExpression() catch _(error)
            throw (error)
        mutable start: Position = lexer.getPreviousPosition()
        let catchClauses: [CatchClause] = parseCatchClauseList() catch _(error) null
        mutable ret: FunctionCall = FunctionCall(arguments, catchClauses, Position(start), lexer.getPosition())
       arguments.parent = ret
        if catchClauses != null {
            for item in catchClauses
                item.parent = ret
        }

        return ret
    }

    function parseExplicitMemberExpression() -> ExplicitMemberExpression throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(dot)
        if success
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let memberPostfix: MemberPostfix = parseMemberPostfix() catch _(error)
            throw (error)
        mutable ret: ExplicitMemberExpression = ExplicitMemberExpression(memberPostfix, Position(start), lexer.getPosition())
       memberPostfix.parent = ret

        return ret
    }

    function parseSubscript() -> Subscript throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(leftBracket)
        if success
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let expressions: [ExpressionElement] = parseExpressionElementList() catch _(error)
            throw (error)
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(rightBracket)
        if success
            lexer.advance()
        mutable ret: Subscript = Subscript(expressions, Position(start), lexer.getPosition())
        if expressions != null {
            for item in expressions
                item.parent = ret
        }

        return ret
    }

    function parseExpressionElementList() -> [ExpressionElement] throws ParserError {
        mutable ret: [ExpressionElement]? = [ExpressionElement]()
        while true
            ret.push(parseExpressionElement() catch _ break)
        return ret
    }

    function parseExpressionElement() -> ExpressionElement throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let expression: Expression = parseExpression() catch _(error)
            throw (error)
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(comma)
        if success
            lexer.advance()
        mutable ret: ExpressionElement = ExpressionElement(expression, Position(start), lexer.getPosition())
       expression.parent = ret

        return ret
    }

    function parseMemberPostfix() -> MemberPostfix throws ParserError {
        let errors: [ParserError] = [ParserError]()
        mutable start: Position = lexer.getPreviousPosition()

        {
            let node: NamedMemberPostfix = parseNamedMemberPostfix() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(Position(start), errors)
    }

    function parseNamedMemberPostfix() -> NamedMemberPostfix throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let identifier: IdentifierExpression = parseIdentifierExpression() catch _(error)
            throw (error)
        mutable ret: NamedMemberPostfix = NamedMemberPostfix(identifier, Position(start), lexer.getPosition())
       identifier.parent = ret

        return ret
    }

    function parsePrimaryExpression() -> PrimaryExpression throws ParserError {
        let errors: [ParserError] = [ParserError]()
        mutable start: Position = lexer.getPreviousPosition()

        {
            let node: IdentifierExpression = parseIdentifierExpression() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: LiteralExpression = parseLiteralExpression() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: IfExpression = parseIfExpression() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: SwitchExpression = parseSwitchExpression() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: ForExpression = parseForExpression() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: WhileExpression = parseWhileExpression() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: RepeatExpression = parseRepeatExpression() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: ParenthesizedExpression = parseParenthesizedExpression() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: ReturnExpression = parseReturnExpression() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: ThrowExpression = parseThrowExpression() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: BreakExpression = parseBreakExpression() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: InitializerCall = parseInitializerCall() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: ThisExpression = parseThisExpression() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: SuperExpression = parseSuperExpression() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: NullExpression = parseNullExpression() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(Position(start), errors)
    }

    function parseIdentifierExpression() -> IdentifierExpression throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let name: String? = lexer.parseIdentifier()
        if (name != null) && (name is Identifier)
            lexer.advance()
        mutable ret: IdentifierExpression = IdentifierExpression(name, Position(start), lexer.getPosition())

        return ret
    }

    function parseLiteralExpression() -> LiteralExpression throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let literal: Literal? = lexer.parseLiteral()
        if literal != null
            lexer.advance()
        mutable ret: LiteralExpression = LiteralExpression(literal, Position(start), lexer.getPosition())

        return ret
    }

    function parseIfExpression() -> IfExpression throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(ifKeyword)
        if success
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let condition: Expression = parseExpression() catch _(error)
            throw (error)
        mutable start: Position = lexer.getPreviousPosition()
        let consequent: Expression = parseExpression() catch _(error)
            throw (error)
        mutable start: Position = lexer.getPreviousPosition()
        let elseClause: ElseClause = parseElseClause() catch _(error) null
        mutable ret: IfExpression = IfExpression(condition, consequent, elseClause, Position(start), lexer.getPosition())
       condition.parent = ret
       consequent.parent = ret
       if elseClause != null
           elseClause.parent = ret

        return ret
    }

    function parseSwitchExpression() -> SwitchExpression throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(switchKeyword)
        if success
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let expression: Expression = parseExpression() catch _(error)
            throw (error)
        mutable start: Position = lexer.getPreviousPosition()
        let body: SwitchBody = parseSwitchBody() catch _(error)
            throw (error)
        mutable ret: SwitchExpression = SwitchExpression(expression, body, Position(start), lexer.getPosition())
       expression.parent = ret
       body.parent = ret

        return ret
    }

    function parseForExpression() -> ForExpression throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(forKeyword)
        if success
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let pattern: Pattern = parsePattern() catch _(error)
            throw (error)
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(inKeyword)
        if success
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let expression: Expression = parseExpression() catch _(error)
            throw (error)
        mutable start: Position = lexer.getPreviousPosition()
        let code: Expression = parseExpression() catch _(error)
            throw (error)
        mutable ret: ForExpression = ForExpression(pattern, expression, code, Position(start), lexer.getPosition())
       pattern.parent = ret
       expression.parent = ret
       code.parent = ret

        return ret
    }

    function parseWhileExpression() -> WhileExpression throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(whileKeyword)
        if success
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let condition: Expression = parseExpression() catch _(error)
            throw (error)
        mutable start: Position = lexer.getPreviousPosition()
        let code: Expression = parseExpression() catch _(error)
            throw (error)
        mutable ret: WhileExpression = WhileExpression(condition, code, Position(start), lexer.getPosition())
       condition.parent = ret
       code.parent = ret

        return ret
    }

    function parseRepeatExpression() -> RepeatExpression throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(repeatKeyword)
        if success
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let code: Expression = parseExpression() catch _(error)
            throw (error)
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(whileKeyword)
        if success
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let condition: Expression = parseExpression() catch _(error)
            throw (error)
        mutable ret: RepeatExpression = RepeatExpression(code, condition, Position(start), lexer.getPosition())
       code.parent = ret
       condition.parent = ret

        return ret
    }

    function parseParenthesizedExpression() -> ParenthesizedExpression throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(leftParen)
        if success
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let expressionElements: [ExpressionElement] = parseExpressionElementList() catch _(error) null
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(rightParen)
        if success
            lexer.advance()
        mutable ret: ParenthesizedExpression = ParenthesizedExpression(expressionElements, Position(start), lexer.getPosition())
        if expressionElements != null {
            for item in expressionElements
                item.parent = ret
        }

        return ret
    }

    function parseReturnExpression() -> ReturnExpression throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(returnKeyword)
        if success
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let expression: Expression = parseExpression() catch _(error) null
        mutable ret: ReturnExpression = ReturnExpression(expression, Position(start), lexer.getPosition())
       if expression != null
           expression.parent = ret

        return ret
    }

    function parseThrowExpression() -> ThrowExpression throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(throwKeyword)
        if success
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let expression: Expression = parseExpression() catch _(error) null
        mutable ret: ThrowExpression = ThrowExpression(expression, Position(start), lexer.getPosition())
       if expression != null
           expression.parent = ret

        return ret
    }

    function parseBreakExpression() -> BreakExpression throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(breakKeyword)
        if success
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let expression: Expression = parseExpression() catch _(error) null
        mutable ret: BreakExpression = BreakExpression(expression, Position(start), lexer.getPosition())
       if expression != null
           expression.parent = ret

        return ret
    }

    function parseInitializerCall() -> InitializerCall throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let typeToInitialize: Type = parseType() catch _(error)
            throw (error)
        mutable start: Position = lexer.getPreviousPosition()
        let arguments: ParenthesizedExpression = parseParenthesizedExpression() catch _(error)
            throw (error)
        mutable start: Position = lexer.getPreviousPosition()
        let catchClauses: [CatchClause] = parseCatchClauseList() catch _(error) null
        mutable ret: InitializerCall = InitializerCall(typeToInitialize, arguments, catchClauses, Position(start), lexer.getPosition())
       typeToInitialize.parent = ret
       arguments.parent = ret
        if catchClauses != null {
            for item in catchClauses
                item.parent = ret
        }

        return ret
    }

    function parseThisExpression() -> ThisExpression throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(thisKeyword)
        if success
            lexer.advance()
        mutable ret: ThisExpression = ThisExpression(Position(start), lexer.getPosition())

        return ret
    }

    function parseSuperExpression() -> SuperExpression throws ParserError {
        let errors: [ParserError] = [ParserError]()
        mutable start: Position = lexer.getPreviousPosition()

        {
            let node: SuperDot = parseSuperDot() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: SuperSubscript = parseSuperSubscript() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(Position(start), errors)
    }

    function parseSuperDot() -> SuperDot throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(superKeyword)
        if success
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(dot)
        if success
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let member: CommonSuperMember = parseCommonSuperMember() catch _(error)
            throw (error)
        mutable ret: SuperDot = SuperDot(member, Position(start), lexer.getPosition())
       member.parent = ret

        return ret
    }

    function parseSuperSubscript() -> SuperSubscript throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(superKeyword)
        if success
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let subscript: Subscript = parseSubscript() catch _(error)
            throw (error)
        mutable ret: SuperSubscript = SuperSubscript(subscript, Position(start), lexer.getPosition())
       subscript.parent = ret

        return ret
    }

    function parseNullExpression() -> NullExpression throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(nullKeyword)
        if success
            lexer.advance()
        mutable ret: NullExpression = NullExpression(Position(start), lexer.getPosition())

        return ret
    }

    function parseElseClause() -> ElseClause throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(elseKeyword)
        if success
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let alternative: Expression = parseExpression() catch _(error)
            throw (error)
        mutable ret: ElseClause = ElseClause(alternative, Position(start), lexer.getPosition())
       alternative.parent = ret

        return ret
    }

    function parseSwitchBody() -> SwitchBody throws ParserError {
        let errors: [ParserError] = [ParserError]()
        mutable start: Position = lexer.getPreviousPosition()

        {
            let node: CurliedSwitchBody = parseCurliedSwitchBody() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: NakedSwitchBody = parseNakedSwitchBody() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(Position(start), errors)
    }

    function parseCurliedSwitchBody() -> CurliedSwitchBody throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(leftCurly)
        if success
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let cases: [SwitchCase] = parseSwitchCaseList() catch _(error)
            throw (error)
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(rightCurly)
        if success
            lexer.advance()
        mutable ret: CurliedSwitchBody = CurliedSwitchBody(cases, Position(start), lexer.getPosition())
        if cases != null {
            for item in cases
                item.parent = ret
        }

        return ret
    }

    function parseNakedSwitchBody() -> NakedSwitchBody throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let cases: [SwitchCase] = parseSwitchCaseList() catch _(error)
            throw (error)
        mutable ret: NakedSwitchBody = NakedSwitchBody(cases, Position(start), lexer.getPosition())
        if cases != null {
            for item in cases
                item.parent = ret
        }

        return ret
    }

    function parseSwitchCaseList() -> [SwitchCase] throws ParserError {
        mutable ret: [SwitchCase]? = [SwitchCase]()
        while true
            ret.push(parseSwitchCase() catch _ break)
        return ret
    }

    function parseSwitchCase() -> SwitchCase throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let label: CaseLabel = parseCaseLabel() catch _(error)
            throw (error)
        mutable start: Position = lexer.getPreviousPosition()
        let content: CaseContent = parseCaseContent() catch _(error)
            throw (error)
        mutable ret: SwitchCase = SwitchCase(label, content, Position(start), lexer.getPosition())
       label.parent = ret
       content.parent = ret

        return ret
    }

    function parseCaseLabel() -> CaseLabel throws ParserError {
        let errors: [ParserError] = [ParserError]()
        mutable start: Position = lexer.getPreviousPosition()

        {
            let node: ItemCaseLabel = parseItemCaseLabel() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: DefaultCaseLabel = parseDefaultCaseLabel() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(Position(start), errors)
    }

    function parseItemCaseLabel() -> ItemCaseLabel throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(caseKeyword)
        if success
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let pattern: Pattern = parsePattern() catch _(error)
            throw (error)
        mutable start: Position = lexer.getPreviousPosition()
        let additionalPatterns: [CaseItem] = parseCaseItemList() catch _(error) null
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(colon)
        if success
            lexer.advance()
        mutable ret: ItemCaseLabel = ItemCaseLabel(pattern, additionalPatterns, Position(start), lexer.getPosition())
       pattern.parent = ret
        if additionalPatterns != null {
            for item in additionalPatterns
                item.parent = ret
        }

        return ret
    }

    function parseDefaultCaseLabel() -> DefaultCaseLabel throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(defaultKeyword)
        if success
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(colon)
        if success
            lexer.advance()
        mutable ret: DefaultCaseLabel = DefaultCaseLabel(Position(start), lexer.getPosition())

        return ret
    }

    function parseCaseItemList() -> [CaseItem] throws ParserError {
        mutable ret: [CaseItem]? = [CaseItem]()
        while true
            ret.push(parseCaseItem() catch _ break)
        return ret
    }

    function parseCaseItem() -> CaseItem throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(comma)
        if success
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let pattern: Pattern = parsePattern() catch _(error)
            throw (error)
        mutable ret: CaseItem = CaseItem(pattern, Position(start), lexer.getPosition())
       pattern.parent = ret

        return ret
    }

    function parsePattern() -> Pattern throws ParserError {
        let errors: [ParserError] = [ParserError]()
        mutable start: Position = lexer.getPreviousPosition()

        {
            let node: WildcardPattern = parseWildcardPattern() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: IdentifierPattern = parseIdentifierPattern() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: TuplePattern = parseTuplePattern() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: ExpressionPattern = parseExpressionPattern() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(Position(start), errors)
    }

    function parseWildcardPattern() -> WildcardPattern throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(underscore)
        if success
            lexer.advance()
        mutable ret: WildcardPattern = WildcardPattern(Position(start), lexer.getPosition())

        return ret
    }

    function parseIdentifierPattern() -> IdentifierPattern throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let identifier: String? = lexer.parseIdentifier()
        if (identifier != null) && (identifier is Identifier)
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let annotationForType: TypeAnnotation = parseTypeAnnotation() catch _(error) null
        mutable ret: IdentifierPattern = IdentifierPattern(identifier, annotationForType, Position(start), lexer.getPosition())
       if annotationForType != null
           annotationForType.parent = ret

        return ret
    }

    function parseTuplePattern() -> TuplePattern throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(leftParen)
        if success
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let elements: [TuplePatternElement] = parseTuplePatternElementList() catch _(error)
            throw (error)
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(rightParen)
        if success
            lexer.advance()
        mutable ret: TuplePattern = TuplePattern(elements, Position(start), lexer.getPosition())
        if elements != null {
            for item in elements
                item.parent = ret
        }

        return ret
    }

    function parseExpressionPattern() -> ExpressionPattern throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let expression: Expression = parseExpression() catch _(error)
            throw (error)
        mutable ret: ExpressionPattern = ExpressionPattern(expression, Position(start), lexer.getPosition())
       expression.parent = ret

        return ret
    }

    function parseTuplePatternElementList() -> [TuplePatternElement] throws ParserError {
        mutable ret: [TuplePatternElement]? = [TuplePatternElement]()
        while true
            ret.push(parseTuplePatternElement() catch _ break)
        return ret
    }

    function parseTuplePatternElement() -> TuplePatternElement throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let pattern: Pattern = parsePattern() catch _(error)
            throw (error)
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(comma)
        if success
            lexer.advance()
        mutable ret: TuplePatternElement = TuplePatternElement(pattern, Position(start), lexer.getPosition())
       pattern.parent = ret

        return ret
    }

    function parseCaseContent() -> CaseContent throws ParserError {
        let errors: [ParserError] = [ParserError]()
        mutable start: Position = lexer.getPreviousPosition()

        {
            let node: BlockCaseContent = parseBlockCaseContent() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: EmptyCaseContent = parseEmptyCaseContent() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(Position(start), errors)
    }

    function parseBlockCaseContent() -> BlockCaseContent throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let statements: [TerminatedStatement] = parseTerminatedStatementList() catch _(error)
            throw (error)
        mutable ret: BlockCaseContent = BlockCaseContent(statements, Position(start), lexer.getPosition())
        if statements != null {
            for item in statements
                item.parent = ret
        }

        return ret
    }

    function parseEmptyCaseContent() -> EmptyCaseContent throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(semicolon)
        if success
            lexer.advance()
        mutable ret: EmptyCaseContent = EmptyCaseContent(Position(start), lexer.getPosition())

        return ret
    }

    function parseCommonSuperMember() -> CommonSuperMember throws ParserError {
        let errors: [ParserError] = [ParserError]()
        mutable start: Position = lexer.getPreviousPosition()

        {
            let node: SuperInit = parseSuperInit() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: SuperMember = parseSuperMember() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(Position(start), errors)
    }

    function parseSuperInit() -> SuperInit throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(initKeyword)
        if success
            lexer.advance()
        mutable ret: SuperInit = SuperInit(Position(start), lexer.getPosition())

        return ret
    }

    function parseSuperMember() -> SuperMember throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let name: String? = lexer.parseIdentifier()
        if (name != null) && (name is Identifier)
            lexer.advance()
        mutable ret: SuperMember = SuperMember(name, Position(start), lexer.getPosition())

        return ret
    }

    function parseType() -> Type throws ParserError {
        let errors: [ParserError] = [ParserError]()
        mutable start: Position = lexer.getPreviousPosition()

        {
            let node: ArrayType = parseArrayType() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: TypeIdentifier = parseTypeIdentifier() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(Position(start), errors)
    }

    function parseTypeIdentifier() -> TypeIdentifier throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let name: String? = lexer.parseIdentifier()
        if (name != null) && (name is Identifier)
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let subType: SubtypeIdentifier = parseSubtypeIdentifier() catch _(error) null
        mutable start: Position = lexer.getPreviousPosition()
        let postfixes: [TypePostfix] = parseTypePostfixList() catch _(error) null
        mutable ret: TypeIdentifier = TypeIdentifier(name, subType, postfixes, Position(start), lexer.getPosition())
       if subType != null
           subType.parent = ret
        if postfixes != null {
            for item in postfixes
                item.parent = ret
        }

        return ret
    }

    function parseArrayType() -> ArrayType throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(leftBracket)
        if success
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let elementType: Type = parseType() catch _(error)
            throw (error)
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(rightBracket)
        if success
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let postfixes: [TypePostfix] = parseTypePostfixList() catch _(error) null
        mutable ret: ArrayType = ArrayType(elementType, postfixes, Position(start), lexer.getPosition())
       elementType.parent = ret
        if postfixes != null {
            for item in postfixes
                item.parent = ret
        }

        return ret
    }

    function parseTypeAnnotation() -> TypeAnnotation throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(colon)
        if success
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let annotationForType: Type = parseType() catch _(error)
            throw (error)
        mutable ret: TypeAnnotation = TypeAnnotation(annotationForType, Position(start), lexer.getPosition())
       annotationForType.parent = ret

        return ret
    }

    function parseSubtypeIdentifier() -> SubtypeIdentifier throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(dot)
        if success
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let typeIdentifier: TypeIdentifier = parseTypeIdentifier() catch _(error)
            throw (error)
        mutable ret: SubtypeIdentifier = SubtypeIdentifier(typeIdentifier, Position(start), lexer.getPosition())
       typeIdentifier.parent = ret

        return ret
    }

    function parseTypePostfixList() -> [TypePostfix] throws ParserError {
        mutable ret: [TypePostfix]? = [TypePostfix]()
        while true
            ret.push(parseTypePostfix() catch _ break)
        return ret
    }

    function parseTypePostfix() -> TypePostfix throws ParserError {
        let errors: [ParserError] = [ParserError]()
        mutable start: Position = lexer.getPreviousPosition()

        {
            let node: OptionalType = parseOptionalType() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(Position(start), errors)
    }

    function parseOptionalType() -> OptionalType throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(questionMark)
        if success
            lexer.advance()
        mutable ret: OptionalType = OptionalType(Position(start), lexer.getPosition())

        return ret
    }

    function parseTypeInheritanceClause() -> TypeInheritanceClause throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(colon)
        if success
            lexer.advance()
        mutable start: Position = lexer.getPreviousPosition()
        let inheritances: [Inheritance] = parseInheritanceList() catch _(error) null
        mutable ret: TypeInheritanceClause = TypeInheritanceClause(inheritances, Position(start), lexer.getPosition())
        if inheritances != null {
            for item in inheritances
                item.parent = ret
        }

        return ret
    }

    function parseInheritanceList() -> [Inheritance] throws ParserError {
        mutable ret: [Inheritance]? = [Inheritance]()
        while true
            ret.push(parseInheritance() catch _ break)
        return ret
    }

    function parseInheritance() -> Inheritance throws ParserError {
        mutable start: Position = lexer.getPreviousPosition()
        let typeIdentifier: TypeIdentifier = parseTypeIdentifier() catch _(error)
            throw (error)
        mutable start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(comma)
        if success
            lexer.advance()
        mutable ret: Inheritance = Inheritance(typeIdentifier, Position(start), lexer.getPosition())
       typeIdentifier.parent = ret

        return ret
    }

    function isAtEnd() -> bool {
        lexer.isAtEnd()
    }

    function isIdentifier(id: String) -> bool {
        if id.equals(useKeyword)
            return false

        if id.equals(classKeyword)
            return false

        if id.equals(functionKeyword)
            return false

        if id.equals(ifKeyword)
            return false

        if id.equals(elseKeyword)
            return false

        if id.equals(switchKeyword)
            return false

        if id.equals(caseKeyword)
            return false

        if id.equals(defaultKeyword)
            return false

        if id.equals(catchKeyword)
            return false

        if id.equals(forKeyword)
            return false

        if id.equals(inKeyword)
            return false

        if id.equals(whileKeyword)
            return false

        if id.equals(repeatKeyword)
            return false

        if id.equals(returnKeyword)
            return false

        if id.equals(throwKeyword)
            return false

        if id.equals(breakKeyword)
            return false

        if id.equals(throwsKeyword)
            return false

        if id.equals(existingKeyword)
            return false

        if id.equals(overrideKeyword)
            return false

        if id.equals(staticKeyword)
            return false

        if id.equals(letKeyword)
            return false

        if id.equals(varKeyword)
            return false

        if id.equals(mutableKeyword)
            return false

        if id.equals(isKeyword)
            return false

        if id.equals(asKeyword)
            return false

        if id.equals(initKeyword)
            return false

        if id.equals(enumKeyword)
            return false

        if id.equals(superKeyword)
            return false

        if id.equals(thisKeyword)
            return false

        if id.equals(nullKeyword)
            return false

        true
    }

    mutable lexer: Lexer
    let fileName: String

    let useKeyword: String = "use"
    let classKeyword: String = "class"
    let functionKeyword: String = "function"
    let ifKeyword: String = "if"
    let elseKeyword: String = "else"
    let switchKeyword: String = "switch"
    let caseKeyword: String = "case"
    let defaultKeyword: String = "default"
    let catchKeyword: String = "catch"
    let forKeyword: String = "for"
    let inKeyword: String = "in"
    let whileKeyword: String = "while"
    let repeatKeyword: String = "repeat"
    let returnKeyword: String = "return"
    let throwKeyword: String = "throw"
    let breakKeyword: String = "break"
    let throwsKeyword: String = "throws"
    let existingKeyword: String = "existing"
    let overrideKeyword: String = "override"
    let staticKeyword: String = "static"
    let letKeyword: String = "let"
    let varKeyword: String = "var"
    let mutableKeyword: String = "mutable"
    let isKeyword: String = "is"
    let asKeyword: String = "as"
    let initKeyword: String = "init"
    let enumKeyword: String = "enum"
    let superKeyword: String = "super"
    let thisKeyword: String = "this"
    let nullKeyword: String = "null"
    let semicolon: String = ";"
    let equal: String = "="
    let leftAngular: String = "<"
    let rightAngular: String = ">"
    let comma: String = ","
    let leftParen: String = "("
    let rightParen: String = ")"
    let leftCurly: String = "{"
    let rightCurly: String = "}"
    let leftBracket: String = "["
    let rightBracket: String = "]"
    let colon: String = ":"
    let dot: String = "."
    let questionMark: String = "?"
    let underscore: String = "_"
    let evaluatesTo: String = "->"
}
