class Parser {
    init(theFileName: String, text: String) {
        lexer = Lexer(text)
        fileName = theFileName
        useKeyword = String("use")
        classKeyword = String("class")
        functionKeyword = String("function")
        ifKeyword = String("if")
        elseKeyword = String("else")
        switchKeyword = String("switch")
        caseKeyword = String("case")
        defaultKeyword = String("default")
        catchKeyword = String("catch")
        forKeyword = String("for")
        inKeyword = String("in")
        whileKeyword = String("while")
        repeatKeyword = String("repeat")
        returnKeyword = String("return")
        throwKeyword = String("throw")
        breakKeyword = String("break")
        throwsKeyword = String("throws")
        existingKeyword = String("existing")
        overrideKeyword = String("override")
        staticKeyword = String("static")
        letKeyword = String("let")
        varKeyword = String("var")
        mutableKeyword = String("mutable")
        isKeyword = String("is")
        asKeyword = String("as")
        initKeyword = String("init")
        enumKeyword = String("enum")
        superKeyword = String("super")
        thisKeyword = String("this")
        nullKeyword = String("null")
        semicolon = String(";")
        equal = String("=")
        leftAngular = String("<")
        rightAngular = String(">")
        comma = String(",")
        leftParen = String("(")
        rightParen = String(")")
        leftCurly = String("{")
        rightCurly = String("}")
        leftBracket = String("[")
        rightBracket = String("]")
        colon = String(":")
        dot = String(".")
        questionMark = String("?")
        underscore = String("_")
        evaluatesTo = String("->")
    }

    function parseCompilationUnit() -> CompilationUnit throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let statements: [TerminatedStatement] = parseTerminatedStatementList() catch _(error) {
             null
        }
        if !isAtEnd() {
            let current: Position = lexer.getPreviousPosition()
            throw ParserError.NotAtEnd(current)
        }

        if compilationUnit == null
            compilationUnit = CompilationUnit(Position(start), lexer.getPosition())

        compilationUnit.statements = node

        compilationUnit.fileName = fileName;
        return compilationUnit
    }

    function parseTerminatedStatementList() -> [TerminatedStatement] throws ParserError {
        mutable terminatedStatement: [TerminatedStatement]? = [TerminatedStatement]()
        while true
            terminatedStatement.push(parseTerminatedStatement() catch _ break)
        return terminatedStatement
    }

    function parseTerminatedStatement() -> TerminatedStatement throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let statement: Statement = parseStatement() catch _(error) {
            throw (error)
        }

        if terminatedStatement == null
            terminatedStatement = TerminatedStatement(Position(start), lexer.getPosition())

        terminatedStatement.statement = node
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(semicolon)
        if success
            lexer.advance()

        if terminatedStatement == null
            terminatedStatement = TerminatedStatement(Position(start), lexer.getPosition())

        return terminatedStatement
    }

    function parseStatement() -> Statement throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: Declaration = parseDeclaration() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: Expression = parseExpression() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(Position(start), errors)
    }

    function parseDeclaration() -> Declaration throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: UseDeclaration = parseUseDeclaration() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: ConstantDeclaration = parseConstantDeclaration() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: VariableDeclaration = parseVariableDeclaration() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: MutableDeclaration = parseMutableDeclaration() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: FunctionDeclaration = parseFunctionDeclaration() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: EnumDeclaration = parseEnumDeclaration() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: ClassDeclaration = parseClassDeclaration() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: InitializerDeclaration = parseInitializerDeclaration() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(Position(start), errors)
    }

    function parseExpression() -> Expression throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: CodeBlock = parseCodeBlock() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: SimpleExpression = parseSimpleExpression() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(Position(start), errors)
    }

    function parseUseDeclaration() -> UseDeclaration throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(useKeyword)
        if success
            lexer.advance()

        if useDeclaration == null
            useDeclaration = UseDeclaration(Position(start), lexer.getPosition())
        let start: Position = lexer.getPreviousPosition()
        let importModule: PathItem = parsePathItem() catch _(error) {
            throw (error)
        }

        if useDeclaration == null
            useDeclaration = UseDeclaration(Position(start), lexer.getPosition())

        useDeclaration.importModule = node
        let start: Position = lexer.getPreviousPosition()
        let importExtensions: [PathIdentifier] = parsePathIdentifierList() catch _(error) {
             null
        }

        if useDeclaration == null
            useDeclaration = UseDeclaration(Position(start), lexer.getPosition())

        useDeclaration.importExtensions = node

        return useDeclaration
    }

    function parseConstantDeclaration() -> ConstantDeclaration throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(letKeyword)
        if success
            lexer.advance()

        if constantDeclaration == null
            constantDeclaration = ConstantDeclaration(Position(start), lexer.getPosition())
        let start: Position = lexer.getPreviousPosition()
        let initializer: BindingInitializer = parseBindingInitializer() catch _(error) {
            throw (error)
        }

        if constantDeclaration == null
            constantDeclaration = ConstantDeclaration(Position(start), lexer.getPosition())

        constantDeclaration.initializer = node

        return constantDeclaration
    }

    function parseVariableDeclaration() -> VariableDeclaration throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(varKeyword)
        if success
            lexer.advance()

        if variableDeclaration == null
            variableDeclaration = VariableDeclaration(Position(start), lexer.getPosition())
        let start: Position = lexer.getPreviousPosition()
        let initializer: BindingInitializer = parseBindingInitializer() catch _(error) {
            throw (error)
        }

        if variableDeclaration == null
            variableDeclaration = VariableDeclaration(Position(start), lexer.getPosition())

        variableDeclaration.initializer = node

        return variableDeclaration
    }

    function parseMutableDeclaration() -> MutableDeclaration throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(mutableKeyword)
        if success
            lexer.advance()

        if mutableDeclaration == null
            mutableDeclaration = MutableDeclaration(Position(start), lexer.getPosition())
        let start: Position = lexer.getPreviousPosition()
        let initializer: BindingInitializer = parseBindingInitializer() catch _(error) {
            throw (error)
        }

        if mutableDeclaration == null
            mutableDeclaration = MutableDeclaration(Position(start), lexer.getPosition())

        mutableDeclaration.initializer = node

        return mutableDeclaration
    }

    function parseFunctionDeclaration() -> FunctionDeclaration throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let modifiers: [Modifier] = parseModifierList() catch _(error) {
             null
        }

        if functionDeclaration == null
            functionDeclaration = FunctionDeclaration(Position(start), lexer.getPosition())

        functionDeclaration.modifiers = node
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(functionKeyword)
        if success
            lexer.advance()

        if functionDeclaration == null
            functionDeclaration = FunctionDeclaration(Position(start), lexer.getPosition())
        let start: Position = lexer.getPreviousPosition()
        let name: FunctionName = parseFunctionName() catch _(error) {
            throw (error)
        }

        if functionDeclaration == null
            functionDeclaration = FunctionDeclaration(Position(start), lexer.getPosition())

        functionDeclaration.name = node
        let start: Position = lexer.getPreviousPosition()
        let signature: FunctionSignature = parseFunctionSignature() catch _(error) {
            throw (error)
        }

        if functionDeclaration == null
            functionDeclaration = FunctionDeclaration(Position(start), lexer.getPosition())

        functionDeclaration.signature = node
        let start: Position = lexer.getPreviousPosition()
        let body: Expression = parseExpression() catch _(error) {
             null
        }

        if functionDeclaration == null
            functionDeclaration = FunctionDeclaration(Position(start), lexer.getPosition())

        functionDeclaration.body = node

        return functionDeclaration
    }

    function parseEnumDeclaration() -> EnumDeclaration throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(enumKeyword)
        if success
            lexer.advance()

        if enumDeclaration == null
            enumDeclaration = EnumDeclaration(Position(start), lexer.getPosition())
        let start: Position = lexer.getPreviousPosition()
        let name: String? = lexer.parseIdentifier()
        if (name != null) && (name is Identifier)
            lexer.advance()

        if enumDeclaration == null
            enumDeclaration = EnumDeclaration(Position(start), lexer.getPosition())

        enumDeclaration.name = name
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(leftCurly)
        if success
            lexer.advance()

        if enumDeclaration == null
            enumDeclaration = EnumDeclaration(Position(start), lexer.getPosition())
        let start: Position = lexer.getPreviousPosition()
        let members: [EnumMember] = parseEnumMemberList() catch _(error) {
            throw (error)
        }

        if enumDeclaration == null
            enumDeclaration = EnumDeclaration(Position(start), lexer.getPosition())

        enumDeclaration.members = node
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(rightCurly)
        if success
            lexer.advance()

        if enumDeclaration == null
            enumDeclaration = EnumDeclaration(Position(start), lexer.getPosition())

        return enumDeclaration
    }

    function parseClassDeclaration() -> ClassDeclaration throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(classKeyword)
        if success
            lexer.advance()

        if classDeclaration == null
            classDeclaration = ClassDeclaration(Position(start), lexer.getPosition())
        let start: Position = lexer.getPreviousPosition()
        let name: String? = lexer.parseIdentifier()
        if (name != null) && (name is Identifier)
            lexer.advance()

        if classDeclaration == null
            classDeclaration = ClassDeclaration(Position(start), lexer.getPosition())

        classDeclaration.name = name
        let start: Position = lexer.getPreviousPosition()
        let genericArgumentClause: GenericArgumentClause = parseGenericArgumentClause() catch _(error) {
             null
        }

        if classDeclaration == null
            classDeclaration = ClassDeclaration(Position(start), lexer.getPosition())

        classDeclaration.genericArgumentClause = node
        let start: Position = lexer.getPreviousPosition()
        let typeInheritanceClause: TypeInheritanceClause = parseTypeInheritanceClause() catch _(error) {
             null
        }

        if classDeclaration == null
            classDeclaration = ClassDeclaration(Position(start), lexer.getPosition())

        classDeclaration.typeInheritanceClause = node
        let start: Position = lexer.getPreviousPosition()
        let body: ClassBody = parseClassBody() catch _(error) {
             null
        }

        if classDeclaration == null
            classDeclaration = ClassDeclaration(Position(start), lexer.getPosition())

        classDeclaration.body = node

        return classDeclaration
    }

    function parseInitializerDeclaration() -> InitializerDeclaration throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let modifiers: [Modifier] = parseModifierList() catch _(error) {
             null
        }

        if initializerDeclaration == null
            initializerDeclaration = InitializerDeclaration(Position(start), lexer.getPosition())

        initializerDeclaration.modifiers = node
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(initKeyword)
        if success
            lexer.advance()

        if initializerDeclaration == null
            initializerDeclaration = InitializerDeclaration(Position(start), lexer.getPosition())
        let start: Position = lexer.getPreviousPosition()
        let parameterClause: ParameterClause = parseParameterClause() catch _(error) {
            throw (error)
        }

        if initializerDeclaration == null
            initializerDeclaration = InitializerDeclaration(Position(start), lexer.getPosition())

        initializerDeclaration.parameterClause = node
        let start: Position = lexer.getPreviousPosition()
        let throwsClause: ThrowsClause = parseThrowsClause() catch _(error) {
             null
        }

        if initializerDeclaration == null
            initializerDeclaration = InitializerDeclaration(Position(start), lexer.getPosition())

        initializerDeclaration.throwsClause = node
        let start: Position = lexer.getPreviousPosition()
        let body: Expression = parseExpression() catch _(error) {
            throw (error)
        }

        if initializerDeclaration == null
            initializerDeclaration = InitializerDeclaration(Position(start), lexer.getPosition())

        initializerDeclaration.body = node

        return initializerDeclaration
    }

    function parseCodeBlock() -> CodeBlock throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(leftCurly)
        if success
            lexer.advance()

        if codeBlock == null
            codeBlock = CodeBlock(Position(start), lexer.getPosition())
        let start: Position = lexer.getPreviousPosition()
        let statements: [TerminatedStatement] = parseTerminatedStatementList() catch _(error) {
            throw (error)
        }

        if codeBlock == null
            codeBlock = CodeBlock(Position(start), lexer.getPosition())

        codeBlock.statements = node
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(rightCurly)
        if success
            lexer.advance()

        if codeBlock == null
            codeBlock = CodeBlock(Position(start), lexer.getPosition())

        return codeBlock
    }

    function parseSimpleExpression() -> SimpleExpression throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let prefixExpression: PrefixExpression = parsePrefixExpression() catch _(error) {
            throw (error)
        }

        if simpleExpression == null
            simpleExpression = SimpleExpression(Position(start), lexer.getPosition())

        simpleExpression.prefixExpression = node
        let start: Position = lexer.getPreviousPosition()
        let binaryOps: [BinaryOp] = parseBinaryOpList() catch _(error) {
             null
        }

        if simpleExpression == null
            simpleExpression = SimpleExpression(Position(start), lexer.getPosition())

        simpleExpression.binaryOps = node

        return simpleExpression
    }

    function parsePathIdentifierList() -> [PathIdentifier] throws ParserError {
        mutable pathIdentifier: [PathIdentifier]? = [PathIdentifier]()
        while true
            pathIdentifier.push(parsePathIdentifier() catch _ break)
        return pathIdentifier
    }

    function parsePathIdentifier() -> PathIdentifier throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(dot)
        if success
            lexer.advance()

        if pathIdentifier == null
            pathIdentifier = PathIdentifier(Position(start), lexer.getPosition())
        let start: Position = lexer.getPreviousPosition()
        let extension: PathItem = parsePathItem() catch _(error) {
            throw (error)
        }

        if pathIdentifier == null
            pathIdentifier = PathIdentifier(Position(start), lexer.getPosition())

        pathIdentifier.extension = node

        return pathIdentifier
    }

    function parsePathItem() -> PathItem throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let name: String? = lexer.parseIdentifier()
        if (name != null) && (name is Identifier)
            lexer.advance()

        if pathItem == null
            pathItem = PathItem(Position(start), lexer.getPosition())

        pathItem.name = name

        return pathItem
    }

    function parseInitializer() -> Initializer throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(equal)
        if success
            lexer.advance()

        if initializer == null
            initializer = Initializer(Position(start), lexer.getPosition())
        let start: Position = lexer.getPreviousPosition()
        let expression: Expression = parseExpression() catch _(error) {
            throw (error)
        }

        if initializer == null
            initializer = Initializer(Position(start), lexer.getPosition())

        initializer.expression = node

        return initializer
    }

    function parseBindingInitializer() -> BindingInitializer throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let initializer: PatternInitializer = parsePatternInitializer() catch _(error) {
            throw (error)
        }

        if bindingInitializer == null
            bindingInitializer = BindingInitializer(Position(start), lexer.getPosition())

        bindingInitializer.initializer = node
        let start: Position = lexer.getPreviousPosition()
        let additionalInitializers: [AdditionalInitializer] = parseAdditionalInitializerList() catch _(error) {
             null
        }

        if bindingInitializer == null
            bindingInitializer = BindingInitializer(Position(start), lexer.getPosition())

        bindingInitializer.additionalInitializers = node

        return bindingInitializer
    }

    function parsePatternInitializerList() -> [PatternInitializer] throws ParserError {
        mutable patternInitializer: [PatternInitializer]? = [PatternInitializer]()
        while true
            patternInitializer.push(parsePatternInitializer() catch _ break)
        return patternInitializer
    }

    function parsePatternInitializer() -> PatternInitializer throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let pattern: Pattern = parsePattern() catch _(error) {
            throw (error)
        }

        if patternInitializer == null
            patternInitializer = PatternInitializer(Position(start), lexer.getPosition())

        patternInitializer.pattern = node
        let start: Position = lexer.getPreviousPosition()
        let initializer: Initializer = parseInitializer() catch _(error) {
             null
        }

        if patternInitializer == null
            patternInitializer = PatternInitializer(Position(start), lexer.getPosition())

        patternInitializer.initializer = node

        return patternInitializer
    }

    function parseAdditionalInitializerList() -> [AdditionalInitializer] throws ParserError {
        mutable additionalInitializer: [AdditionalInitializer]? = [AdditionalInitializer]()
        while true
            additionalInitializer.push(parseAdditionalInitializer() catch _ break)
        return additionalInitializer
    }

    function parseAdditionalInitializer() -> AdditionalInitializer throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(comma)
        if success
            lexer.advance()

        if additionalInitializer == null
            additionalInitializer = AdditionalInitializer(Position(start), lexer.getPosition())
        let start: Position = lexer.getPreviousPosition()
        let pattern: PatternInitializer = parsePatternInitializer() catch _(error) {
            throw (error)
        }

        if additionalInitializer == null
            additionalInitializer = AdditionalInitializer(Position(start), lexer.getPosition())

        additionalInitializer.pattern = node

        return additionalInitializer
    }

    function parseModifierList() -> [Modifier] throws ParserError {
        mutable modifier: [Modifier]? = [Modifier]()
        while true
            modifier.push(parseModifier() catch _ break)
        return modifier
    }

    function parseModifier() -> Modifier throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: OverrideWord = parseOverrideWord() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: StaticWord = parseStaticWord() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(Position(start), errors)
    }

    function parseOverrideWord() -> OverrideWord throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(overrideKeyword)
        if success
            lexer.advance()

        if overrideWord == null
            overrideWord = OverrideWord(Position(start), lexer.getPosition())

        return overrideWord
    }

    function parseStaticWord() -> StaticWord throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(staticKeyword)
        if success
            lexer.advance()

        if staticWord == null
            staticWord = StaticWord(Position(start), lexer.getPosition())

        return staticWord
    }

    function parseFunctionName() -> FunctionName throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: IdentifierFunction = parseIdentifierFunction() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(Position(start), errors)
    }

    function parseIdentifierFunction() -> IdentifierFunction throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let name: String? = lexer.parseIdentifier()
        if (name != null) && (name is Identifier)
            lexer.advance()

        if identifierFunction == null
            identifierFunction = IdentifierFunction(Position(start), lexer.getPosition())

        identifierFunction.name = name

        return identifierFunction
    }

    function parseFunctionSignature() -> FunctionSignature throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let parameterClause: ParameterClause = parseParameterClause() catch _(error) {
            throw (error)
        }

        if functionSignature == null
            functionSignature = FunctionSignature(Position(start), lexer.getPosition())

        functionSignature.parameterClause = node
        let start: Position = lexer.getPreviousPosition()
        let result: FunctionResult = parseFunctionResult() catch _(error) {
             null
        }

        if functionSignature == null
            functionSignature = FunctionSignature(Position(start), lexer.getPosition())

        functionSignature.result = node
        let start: Position = lexer.getPreviousPosition()
        let throwsClause: ThrowsClause = parseThrowsClause() catch _(error) {
             null
        }

        if functionSignature == null
            functionSignature = FunctionSignature(Position(start), lexer.getPosition())

        functionSignature.throwsClause = node

        return functionSignature
    }

    function parseFunctionResult() -> FunctionResult throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(evaluatesTo)
        if success
            lexer.advance()

        if functionResult == null
            functionResult = FunctionResult(Position(start), lexer.getPosition())
        let start: Position = lexer.getPreviousPosition()
        let existingObject: ExistingClause = parseExistingClause() catch _(error) {
             null
        }

        if functionResult == null
            functionResult = FunctionResult(Position(start), lexer.getPosition())

        functionResult.existingObject = node
        let start: Position = lexer.getPreviousPosition()
        let resultType: Type = parseType() catch _(error) {
            throw (error)
        }

        if functionResult == null
            functionResult = FunctionResult(Position(start), lexer.getPosition())

        functionResult.resultType = node

        return functionResult
    }

    function parseExistingClause() -> ExistingClause throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(existingKeyword)
        if success
            lexer.advance()

        if existingClause == null
            existingClause = ExistingClause(Position(start), lexer.getPosition())

        return existingClause
    }

    function parseParameterClauseList() -> [ParameterClause] throws ParserError {
        mutable parameterClause: [ParameterClause]? = [ParameterClause]()
        while true
            parameterClause.push(parseParameterClause() catch _ break)
        return parameterClause
    }

    function parseParameterClause() -> ParameterClause throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(leftParen)
        if success
            lexer.advance()

        if parameterClause == null
            parameterClause = ParameterClause(Position(start), lexer.getPosition())
        let start: Position = lexer.getPreviousPosition()
        let parameters: [Parameter] = parseParameterList() catch _(error) {
             null
        }

        if parameterClause == null
            parameterClause = ParameterClause(Position(start), lexer.getPosition())

        parameterClause.parameters = node
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(rightParen)
        if success
            lexer.advance()

        if parameterClause == null
            parameterClause = ParameterClause(Position(start), lexer.getPosition())

        return parameterClause
    }

    function parseParameterList() -> [Parameter] throws ParserError {
        mutable parameter: [Parameter]? = [Parameter]()
        while true
            parameter.push(parseParameter() catch _ break)
        return parameter
    }

    function parseParameter() -> Parameter throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: ConstParameter = parseConstParameter() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: VarParameter = parseVarParameter() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(Position(start), errors)
    }

    function parseConstParameter() -> ConstParameter throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(letKeyword)
        if success
            lexer.advance()

        if constParameter == null
            constParameter = ConstParameter(Position(start), lexer.getPosition())
        let start: Position = lexer.getPreviousPosition()
        let name: String? = lexer.parseIdentifier()
        if (name != null) && (name is Identifier)
            lexer.advance()

        if constParameter == null
            constParameter = ConstParameter(Position(start), lexer.getPosition())

        constParameter.name = name
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(colon)
        if success
            lexer.advance()

        if constParameter == null
            constParameter = ConstParameter(Position(start), lexer.getPosition())
        let start: Position = lexer.getPreviousPosition()
        let parameterType: Type = parseType() catch _(error) {
            throw (error)
        }

        if constParameter == null
            constParameter = ConstParameter(Position(start), lexer.getPosition())

        constParameter.parameterType = node
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(comma)
        if success
            lexer.advance()

        if constParameter == null
            constParameter = ConstParameter(Position(start), lexer.getPosition())

        return constParameter
    }

    function parseVarParameter() -> VarParameter throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(mutableKeyword)
        if success
            lexer.advance()

        if varParameter == null
            varParameter = VarParameter(Position(start), lexer.getPosition())
        let start: Position = lexer.getPreviousPosition()
        let name: String? = lexer.parseIdentifier()
        if (name != null) && (name is Identifier)
            lexer.advance()

        if varParameter == null
            varParameter = VarParameter(Position(start), lexer.getPosition())

        varParameter.name = name
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(colon)
        if success
            lexer.advance()

        if varParameter == null
            varParameter = VarParameter(Position(start), lexer.getPosition())
        let start: Position = lexer.getPreviousPosition()
        let parameterType: Type = parseType() catch _(error) {
            throw (error)
        }

        if varParameter == null
            varParameter = VarParameter(Position(start), lexer.getPosition())

        varParameter.parameterType = node
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(comma)
        if success
            lexer.advance()

        if varParameter == null
            varParameter = VarParameter(Position(start), lexer.getPosition())

        return varParameter
    }

    function parseThrowsClause() -> ThrowsClause throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(throwsKeyword)
        if success
            lexer.advance()

        if throwsClause == null
            throwsClause = ThrowsClause(Position(start), lexer.getPosition())
        let start: Position = lexer.getPreviousPosition()
        let throwsType: Type = parseType() catch _(error) {
            throw (error)
        }

        if throwsClause == null
            throwsClause = ThrowsClause(Position(start), lexer.getPosition())

        throwsClause.throwsType = node

        return throwsClause
    }

    function parseEnumMemberList() -> [EnumMember] throws ParserError {
        mutable enumMember: [EnumMember]? = [EnumMember]()
        while true
            enumMember.push(parseEnumMember() catch _ break)
        return enumMember
    }

    function parseEnumMember() -> EnumMember throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(caseKeyword)
        if success
            lexer.advance()

        if enumMember == null
            enumMember = EnumMember(Position(start), lexer.getPosition())
        let start: Position = lexer.getPreviousPosition()
        let enumCase: EnumCase = parseEnumCase() catch _(error) {
            throw (error)
        }

        if enumMember == null
            enumMember = EnumMember(Position(start), lexer.getPosition())

        enumMember.enumCase = node
        let start: Position = lexer.getPreviousPosition()
        let additionalCases: [AdditionalCase] = parseAdditionalCaseList() catch _(error) {
             null
        }

        if enumMember == null
            enumMember = EnumMember(Position(start), lexer.getPosition())

        enumMember.additionalCases = node
        let start: Position = lexer.getPreviousPosition()
        let parameterClause: ParameterClause = parseParameterClause() catch _(error) {
             null
        }

        if enumMember == null
            enumMember = EnumMember(Position(start), lexer.getPosition())

        enumMember.parameterClause = node

        return enumMember
    }

    function parseEnumCase() -> EnumCase throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let name: String? = lexer.parseIdentifier()
        if (name != null) && (name is Identifier)
            lexer.advance()

        if enumCase == null
            enumCase = EnumCase(Position(start), lexer.getPosition())

        enumCase.name = name

        return enumCase
    }

    function parseAdditionalCaseList() -> [AdditionalCase] throws ParserError {
        mutable additionalCase: [AdditionalCase]? = [AdditionalCase]()
        while true
            additionalCase.push(parseAdditionalCase() catch _ break)
        return additionalCase
    }

    function parseAdditionalCase() -> AdditionalCase throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(comma)
        if success
            lexer.advance()

        if additionalCase == null
            additionalCase = AdditionalCase(Position(start), lexer.getPosition())
        let start: Position = lexer.getPreviousPosition()
        let enumCase: EnumCase = parseEnumCase() catch _(error) {
            throw (error)
        }

        if additionalCase == null
            additionalCase = AdditionalCase(Position(start), lexer.getPosition())

        additionalCase.enumCase = node

        return additionalCase
    }

    function parseClassBody() -> ClassBody throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(leftCurly)
        if success
            lexer.advance()

        if classBody == null
            classBody = ClassBody(Position(start), lexer.getPosition())
        let start: Position = lexer.getPreviousPosition()
        let members: [ClassMember] = parseClassMemberList() catch _(error) {
             null
        }

        if classBody == null
            classBody = ClassBody(Position(start), lexer.getPosition())

        classBody.members = node
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(rightCurly)
        if success
            lexer.advance()

        if classBody == null
            classBody = ClassBody(Position(start), lexer.getPosition())

        return classBody
    }

    function parseGenericArgumentClause() -> GenericArgumentClause throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(leftAngular)
        if success
            lexer.advance()

        if genericArgumentClause == null
            genericArgumentClause = GenericArgumentClause(Position(start), lexer.getPosition())
        let start: Position = lexer.getPreviousPosition()
        let genericParameters: [GenericParameter] = parseGenericParameterList() catch _(error) {
            throw (error)
        }

        if genericArgumentClause == null
            genericArgumentClause = GenericArgumentClause(Position(start), lexer.getPosition())

        genericArgumentClause.genericParameters = node
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(rightAngular)
        if success
            lexer.advance()

        if genericArgumentClause == null
            genericArgumentClause = GenericArgumentClause(Position(start), lexer.getPosition())

        return genericArgumentClause
    }

    function parseGenericParameterList() -> [GenericParameter] throws ParserError {
        mutable genericParameter: [GenericParameter]? = [GenericParameter]()
        while true
            genericParameter.push(parseGenericParameter() catch _ break)
        return genericParameter
    }

    function parseGenericParameter() -> GenericParameter throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let typeName: String? = lexer.parseIdentifier()
        if (typeName != null) && (typeName is Identifier)
            lexer.advance()

        if genericParameter == null
            genericParameter = GenericParameter(Position(start), lexer.getPosition())

        genericParameter.typeName = typeName

        return genericParameter
    }

    function parseClassMemberList() -> [ClassMember] throws ParserError {
        mutable classMember: [ClassMember]? = [ClassMember]()
        while true
            classMember.push(parseClassMember() catch _ break)
        return classMember
    }

    function parseClassMember() -> ClassMember throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let declaration: Declaration = parseDeclaration() catch _(error) {
            throw (error)
        }

        if classMember == null
            classMember = ClassMember(Position(start), lexer.getPosition())

        classMember.declaration = node
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(semicolon)
        if success
            lexer.advance()

        if classMember == null
            classMember = ClassMember(Position(start), lexer.getPosition())

        return classMember
    }

    function parsePrefixExpression() -> PrefixExpression throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let prefixOperator: String? = lexer.parsePrefixOperator()
        if prefixOperator != null
            lexer.advance()

        if prefixExpression == null
            prefixExpression = PrefixExpression(Position(start), lexer.getPosition())

        prefixExpression.prefixOperator = prefixOperator
        let start: Position = lexer.getPreviousPosition()
        let expression: PostfixExpression = parsePostfixExpression() catch _(error) {
            throw (error)
        }

        if prefixExpression == null
            prefixExpression = PrefixExpression(Position(start), lexer.getPosition())

        prefixExpression.expression = node

        return prefixExpression
    }

    function parsePostfixExpression() -> PostfixExpression throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let primaryExpression: PrimaryExpression = parsePrimaryExpression() catch _(error) {
            throw (error)
        }

        if postfixExpression == null
            postfixExpression = PostfixExpression(Position(start), lexer.getPosition())

        postfixExpression.primaryExpression = node
        let start: Position = lexer.getPreviousPosition()
        let postfixes: [Postfix] = parsePostfixList() catch _(error) {
             null
        }

        if postfixExpression == null
            postfixExpression = PostfixExpression(Position(start), lexer.getPosition())

        postfixExpression.postfixes = node

        return postfixExpression
    }

    function parseBinaryOpList() -> [BinaryOp] throws ParserError {
        mutable binaryOp: [BinaryOp]? = [BinaryOp]()
        while true
            binaryOp.push(parseBinaryOp() catch _ break)
        return binaryOp
    }

    function parseBinaryOp() -> BinaryOp throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: BinaryOperation = parseBinaryOperation() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: Assignment = parseAssignment() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: TypeQuery = parseTypeQuery() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: TypeCast = parseTypeCast() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(Position(start), errors)
    }

    function parseBinaryOperation() -> BinaryOperation throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let binaryOperator: String? = lexer.parseBinaryOperator()
        if binaryOperator != null
            lexer.advance()

        if binaryOperation == null
            binaryOperation = BinaryOperation(Position(start), lexer.getPosition())

        binaryOperation.binaryOperator = binaryOperator
        let start: Position = lexer.getPreviousPosition()
        let expression: PrefixExpression = parsePrefixExpression() catch _(error) {
            throw (error)
        }

        if binaryOperation == null
            binaryOperation = BinaryOperation(Position(start), lexer.getPosition())

        binaryOperation.expression = node

        return binaryOperation
    }

    function parseAssignment() -> Assignment throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(equal)
        if success
            lexer.advance()

        if assignment == null
            assignment = Assignment(Position(start), lexer.getPosition())
        let start: Position = lexer.getPreviousPosition()
        let expression: PrefixExpression = parsePrefixExpression() catch _(error) {
            throw (error)
        }

        if assignment == null
            assignment = Assignment(Position(start), lexer.getPosition())

        assignment.expression = node

        return assignment
    }

    function parseTypeQuery() -> TypeQuery throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(isKeyword)
        if success
            lexer.advance()

        if typeQuery == null
            typeQuery = TypeQuery(Position(start), lexer.getPosition())
        let start: Position = lexer.getPreviousPosition()
        let objectType: Type = parseType() catch _(error) {
            throw (error)
        }

        if typeQuery == null
            typeQuery = TypeQuery(Position(start), lexer.getPosition())

        typeQuery.objectType = node

        return typeQuery
    }

    function parseTypeCast() -> TypeCast throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(asKeyword)
        if success
            lexer.advance()

        if typeCast == null
            typeCast = TypeCast(Position(start), lexer.getPosition())
        let start: Position = lexer.getPreviousPosition()
        let objectType: Type = parseType() catch _(error) {
            throw (error)
        }

        if typeCast == null
            typeCast = TypeCast(Position(start), lexer.getPosition())

        typeCast.objectType = node

        return typeCast
    }

    function parseCatchClauseList() -> [CatchClause] throws ParserError {
        mutable catchClause: [CatchClause]? = [CatchClause]()
        while true
            catchClause.push(parseCatchClause() catch _ break)
        return catchClause
    }

    function parseCatchClause() -> CatchClause throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(catchKeyword)
        if success
            lexer.advance()

        if catchClause == null
            catchClause = CatchClause(Position(start), lexer.getPosition())
        let start: Position = lexer.getPreviousPosition()
        let catchPattern: CatchPattern = parseCatchPattern() catch _(error) {
            throw (error)
        }

        if catchClause == null
            catchClause = CatchClause(Position(start), lexer.getPosition())

        catchClause.catchPattern = node
        let start: Position = lexer.getPreviousPosition()
        let bindingPattern: TuplePattern = parseTuplePattern() catch _(error) {
             null
        }

        if catchClause == null
            catchClause = CatchClause(Position(start), lexer.getPosition())

        catchClause.bindingPattern = node
        let start: Position = lexer.getPreviousPosition()
        let expression: Expression = parseExpression() catch _(error) {
            throw (error)
        }

        if catchClause == null
            catchClause = CatchClause(Position(start), lexer.getPosition())

        catchClause.expression = node

        return catchClause
    }

    function parseCatchPattern() -> CatchPattern throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: WildCardCatchPattern = parseWildCardCatchPattern() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: PathItemCatchPattern = parsePathItemCatchPattern() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(Position(start), errors)
    }

    function parseWildCardCatchPattern() -> WildCardCatchPattern throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let pattern: WildcardPattern = parseWildcardPattern() catch _(error) {
            throw (error)
        }

        if wildCardCatchPattern == null
            wildCardCatchPattern = WildCardCatchPattern(Position(start), lexer.getPosition())

        wildCardCatchPattern.pattern = node

        return wildCardCatchPattern
    }

    function parsePathItemCatchPattern() -> PathItemCatchPattern throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let catchCase: PathItem = parsePathItem() catch _(error) {
            throw (error)
        }

        if pathItemCatchPattern == null
            pathItemCatchPattern = PathItemCatchPattern(Position(start), lexer.getPosition())

        pathItemCatchPattern.catchCase = node
        let start: Position = lexer.getPreviousPosition()
        let catchCaseExtensions: [PathIdentifier] = parsePathIdentifierList() catch _(error) {
             null
        }

        if pathItemCatchPattern == null
            pathItemCatchPattern = PathItemCatchPattern(Position(start), lexer.getPosition())

        pathItemCatchPattern.catchCaseExtensions = node

        return pathItemCatchPattern
    }

    function parsePostfixList() -> [Postfix] throws ParserError {
        mutable postfix: [Postfix]? = [Postfix]()
        while true
            postfix.push(parsePostfix() catch _ break)
        return postfix
    }

    function parsePostfix() -> Postfix throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: OperatorPostfix = parseOperatorPostfix() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: FunctionCall = parseFunctionCall() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: ExplicitMemberExpression = parseExplicitMemberExpression() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: Subscript = parseSubscript() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(Position(start), errors)
    }

    function parseOperatorPostfix() -> OperatorPostfix throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let postfixOperator: String? = lexer.parsePostfixOperator()
        if postfixOperator != null
            lexer.advance()

        if operatorPostfix == null
            operatorPostfix = OperatorPostfix(Position(start), lexer.getPosition())

        operatorPostfix.postfixOperator = postfixOperator

        return operatorPostfix
    }

    function parseFunctionCall() -> FunctionCall throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let arguments: ParenthesizedExpression = parseParenthesizedExpression() catch _(error) {
            throw (error)
        }

        if functionCall == null
            functionCall = FunctionCall(Position(start), lexer.getPosition())

        functionCall.arguments = node
        let start: Position = lexer.getPreviousPosition()
        let catchClauses: [CatchClause] = parseCatchClauseList() catch _(error) {
             null
        }

        if functionCall == null
            functionCall = FunctionCall(Position(start), lexer.getPosition())

        functionCall.catchClauses = node

        return functionCall
    }

    function parseExplicitMemberExpression() -> ExplicitMemberExpression throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(dot)
        if success
            lexer.advance()

        if explicitMemberExpression == null
            explicitMemberExpression = ExplicitMemberExpression(Position(start), lexer.getPosition())
        let start: Position = lexer.getPreviousPosition()
        let memberPostfix: MemberPostfix = parseMemberPostfix() catch _(error) {
            throw (error)
        }

        if explicitMemberExpression == null
            explicitMemberExpression = ExplicitMemberExpression(Position(start), lexer.getPosition())

        explicitMemberExpression.memberPostfix = node

        return explicitMemberExpression
    }

    function parseSubscript() -> Subscript throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(leftBracket)
        if success
            lexer.advance()

        if subscript == null
            subscript = Subscript(Position(start), lexer.getPosition())
        let start: Position = lexer.getPreviousPosition()
        let expressions: [ExpressionElement] = parseExpressionElementList() catch _(error) {
            throw (error)
        }

        if subscript == null
            subscript = Subscript(Position(start), lexer.getPosition())

        subscript.expressions = node
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(rightBracket)
        if success
            lexer.advance()

        if subscript == null
            subscript = Subscript(Position(start), lexer.getPosition())

        return subscript
    }

    function parseExpressionElementList() -> [ExpressionElement] throws ParserError {
        mutable expressionElement: [ExpressionElement]? = [ExpressionElement]()
        while true
            expressionElement.push(parseExpressionElement() catch _ break)
        return expressionElement
    }

    function parseExpressionElement() -> ExpressionElement throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let expression: Expression = parseExpression() catch _(error) {
            throw (error)
        }

        if expressionElement == null
            expressionElement = ExpressionElement(Position(start), lexer.getPosition())

        expressionElement.expression = node
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(comma)
        if success
            lexer.advance()

        if expressionElement == null
            expressionElement = ExpressionElement(Position(start), lexer.getPosition())

        return expressionElement
    }

    function parseMemberPostfix() -> MemberPostfix throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: NamedMemberPostfix = parseNamedMemberPostfix() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(Position(start), errors)
    }

    function parseNamedMemberPostfix() -> NamedMemberPostfix throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let identifier: IdentifierExpression = parseIdentifierExpression() catch _(error) {
            throw (error)
        }

        if namedMemberPostfix == null
            namedMemberPostfix = NamedMemberPostfix(Position(start), lexer.getPosition())

        namedMemberPostfix.identifier = node

        return namedMemberPostfix
    }

    function parsePrimaryExpression() -> PrimaryExpression throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: IdentifierExpression = parseIdentifierExpression() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: LiteralExpression = parseLiteralExpression() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: IfExpression = parseIfExpression() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: SwitchExpression = parseSwitchExpression() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: ForExpression = parseForExpression() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: WhileExpression = parseWhileExpression() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: RepeatExpression = parseRepeatExpression() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: ParenthesizedExpression = parseParenthesizedExpression() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: ReturnExpression = parseReturnExpression() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: ThrowExpression = parseThrowExpression() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: BreakExpression = parseBreakExpression() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: InitializerCall = parseInitializerCall() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: ThisExpression = parseThisExpression() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: SuperExpression = parseSuperExpression() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: NullExpression = parseNullExpression() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(Position(start), errors)
    }

    function parseIdentifierExpression() -> IdentifierExpression throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let name: String? = lexer.parseIdentifier()
        if (name != null) && (name is Identifier)
            lexer.advance()

        if identifierExpression == null
            identifierExpression = IdentifierExpression(Position(start), lexer.getPosition())

        identifierExpression.name = name

        return identifierExpression
    }

    function parseLiteralExpression() -> LiteralExpression throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let literal: Literal? = lexer.parseLiteral()
        if literal != null
            lexer.advance()

        if literalExpression == null
            literalExpression = LiteralExpression(Position(start), lexer.getPosition())

        literalExpression.literal = literal

        return literalExpression
    }

    function parseIfExpression() -> IfExpression throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(ifKeyword)
        if success
            lexer.advance()

        if ifExpression == null
            ifExpression = IfExpression(Position(start), lexer.getPosition())
        let start: Position = lexer.getPreviousPosition()
        let condition: Expression = parseExpression() catch _(error) {
            throw (error)
        }

        if ifExpression == null
            ifExpression = IfExpression(Position(start), lexer.getPosition())

        ifExpression.condition = node
        let start: Position = lexer.getPreviousPosition()
        let consequent: Expression = parseExpression() catch _(error) {
            throw (error)
        }

        if ifExpression == null
            ifExpression = IfExpression(Position(start), lexer.getPosition())

        ifExpression.consequent = node
        let start: Position = lexer.getPreviousPosition()
        let elseClause: ElseClause = parseElseClause() catch _(error) {
             null
        }

        if ifExpression == null
            ifExpression = IfExpression(Position(start), lexer.getPosition())

        ifExpression.elseClause = node

        return ifExpression
    }

    function parseSwitchExpression() -> SwitchExpression throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(switchKeyword)
        if success
            lexer.advance()

        if switchExpression == null
            switchExpression = SwitchExpression(Position(start), lexer.getPosition())
        let start: Position = lexer.getPreviousPosition()
        let expression: Expression = parseExpression() catch _(error) {
            throw (error)
        }

        if switchExpression == null
            switchExpression = SwitchExpression(Position(start), lexer.getPosition())

        switchExpression.expression = node
        let start: Position = lexer.getPreviousPosition()
        let body: SwitchBody = parseSwitchBody() catch _(error) {
            throw (error)
        }

        if switchExpression == null
            switchExpression = SwitchExpression(Position(start), lexer.getPosition())

        switchExpression.body = node

        return switchExpression
    }

    function parseForExpression() -> ForExpression throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(forKeyword)
        if success
            lexer.advance()

        if forExpression == null
            forExpression = ForExpression(Position(start), lexer.getPosition())
        let start: Position = lexer.getPreviousPosition()
        let pattern: Pattern = parsePattern() catch _(error) {
            throw (error)
        }

        if forExpression == null
            forExpression = ForExpression(Position(start), lexer.getPosition())

        forExpression.pattern = node
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(inKeyword)
        if success
            lexer.advance()

        if forExpression == null
            forExpression = ForExpression(Position(start), lexer.getPosition())
        let start: Position = lexer.getPreviousPosition()
        let expression: Expression = parseExpression() catch _(error) {
            throw (error)
        }

        if forExpression == null
            forExpression = ForExpression(Position(start), lexer.getPosition())

        forExpression.expression = node
        let start: Position = lexer.getPreviousPosition()
        let code: Expression = parseExpression() catch _(error) {
            throw (error)
        }

        if forExpression == null
            forExpression = ForExpression(Position(start), lexer.getPosition())

        forExpression.code = node

        return forExpression
    }

    function parseWhileExpression() -> WhileExpression throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(whileKeyword)
        if success
            lexer.advance()

        if whileExpression == null
            whileExpression = WhileExpression(Position(start), lexer.getPosition())
        let start: Position = lexer.getPreviousPosition()
        let condition: Expression = parseExpression() catch _(error) {
            throw (error)
        }

        if whileExpression == null
            whileExpression = WhileExpression(Position(start), lexer.getPosition())

        whileExpression.condition = node
        let start: Position = lexer.getPreviousPosition()
        let code: Expression = parseExpression() catch _(error) {
            throw (error)
        }

        if whileExpression == null
            whileExpression = WhileExpression(Position(start), lexer.getPosition())

        whileExpression.code = node

        return whileExpression
    }

    function parseRepeatExpression() -> RepeatExpression throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(repeatKeyword)
        if success
            lexer.advance()

        if repeatExpression == null
            repeatExpression = RepeatExpression(Position(start), lexer.getPosition())
        let start: Position = lexer.getPreviousPosition()
        let code: Expression = parseExpression() catch _(error) {
            throw (error)
        }

        if repeatExpression == null
            repeatExpression = RepeatExpression(Position(start), lexer.getPosition())

        repeatExpression.code = node
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(whileKeyword)
        if success
            lexer.advance()

        if repeatExpression == null
            repeatExpression = RepeatExpression(Position(start), lexer.getPosition())
        let start: Position = lexer.getPreviousPosition()
        let condition: Expression = parseExpression() catch _(error) {
            throw (error)
        }

        if repeatExpression == null
            repeatExpression = RepeatExpression(Position(start), lexer.getPosition())

        repeatExpression.condition = node

        return repeatExpression
    }

    function parseParenthesizedExpression() -> ParenthesizedExpression throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(leftParen)
        if success
            lexer.advance()

        if parenthesizedExpression == null
            parenthesizedExpression = ParenthesizedExpression(Position(start), lexer.getPosition())
        let start: Position = lexer.getPreviousPosition()
        let expressionElements: [ExpressionElement] = parseExpressionElementList() catch _(error) {
             null
        }

        if parenthesizedExpression == null
            parenthesizedExpression = ParenthesizedExpression(Position(start), lexer.getPosition())

        parenthesizedExpression.expressionElements = node
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(rightParen)
        if success
            lexer.advance()

        if parenthesizedExpression == null
            parenthesizedExpression = ParenthesizedExpression(Position(start), lexer.getPosition())

        return parenthesizedExpression
    }

    function parseReturnExpression() -> ReturnExpression throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(returnKeyword)
        if success
            lexer.advance()

        if returnExpression == null
            returnExpression = ReturnExpression(Position(start), lexer.getPosition())
        let start: Position = lexer.getPreviousPosition()
        let expression: Expression = parseExpression() catch _(error) {
             null
        }

        if returnExpression == null
            returnExpression = ReturnExpression(Position(start), lexer.getPosition())

        returnExpression.expression = node

        return returnExpression
    }

    function parseThrowExpression() -> ThrowExpression throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(throwKeyword)
        if success
            lexer.advance()

        if throwExpression == null
            throwExpression = ThrowExpression(Position(start), lexer.getPosition())
        let start: Position = lexer.getPreviousPosition()
        let expression: Expression = parseExpression() catch _(error) {
             null
        }

        if throwExpression == null
            throwExpression = ThrowExpression(Position(start), lexer.getPosition())

        throwExpression.expression = node

        return throwExpression
    }

    function parseBreakExpression() -> BreakExpression throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(breakKeyword)
        if success
            lexer.advance()

        if breakExpression == null
            breakExpression = BreakExpression(Position(start), lexer.getPosition())
        let start: Position = lexer.getPreviousPosition()
        let expression: Expression = parseExpression() catch _(error) {
             null
        }

        if breakExpression == null
            breakExpression = BreakExpression(Position(start), lexer.getPosition())

        breakExpression.expression = node

        return breakExpression
    }

    function parseInitializerCall() -> InitializerCall throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let typeToInitialize: Type = parseType() catch _(error) {
            throw (error)
        }

        if initializerCall == null
            initializerCall = InitializerCall(Position(start), lexer.getPosition())

        initializerCall.typeToInitialize = node
        let start: Position = lexer.getPreviousPosition()
        let arguments: ParenthesizedExpression = parseParenthesizedExpression() catch _(error) {
            throw (error)
        }

        if initializerCall == null
            initializerCall = InitializerCall(Position(start), lexer.getPosition())

        initializerCall.arguments = node
        let start: Position = lexer.getPreviousPosition()
        let catchClauses: [CatchClause] = parseCatchClauseList() catch _(error) {
             null
        }

        if initializerCall == null
            initializerCall = InitializerCall(Position(start), lexer.getPosition())

        initializerCall.catchClauses = node

        return initializerCall
    }

    function parseThisExpression() -> ThisExpression throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(thisKeyword)
        if success
            lexer.advance()

        if thisExpression == null
            thisExpression = ThisExpression(Position(start), lexer.getPosition())

        return thisExpression
    }

    function parseSuperExpression() -> SuperExpression throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: SuperDot = parseSuperDot() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: SuperSubscript = parseSuperSubscript() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(Position(start), errors)
    }

    function parseSuperDot() -> SuperDot throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(superKeyword)
        if success
            lexer.advance()

        if superDot == null
            superDot = SuperDot(Position(start), lexer.getPosition())
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(dot)
        if success
            lexer.advance()

        if superDot == null
            superDot = SuperDot(Position(start), lexer.getPosition())
        let start: Position = lexer.getPreviousPosition()
        let member: CommonSuperMember = parseCommonSuperMember() catch _(error) {
            throw (error)
        }

        if superDot == null
            superDot = SuperDot(Position(start), lexer.getPosition())

        superDot.member = node

        return superDot
    }

    function parseSuperSubscript() -> SuperSubscript throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(superKeyword)
        if success
            lexer.advance()

        if superSubscript == null
            superSubscript = SuperSubscript(Position(start), lexer.getPosition())
        let start: Position = lexer.getPreviousPosition()
        let subscript: Subscript = parseSubscript() catch _(error) {
            throw (error)
        }

        if superSubscript == null
            superSubscript = SuperSubscript(Position(start), lexer.getPosition())

        superSubscript.subscript = node

        return superSubscript
    }

    function parseNullExpression() -> NullExpression throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(nullKeyword)
        if success
            lexer.advance()

        if nullExpression == null
            nullExpression = NullExpression(Position(start), lexer.getPosition())

        return nullExpression
    }

    function parseElseClause() -> ElseClause throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(elseKeyword)
        if success
            lexer.advance()

        if elseClause == null
            elseClause = ElseClause(Position(start), lexer.getPosition())
        let start: Position = lexer.getPreviousPosition()
        let alternative: Expression = parseExpression() catch _(error) {
            throw (error)
        }

        if elseClause == null
            elseClause = ElseClause(Position(start), lexer.getPosition())

        elseClause.alternative = node

        return elseClause
    }

    function parseSwitchBody() -> SwitchBody throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: CurliedSwitchBody = parseCurliedSwitchBody() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: NakedSwitchBody = parseNakedSwitchBody() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(Position(start), errors)
    }

    function parseCurliedSwitchBody() -> CurliedSwitchBody throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(leftCurly)
        if success
            lexer.advance()

        if curliedSwitchBody == null
            curliedSwitchBody = CurliedSwitchBody(Position(start), lexer.getPosition())
        let start: Position = lexer.getPreviousPosition()
        let cases: [SwitchCase] = parseSwitchCaseList() catch _(error) {
            throw (error)
        }

        if curliedSwitchBody == null
            curliedSwitchBody = CurliedSwitchBody(Position(start), lexer.getPosition())

        curliedSwitchBody.cases = node
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(rightCurly)
        if success
            lexer.advance()

        if curliedSwitchBody == null
            curliedSwitchBody = CurliedSwitchBody(Position(start), lexer.getPosition())

        return curliedSwitchBody
    }

    function parseNakedSwitchBody() -> NakedSwitchBody throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let cases: [SwitchCase] = parseSwitchCaseList() catch _(error) {
            throw (error)
        }

        if nakedSwitchBody == null
            nakedSwitchBody = NakedSwitchBody(Position(start), lexer.getPosition())

        nakedSwitchBody.cases = node

        return nakedSwitchBody
    }

    function parseSwitchCaseList() -> [SwitchCase] throws ParserError {
        mutable switchCase: [SwitchCase]? = [SwitchCase]()
        while true
            switchCase.push(parseSwitchCase() catch _ break)
        return switchCase
    }

    function parseSwitchCase() -> SwitchCase throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let label: CaseLabel = parseCaseLabel() catch _(error) {
            throw (error)
        }

        if switchCase == null
            switchCase = SwitchCase(Position(start), lexer.getPosition())

        switchCase.label = node
        let start: Position = lexer.getPreviousPosition()
        let content: CaseContent = parseCaseContent() catch _(error) {
            throw (error)
        }

        if switchCase == null
            switchCase = SwitchCase(Position(start), lexer.getPosition())

        switchCase.content = node

        return switchCase
    }

    function parseCaseLabel() -> CaseLabel throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: ItemCaseLabel = parseItemCaseLabel() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: DefaultCaseLabel = parseDefaultCaseLabel() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(Position(start), errors)
    }

    function parseItemCaseLabel() -> ItemCaseLabel throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(caseKeyword)
        if success
            lexer.advance()

        if itemCaseLabel == null
            itemCaseLabel = ItemCaseLabel(Position(start), lexer.getPosition())
        let start: Position = lexer.getPreviousPosition()
        let pattern: Pattern = parsePattern() catch _(error) {
            throw (error)
        }

        if itemCaseLabel == null
            itemCaseLabel = ItemCaseLabel(Position(start), lexer.getPosition())

        itemCaseLabel.pattern = node
        let start: Position = lexer.getPreviousPosition()
        let additionalPatterns: [CaseItem] = parseCaseItemList() catch _(error) {
             null
        }

        if itemCaseLabel == null
            itemCaseLabel = ItemCaseLabel(Position(start), lexer.getPosition())

        itemCaseLabel.additionalPatterns = node
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(colon)
        if success
            lexer.advance()

        if itemCaseLabel == null
            itemCaseLabel = ItemCaseLabel(Position(start), lexer.getPosition())

        return itemCaseLabel
    }

    function parseDefaultCaseLabel() -> DefaultCaseLabel throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(defaultKeyword)
        if success
            lexer.advance()

        if defaultCaseLabel == null
            defaultCaseLabel = DefaultCaseLabel(Position(start), lexer.getPosition())
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(colon)
        if success
            lexer.advance()

        if defaultCaseLabel == null
            defaultCaseLabel = DefaultCaseLabel(Position(start), lexer.getPosition())

        return defaultCaseLabel
    }

    function parseCaseItemList() -> [CaseItem] throws ParserError {
        mutable caseItem: [CaseItem]? = [CaseItem]()
        while true
            caseItem.push(parseCaseItem() catch _ break)
        return caseItem
    }

    function parseCaseItem() -> CaseItem throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(comma)
        if success
            lexer.advance()

        if caseItem == null
            caseItem = CaseItem(Position(start), lexer.getPosition())
        let start: Position = lexer.getPreviousPosition()
        let pattern: Pattern = parsePattern() catch _(error) {
            throw (error)
        }

        if caseItem == null
            caseItem = CaseItem(Position(start), lexer.getPosition())

        caseItem.pattern = node

        return caseItem
    }

    function parsePattern() -> Pattern throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: WildcardPattern = parseWildcardPattern() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: IdentifierPattern = parseIdentifierPattern() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: TuplePattern = parseTuplePattern() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: ExpressionPattern = parseExpressionPattern() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(Position(start), errors)
    }

    function parseWildcardPattern() -> WildcardPattern throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(underscore)
        if success
            lexer.advance()

        if wildcardPattern == null
            wildcardPattern = WildcardPattern(Position(start), lexer.getPosition())

        return wildcardPattern
    }

    function parseIdentifierPattern() -> IdentifierPattern throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let identifier: String? = lexer.parseIdentifier()
        if (identifier != null) && (identifier is Identifier)
            lexer.advance()

        if identifierPattern == null
            identifierPattern = IdentifierPattern(Position(start), lexer.getPosition())

        identifierPattern.identifier = identifier
        let start: Position = lexer.getPreviousPosition()
        let annotationForType: TypeAnnotation = parseTypeAnnotation() catch _(error) {
             null
        }

        if identifierPattern == null
            identifierPattern = IdentifierPattern(Position(start), lexer.getPosition())

        identifierPattern.annotationForType = node

        return identifierPattern
    }

    function parseTuplePattern() -> TuplePattern throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(leftParen)
        if success
            lexer.advance()

        if tuplePattern == null
            tuplePattern = TuplePattern(Position(start), lexer.getPosition())
        let start: Position = lexer.getPreviousPosition()
        let elements: [TuplePatternElement] = parseTuplePatternElementList() catch _(error) {
            throw (error)
        }

        if tuplePattern == null
            tuplePattern = TuplePattern(Position(start), lexer.getPosition())

        tuplePattern.elements = node
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(rightParen)
        if success
            lexer.advance()

        if tuplePattern == null
            tuplePattern = TuplePattern(Position(start), lexer.getPosition())

        return tuplePattern
    }

    function parseExpressionPattern() -> ExpressionPattern throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let expression: Expression = parseExpression() catch _(error) {
            throw (error)
        }

        if expressionPattern == null
            expressionPattern = ExpressionPattern(Position(start), lexer.getPosition())

        expressionPattern.expression = node

        return expressionPattern
    }

    function parseTuplePatternElementList() -> [TuplePatternElement] throws ParserError {
        mutable tuplePatternElement: [TuplePatternElement]? = [TuplePatternElement]()
        while true
            tuplePatternElement.push(parseTuplePatternElement() catch _ break)
        return tuplePatternElement
    }

    function parseTuplePatternElement() -> TuplePatternElement throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let pattern: Pattern = parsePattern() catch _(error) {
            throw (error)
        }

        if tuplePatternElement == null
            tuplePatternElement = TuplePatternElement(Position(start), lexer.getPosition())

        tuplePatternElement.pattern = node
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(comma)
        if success
            lexer.advance()

        if tuplePatternElement == null
            tuplePatternElement = TuplePatternElement(Position(start), lexer.getPosition())

        return tuplePatternElement
    }

    function parseCaseContent() -> CaseContent throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: BlockCaseContent = parseBlockCaseContent() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: EmptyCaseContent = parseEmptyCaseContent() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(Position(start), errors)
    }

    function parseBlockCaseContent() -> BlockCaseContent throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let statements: [TerminatedStatement] = parseTerminatedStatementList() catch _(error) {
            throw (error)
        }

        if blockCaseContent == null
            blockCaseContent = BlockCaseContent(Position(start), lexer.getPosition())

        blockCaseContent.statements = node

        return blockCaseContent
    }

    function parseEmptyCaseContent() -> EmptyCaseContent throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(semicolon)
        if success
            lexer.advance()

        if emptyCaseContent == null
            emptyCaseContent = EmptyCaseContent(Position(start), lexer.getPosition())

        return emptyCaseContent
    }

    function parseCommonSuperMember() -> CommonSuperMember throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: SuperInit = parseSuperInit() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: SuperMember = parseSuperMember() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(Position(start), errors)
    }

    function parseSuperInit() -> SuperInit throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parseKeyword(initKeyword)
        if success
            lexer.advance()

        if superInit == null
            superInit = SuperInit(Position(start), lexer.getPosition())

        return superInit
    }

    function parseSuperMember() -> SuperMember throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let name: String? = lexer.parseIdentifier()
        if (name != null) && (name is Identifier)
            lexer.advance()

        if superMember == null
            superMember = SuperMember(Position(start), lexer.getPosition())

        superMember.name = name

        return superMember
    }

    function parseType() -> Type throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: ArrayType = parseArrayType() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        {
            let node: TypeIdentifier = parseTypeIdentifier() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(Position(start), errors)
    }

    function parseTypeIdentifier() -> TypeIdentifier throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let name: String? = lexer.parseIdentifier()
        if (name != null) && (name is Identifier)
            lexer.advance()

        if typeIdentifier == null
            typeIdentifier = TypeIdentifier(Position(start), lexer.getPosition())

        typeIdentifier.name = name
        let start: Position = lexer.getPreviousPosition()
        let subType: SubtypeIdentifier = parseSubtypeIdentifier() catch _(error) {
             null
        }

        if typeIdentifier == null
            typeIdentifier = TypeIdentifier(Position(start), lexer.getPosition())

        typeIdentifier.subType = node
        let start: Position = lexer.getPreviousPosition()
        let postfixes: [TypePostfix] = parseTypePostfixList() catch _(error) {
             null
        }

        if typeIdentifier == null
            typeIdentifier = TypeIdentifier(Position(start), lexer.getPosition())

        typeIdentifier.postfixes = node

        return typeIdentifier
    }

    function parseArrayType() -> ArrayType throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(leftBracket)
        if success
            lexer.advance()

        if arrayType == null
            arrayType = ArrayType(Position(start), lexer.getPosition())
        let start: Position = lexer.getPreviousPosition()
        let elementType: Type = parseType() catch _(error) {
            throw (error)
        }

        if arrayType == null
            arrayType = ArrayType(Position(start), lexer.getPosition())

        arrayType.elementType = node
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(rightBracket)
        if success
            lexer.advance()

        if arrayType == null
            arrayType = ArrayType(Position(start), lexer.getPosition())
        let start: Position = lexer.getPreviousPosition()
        let postfixes: [TypePostfix] = parseTypePostfixList() catch _(error) {
             null
        }

        if arrayType == null
            arrayType = ArrayType(Position(start), lexer.getPosition())

        arrayType.postfixes = node

        return arrayType
    }

    function parseTypeAnnotation() -> TypeAnnotation throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(colon)
        if success
            lexer.advance()

        if typeAnnotation == null
            typeAnnotation = TypeAnnotation(Position(start), lexer.getPosition())
        let start: Position = lexer.getPreviousPosition()
        let annotationForType: Type = parseType() catch _(error) {
            throw (error)
        }

        if typeAnnotation == null
            typeAnnotation = TypeAnnotation(Position(start), lexer.getPosition())

        typeAnnotation.annotationForType = node

        return typeAnnotation
    }

    function parseSubtypeIdentifier() -> SubtypeIdentifier throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(dot)
        if success
            lexer.advance()

        if subtypeIdentifier == null
            subtypeIdentifier = SubtypeIdentifier(Position(start), lexer.getPosition())
        let start: Position = lexer.getPreviousPosition()
        let typeIdentifier: TypeIdentifier = parseTypeIdentifier() catch _(error) {
            throw (error)
        }

        if subtypeIdentifier == null
            subtypeIdentifier = SubtypeIdentifier(Position(start), lexer.getPosition())

        subtypeIdentifier.typeIdentifier = node

        return subtypeIdentifier
    }

    function parseTypePostfixList() -> [TypePostfix] throws ParserError {
        mutable typePostfix: [TypePostfix]? = [TypePostfix]()
        while true
            typePostfix.push(parseTypePostfix() catch _ break)
        return typePostfix
    }

    function parseTypePostfix() -> TypePostfix throws ParserError {
        let errors: [ParserError] = [ParserError]()
        let start: Position = lexer.getPreviousPosition()

        {
            let node: OptionalType = parseOptionalType() catch _(error) {
                errors.push(error)
                break
            }

            return node
        }

        throw ParserError.UnableToParse(Position(start), errors)
    }

    function parseOptionalType() -> OptionalType throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(questionMark)
        if success
            lexer.advance()

        if optionalType == null
            optionalType = OptionalType(Position(start), lexer.getPosition())

        return optionalType
    }

    function parseTypeInheritanceClause() -> TypeInheritanceClause throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(colon)
        if success
            lexer.advance()

        if typeInheritanceClause == null
            typeInheritanceClause = TypeInheritanceClause(Position(start), lexer.getPosition())
        let start: Position = lexer.getPreviousPosition()
        let inheritances: [Inheritance] = parseInheritanceList() catch _(error) {
             null
        }

        if typeInheritanceClause == null
            typeInheritanceClause = TypeInheritanceClause(Position(start), lexer.getPosition())

        typeInheritanceClause.inheritances = node

        return typeInheritanceClause
    }

    function parseInheritanceList() -> [Inheritance] throws ParserError {
        mutable inheritance: [Inheritance]? = [Inheritance]()
        while true
            inheritance.push(parseInheritance() catch _ break)
        return inheritance
    }

    function parseInheritance() -> Inheritance throws ParserError {
        let start: Position = lexer.getPreviousPosition()
        let typeIdentifier: TypeIdentifier = parseTypeIdentifier() catch _(error) {
            throw (error)
        }

        if inheritance == null
            inheritance = Inheritance(Position(start), lexer.getPosition())

        inheritance.typeIdentifier = node
        let start: Position = lexer.getPreviousPosition()
        let success: bool = lexer.parsePunctuation(comma)
        if success
            lexer.advance()

        if inheritance == null
            inheritance = Inheritance(Position(start), lexer.getPosition())

        return inheritance
    }

    function isAtEnd() -> bool {
        lexer.isAtEnd()
    }

    function isIdentifier(id: String) -> bool {
        if id.equals(useKeyword)
            return false

        if id.equals(classKeyword)
            return false

        if id.equals(functionKeyword)
            return false

        if id.equals(ifKeyword)
            return false

        if id.equals(elseKeyword)
            return false

        if id.equals(switchKeyword)
            return false

        if id.equals(caseKeyword)
            return false

        if id.equals(defaultKeyword)
            return false

        if id.equals(catchKeyword)
            return false

        if id.equals(forKeyword)
            return false

        if id.equals(inKeyword)
            return false

        if id.equals(whileKeyword)
            return false

        if id.equals(repeatKeyword)
            return false

        if id.equals(returnKeyword)
            return false

        if id.equals(throwKeyword)
            return false

        if id.equals(breakKeyword)
            return false

        if id.equals(throwsKeyword)
            return false

        if id.equals(existingKeyword)
            return false

        if id.equals(overrideKeyword)
            return false

        if id.equals(staticKeyword)
            return false

        if id.equals(letKeyword)
            return false

        if id.equals(varKeyword)
            return false

        if id.equals(mutableKeyword)
            return false

        if id.equals(isKeyword)
            return false

        if id.equals(asKeyword)
            return false

        if id.equals(initKeyword)
            return false

        if id.equals(enumKeyword)
            return false

        if id.equals(superKeyword)
            return false

        if id.equals(thisKeyword)
            return false

        if id.equals(nullKeyword)
            return false

        true
    }

    mutable lexer: Lexer
    let fileName: String

    let useKeyword: String = "use"
    let classKeyword: String = "class"
    let functionKeyword: String = "function"
    let ifKeyword: String = "if"
    let elseKeyword: String = "else"
    let switchKeyword: String = "switch"
    let caseKeyword: String = "case"
    let defaultKeyword: String = "default"
    let catchKeyword: String = "catch"
    let forKeyword: String = "for"
    let inKeyword: String = "in"
    let whileKeyword: String = "while"
    let repeatKeyword: String = "repeat"
    let returnKeyword: String = "return"
    let throwKeyword: String = "throw"
    let breakKeyword: String = "break"
    let throwsKeyword: String = "throws"
    let existingKeyword: String = "existing"
    let overrideKeyword: String = "override"
    let staticKeyword: String = "static"
    let letKeyword: String = "let"
    let varKeyword: String = "var"
    let mutableKeyword: String = "mutable"
    let isKeyword: String = "is"
    let asKeyword: String = "as"
    let initKeyword: String = "init"
    let enumKeyword: String = "enum"
    let superKeyword: String = "super"
    let thisKeyword: String = "this"
    let nullKeyword: String = "null"
    let semicolon: String = ";"
    let equal: String = "="
    let leftAngular: String = "<"
    let rightAngular: String = ">"
    let comma: String = ","
    let leftParen: String = "("
    let rightParen: String = ")"
    let leftCurly: String = "{"
    let rightCurly: String = "}"
    let leftBracket: String = "["
    let rightBracket: String = "]"
    let colon: String = ":"
    let dot: String = "."
    let questionMark: String = "?"
    let underscore: String = "_"
    let evaluatesTo: String = "->"
}
