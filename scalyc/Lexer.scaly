class Position {
    init(line: unsigned, column: unsigned) {
        this.line = line
        this.column = column
    }

    init(position: Position) {
        this.line = position.line
        this.column = position.column
    }

    let line: unsigned
    let column: unsigned
}

class Token {
}

class EofToken : Token {
}

class InvalidToken : Token {
}

class Identifier : Token {
    init(name: String) {
        this.name = name
    }
    let name: String
}

class Literal : Token {
}

class StringLiteral : Literal {
    init(theString: String) {
        string = theString
    }
    let string: String
}

class CharacterLiteral : Literal {
    init(theString: String) {
        value = theString
    }
    let value: String
}

class NumericLiteral : Literal {
    init(theValue: String) {
        value = theValue
    }
    let value: String
}

class Punctuation : Token {
    init(theSign: String) {
        sign = theSign
    }
    let sign: String
}

class Operator : Token {
    let operation: String
}

class PrefixOperator : Operator {
    init(theOperation: String) {
        operation = theOperation
    }
}

class BinaryOperator : Operator {
    init(theOperation: String) {
        operation = theOperation
    }
}

class PostfixOperator : Operator {
    init(theOperation: String) {
        operation = theOperation
    }
}

class Lexer {

    mutable token: Token?
    mutable whitespaceSkipped: bool
    let text: String
    mutable position: unsigned
    let end: unsigned
    mutable previousLine: unsigned
    mutable previousColumn: unsigned
    mutable line: unsigned
    mutable column: unsigned
    
    init(theText: String) {
        token = new InvalidToken()
        whitespaceSkipped = true
        text = theText
        end = text.getLength()
        position = 0
        previousLine = 1
        previousColumn = 0
        line = 1
        column = 0
        advance()
    }

    function advance() {
        skipWhitespace()
        previousLine = line
        previousColumn = column

        if position == end {
            token = new EofToken()
            return
        }
        
        let c: character = text.charAt(position)
        
        if ((c >= 'a') && (c <= 'z')) || ((c >= 'A') && (c <= 'Z')) {
            token = scanIdentifier()
            return
        }
        
        if (c >= '0') && (c <= '9') {
            token = scanNumericLiteral()
            return
        }

        switch c {
            case '\"':
                token = scanStringLiteral()

            case '\'':
                token = scanCharacterLiteral()

            case '_', '(', ')', '{', '}', '[', ']', ',', ':', ';', '@', '#', '`': {
                token = new Punctuation(new String(text.charAt(position)))
                position++ column++
            }

            case '/', '+', '*', '%', '&', '|', '^', '~':
                token = scanOperator(false)
            
            case '<', '>': {
                position++ column++
                if position == end {
                    token = new InvalidToken()
                }
                else {
                    switch text.charAt(position) {
                        case '/', '=', '+', '!','*', '%', '&', '|', '^', '~', '.', ' ', '\t', '\r', '\n': {
                            position-- column--
                            token = scanOperator(true)
                        }
                        default:
                            token = new Punctuation(new String(c))
                    }
                }
            }

            case '.': {
                position++ column++
                if position == end {
                    token = new InvalidToken()
                }
                else {
                    if text.charAt(position) == '.' {
                        position-- column--
                        token = scanOperator(true)
                    }
                    else {
                        token = new Punctuation(new String('.'))
                    }
                }
            }
            
            case '-': {
                position++ column++
                if position == end {
                    token = new InvalidToken()
                }
                else {
                    if text.charAt(position) != '>' {
                        position-- column--
                        token = scanOperator(true)
                    }
                    else {
                        token = new Punctuation(new String("->"))
                        position++ column++
                    }
                }
            }

            case '!': {
                position++ column++
                if position == end {
                    token = new PostfixOperator(new String("!"))
                }
                else {
                    switch text.charAt(position) {
                        case '/', '=', '+', '!', '*', '%', '&', '|', '^', '~' , '.', ' ', '\t', '\r', '\n': {
                            position-- column--
                            token = scanOperator(true)
                        }

                        default: {
                            if whitespaceSkipped || ((token != null) && (token is Punctuation)) {
                                position-- column--
                                token = scanOperator(true)
                            }
                            else {
                                token = new Punctuation(new String("!"))
                            }
                        }
                    } 
                }
            }

            case '?': {
                position++ column++
                if position == end {
                    token = new PostfixOperator(new String("?"))
                }
                else {
                    switch text.charAt(position) {
                        case '/', '=', '+', '!', '*', '%', '&', '|', '^', '~': {
                            position-- column--
                            token = scanOperator(true)
                        }
                        default: {
                            if whitespaceSkipped {
                                position-- column--
                                token = scanOperator(true)
                            }
                            else {
                                token = new Punctuation(new String("?"))
                            }
                        }
                    } 
                }
            }

            case '=': {
                position++ column++
                if position == end {
                    token = new InvalidToken()
                }
                else {
                    switch text.charAt(position) {
                        case '/', '=', '+', '!', '*', '%', '&', '|', '^', '~': {
                            position-- column--
                            token = scanOperator(true)
                        }
                        default:
                            token = new Punctuation(new String("="))
                    }
                }
            }
 
            default:
                token = new InvalidToken()
        }
    }

    function scanIdentifier(): Identifier {
        mutable name: VarString = new VarString(text.charAt(position))

        repeat {
            position++ column++
            
            if position == end
                return Identifier(new String(name))
            
            let c: character = text.charAt(position)
            if  ((c >= 'a') && (c <= 'z')) || 
                ((c >= 'A') && (c <= 'Z')) || 
                ((c >= '0') && (c <= '9')) || 
                 (c == '_')
                name.append(text.charAt(position))
            else
                return Identifier(new String(name))
        }            
        while true
    }

    function scanOperator(includeDots: bool): Operator {
        mutable whitespaceSkippedBefore: bool = whitespaceSkipped

        if !whitespaceSkippedBefore {
            if token is Punctuation {
                let sign: String = (token as Punctuation).sign
                if sign.equals("(") || sign.equals("[") || sign.equals("{") || sign.equals(",") || sign.equals(";") || sign.equals(":")
                    whitespaceSkippedBefore = true
                else
                    whitespaceSkippedBefore = false
            }
        }
        
        mutable operation: VarString = new VarString(text.charAt(position))

        repeat {
            position++ column++
            if position == end {
                if whitespaceSkippedBefore
                    return BinaryOperator(new String(operation))
                else
                    return PostfixOperator(new String(operation))
            }

            if includeDots && (text.charAt(position) == '.') {
                operation.append(text.charAt(position))
                continue
            }
            
            switch text.charAt(position) {
                case '/', '=', '-', '+', '!', '*', '%', '<', '&', '|', '^', '~':
                    operation.append(text.charAt(position))

                default: {
                    let lastPosition: unsigned = position
                    let lastLine: unsigned = line
                    let lastColumn: unsigned = column
                    skipWhitespace()
                    position = lastPosition
                    line = lastLine
                    column = lastColumn
                    mutable whitespaceSkippedAfter: bool = whitespaceSkipped

                    if !whitespaceSkippedAfter {
                        switch text.charAt(position) {
                            case ')', ']', '}', ',', ';', ':', '.':
                                whitespaceSkippedAfter = true
                            default:
                                whitespaceSkippedAfter = false
                        }
                    }

                    if (whitespaceSkippedBefore &&  whitespaceSkippedAfter) || 
                      (!whitespaceSkippedBefore && !whitespaceSkippedAfter)
                        return BinaryOperator(new String(operation))
                        
                    if (!whitespaceSkippedBefore && whitespaceSkippedAfter)
                        return PostfixOperator(new String(operation))
                        
                    if (whitespaceSkippedBefore && !whitespaceSkippedAfter)
                        return PrefixOperator(new String(operation))
                }
            }
        } while true
    }

    function scanStringLiteral(): Token {
        mutable value: VarString = new VarString("")

        repeat {
            position++ column++
            if position == end
                return InvalidToken()

            switch text.charAt(position) {
                case '\"': {
                    position++ column++
                    return StringLiteral(new String(value))
                }
                case '\\': {
                    position++ column++
                    switch text.charAt(position) {
                        case '\"', '\\', '\'': {
                            value.append('\\');
                            value.append(text.charAt(position))
                        }
                        case 'n': value.append("\\n")
                        case 'r': value.append("\\r")
                        case 't': value.append("\\t")
                        case '0': value.append("\\0")
                        default: return InvalidToken()
                    }
                }
                default:
                    value.append(text.charAt(position))
            }
        } while true
    }

    function scanCharacterLiteral(): Token {
        mutable value: VarString = new VarString("")
        repeat {
            position++ column++
            if position == end
                return InvalidToken()

            switch text.charAt(position) {
                case '\'': {
                    position++ column++
                    return CharacterLiteral(new String(value))
                }
                case '\\': {
                    position++ column++
                    switch text.charAt(position) {
                        case '\"', '\\', '\'': value.append(text.charAt(position))
                        case 'n': value.append('\n')
                        case 'r': value.append('\r')
                        case 't': value.append('\t')
                        case '0': value.append('\0')
                        default: return InvalidToken()
                    }
                }
                default: {
                    value.append(text.charAt(position))
                }
            }
        }
        while true
    }

    function scanNumericLiteral(): NumericLiteral {    
        mutable value: VarString = new VarString(text.charAt(position))

        repeat {
            position++ column++
            
            if position == end
                return NumericLiteral(new String(value))
            
            let c: character = text.charAt(position)
            if (c >= '0') && (c <= '9')
                value.append(text.charAt(position))
            else
                return NumericLiteral(new String(value))
        } while true
    }

    function skipWhitespace(): bool {
        whitespaceSkipped = false
        repeat {
            if position == end
                return true

            switch text.charAt(position) {
                case ' ': {
                    whitespaceSkipped = true
                    position++ column++
                    continue
                }
                case '\t': {
                    whitespaceSkipped = true
                    position++ column += 4
                    continue
                }
                case '\r': {
                    whitespaceSkipped = true
                    position++
                    continue
                }
                case '\n': {
                    whitespaceSkipped = true
                    position++ column = 1 line++
                    continue
                }
                case '/': {
                    position++ column++

                    if position == end
                        return whitespaceSkipped
                        
                    if text.charAt(position) == '/' { 
                        whitespaceSkipped = true
                        handleSingleLineComment()
                    }
                    else { 
                        if text.charAt(position) == '*' { 
                            whitespaceSkipped = true
                            handleMultiLineComment()
                        }
                        else
                            return whitespaceSkipped
                    }
                }
                default:
                    return whitespaceSkipped
            }
        } 
        while true
    }
    
    function handleSingleLineComment() {
        repeat {
            if position == end
                return;
                
            switch text.charAt(position) {
                case '\t': {
                    whitespaceSkipped = true
                    position++ column += 4
                    continue
                }
                case '\r': {
                    whitespaceSkipped = true
                    position++
                    continue
                }
                case '\n': {
                    whitespaceSkipped = true
                    position++ column = 1 line++
                    return
                }
                default: {
                    position++ column++
                    continue
                }
            }
        }
        while true
    }

    function handleMultiLineComment() {
        repeat {
            if position == end
                return;
                
            switch text.charAt(position) {
                case '/': {
                    position++ column++
                    if position == end
                        return
                    else {
                        if text.charAt(position) == '*'
                            handleMultiLineComment()
                        else
                            return
                    }
                }
                case '*': {
                    position++ column++

                    if position == end
                        return
                    else {
                        if text.charAt(position) == '/' { 
                            position++ column++
                            return
                        }
                    }
                }
                case '\t': {
                    whitespaceSkipped = true
                    position++ column += 4
                    continue
                }
                case '\r': {
                    whitespaceSkipped = true
                    position++
                    continue
                }
                case '\n': {
                    whitespaceSkipped = true
                    position++ column = 1 line++
                    continue
                }
                default: {
                    position++ column++
                    continue
                }
            }
        }
        while true
    }

    function parseKeyword(fixedString: String): bool {
        if !(token is Identifier)
            return false

        let identifier: Identifier = token as Identifier
        return identifier.name.equals(fixedString)
    }

    function parseIdentifier(): String? {
        if !(token is Identifier)
            return null

        let identifier: Identifier = token as Identifier
        return String(identifier.name)
    }

    function parsePunctuation(fixedString: String): bool {
        if !(token is Punctuation)
            return false

        let punctuation: Punctuation = token as Punctuation
        return punctuation.sign.equals(fixedString)
    }

    function parseOperator(): String? {
        if !(token is Operator)
            return null

        let op: Operator = token as Operator
        return String(op.operation)
    }

    function parseLiteral(): Literal? {
        if !(token is Literal)
            return null

        if token is StringLiteral {
            let stringLiteral: StringLiteral = token as StringLiteral
            return StringLiteral(new String(stringLiteral.string))
        }

        if token is CharacterLiteral {
            let characterLiteral: CharacterLiteral = token as CharacterLiteral
            return CharacterLiteral(new String(characterLiteral.value))
        }

        if token is NumericLiteral {
            let numericLiteral: NumericLiteral = token as NumericLiteral
            return NumericLiteral(new String(numericLiteral.value))
        }

        return null
    }


    function parsePrefixOperator(): String? {
        if !(token is PrefixOperator)
            return null

        let op: Operator = token as Operator
        return String(op.operation)
    }

    function parseBinaryOperator(): String? {
        if !(token is BinaryOperator) {
            if (token is Punctuation) && (((token as Punctuation).sign.equals("<")) || ((token as Punctuation).sign.equals(">"))) {
                let op: Operator = token as Operator
                return String(op.operation)
            }

            return null
        }

        let op: Operator = token as Operator
        return String(op.operation)
    }


    function parsePostfixOperator(): String? {
        if !(token is PostfixOperator)
            return null

        let op: Operator = token as Operator
        return String(op.operation)
    }

    function isAtEnd(): bool {
        return position == end
    }

    function getPosition(): Position {
        return Position(line, column)
    }

    function getPreviousPosition(): Position {
        return Position(previousLine, previousColumn)
    }
}
