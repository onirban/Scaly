class Position {
    init(line: unsigned, column: unsigned) {
        this.line = line
        this.column = column
    }
    let line: unsigned
    let column: unsigned
}

class Token {
}

class EofToken : Token {
}

class InvalidToken : Token {
}

class Identifier : Token {
    init(name: String) {
        this.name = name
    }
    let name: String
}

class Literal : Token {
}

class StringLiteral : Literal {
    init(theString: String) {
        string = theString
    }
    let string: String
}

class CharacterLiteral : Literal {
    init(theString: String) {
        value = theString
    }
    let value: String
}

class NumericLiteral : Literal {
    init(theValue: String) {
        value = theValue
    }
    let value: String
}

class Punctuation : Token {
    init(theSign: String) {
        sign = theSign
    }
    let sign: String
}

class Operator : Token {
    let operation: String
}

class PrefixOperator : Operator {
    init(theOperation: String) {
        operation = theOperation;
    }
}

class BinaryOperator : Operator {
    init(theOperation: String) {
        operation = theOperation;
    }
}

class PostfixOperator : Operator {
    init(theOperation: String) {
        operation = theOperation;
    }
}

class Lexer {

    mutable token: Token?
    mutable whitespaceSkipped: bool
    let text: String
    mutable position: unsigned
    let end: unsigned
    mutable previousLine: unsigned
    mutable previousColumn: unsigned
    mutable line: unsigned
    mutable column: unsigned
    
    init(theText: String) {
        token = InvalidToken();
        whitespaceSkipped = true
        text = theText
        end = text.getLength()
        position = 0
        previousLine = 1
        previousColumn = 0
        line = 1
        column = 0
        advance()
    }

    function advance() {
        skipWhitespace()
        previousLine = line
        previousColumn = column

        if position == end {
            token = EofToken()
            return
        }
        
        let c: character = text[position]
        
        if ((c >= 'a') && (c <= 'z')) || ((c >= 'A') && (c <= 'Z')) {
            token = scanIdentifier()
            return
        }
        
        if (c >= '0') && (c <= '9') {
            token = scanNumericLiteral()
            return
        }

        switch c {
            case '\"':
                token = scanStringLiteral()

            case '\'':
                token = scanCharacterLiteral()

            case '_', '(', ')', '{', '}', '[', ']', ',', ':', ';', '@', '#', '`': {
                token = Punctuation(String(text[position]))
                position++ column++
            }

            case '/', '+', '*', '%', '&', '|', '^', '~':
                token = scanOperator(false)
            
            case '<', '>': {
                position++ column++
                if position == end {
                    token = InvalidToken()
                }
                else {
                    switch text[position] {
                        case '/', '=', '+', '!','*', '%', '&', '|', '^', '~', '.', ' ', '\t', '\r', '\n': {
                            position-- column--
                            token = scanOperator(true)
                        }
                        default:
                            token = Punctuation(String(c))
                    }
                }
            }

            case '.': {
                position++ column++
                if position == end {
                    token = InvalidToken()
                }
                else {
                    if text[position] == '.' {
                        position-- column--
                        token = scanOperator(true)
                    }
                    else {
                        token = Punctuation(String('.'))
                    }
                }
            }
            
            case '-': {
                position++ column++
                if position == end {
                    token = InvalidToken()
                }
                else {
                    if text[position] != '>' {
                        position-- column--
                        token = scanOperator(true)
                    }
                    else {
                        token = Punctuation(String("->"))
                        position++ column++
                    }
                }
            }

            case '!': {
                position++ column++
                if position == end {
                    token = PostfixOperator(String("!"))
                }
                else {
                    switch text[position] {
                        case '/', '=', '+', '!', '*', '%', '&', '|', '^', '~' , '.', ' ', '\t', '\r', '\n': {
                            position-- column--
                            token = scanOperator(true)
                        }

                        default: {
                            if whitespaceSkipped || ((token != null) && (token is Punctuation)) {
                                position-- column--
                                token = scanOperator(true)
                            }
                            else {
                                token = Punctuation(String("!"))
                            }
                        }
                    } 
                }
            }

            case '?': {
                position++ column++
                if position == end {
                    token = PostfixOperator(String("?"))
                }
                else {
                    switch text[position] {
                        case '/', '=', '+', '!', '*', '%', '&', '|', '^', '~': {
                            position-- column--
                            token = scanOperator(true)
                        }
                        default: {
                            if whitespaceSkipped {
                                position-- column--
                                token = scanOperator(true)
                            }
                            else {
                                token = Punctuation(String("?"))
                            }
                        }
                    } 
                }
            }

            case '=': {
                position++ column++
                if position == end {
                    token = InvalidToken()
                }
                else {
                    switch text[position] {
                        case '/', '=', '+', '!', '*', '%', '&', '|', '^', '~': {
                            position-- column--
                            token = scanOperator(true)
                        }
                        default:
                            token = Punctuation(String("="))
                    }
                }
            }
 
            default:
                token = InvalidToken()
        }
    }

    function scanIdentifier() -> Identifier {
        mutable name: VarString = VarString(text[position])

        repeat {
            position++ column++
            
            if position == end
                return Identifier(String(name))
            
            let c: character = text[position]
            if  ((c >= 'a') && (c <= 'z')) || 
                ((c >= 'A') && (c <= 'Z')) || 
                ((c >= '0') && (c <= '9')) || 
                 (c == '_')
                name.append(text[position])
            else
                return Identifier(String(name))
        }            
        while true
    }

    function scanOperator(includeDots: bool) -> Operator {
        mutable whitespaceSkippedBefore: bool = whitespaceSkipped

        if !whitespaceSkippedBefore {
            if token is Punctuation {
                let sign: String = (token as Punctuation).sign;
                if sign.equals("(") || sign.equals("[") || sign.equals("{") || sign.equals(",") || sign.equals(";") || sign.equals(":")
                    whitespaceSkippedBefore = true
                else
                    whitespaceSkippedBefore = false
            }
        }
        
        mutable operation: VarString = VarString(text[position])

        repeat {
            position++ column++
            if position == end {
                if whitespaceSkippedBefore
                    return BinaryOperator(String(operation))
                else
                    return PostfixOperator(String(operation))
            }

            if includeDots && (text[position] == '.') {
                operation.append(text[position]);
                continue;
            }
            
            switch text[position] {
                case '/', '=', '-', '+', '!', '*', '%', '<', '&', '|', '^', '~':
                    operation.append(text[position])

                default: {
                    let lastPosition: unsigned = position
                    let lastLine: unsigned = line
                    let lastColumn: unsigned = position
                    skipWhitespace()
                    position = lastPosition
                    line = lastLine
                    column = lastColumn
                    mutable whitespaceSkippedAfter: bool = whitespaceSkipped

                    if !whitespaceSkippedAfter
                        switch text[position]
                            case ')', ']', '}', ',', ';', ':', '.':
                                whitespaceSkippedAfter = true
                            default:
                                whitespaceSkippedAfter = false

                    if (whitespaceSkippedBefore &&  whitespaceSkippedAfter) || 
                      (!whitespaceSkippedBefore && !whitespaceSkippedAfter)
                        return BinaryOperator(operation)
                        
                    if (!whitespaceSkippedBefore && whitespaceSkippedAfter)
                        return PostfixOperator(operation)
                        
                    if (whitespaceSkippedBefore && !whitespaceSkippedAfter)
                        return PrefixOperator(operation)
                }
            }
        } while true
    }

    function scanNumericLiteral() -> NumericLiteral {    
        mutable value: String = String(text[position])

        do {
            position++ column++
            
            if position == end
                return NumericLiteral(value)
            
            let c: character = text[position]
            if (c >= '0') && (c <= '9')
                value.append(text[position])
            else
                return NumericLiteral(value)
        } while true
    }

    function scanStringLiteral() -> Token {
        mutable value: String = String("")

        do {
            position++ column++
            if position == end
                return InvalidToken()

            switch text[position] {
                case '\"': {
                    position++ column++
                    return StringLiteral(value)
                }
                case '\\': {
                    position++ column++
                    switch text[position]
                        case '\"', '\\': value.append(text[position])
                        case 'n': value.append('\n')
                        case 'r': value.append('\r')
                        case 't': value.append('\t')
                        case '0': value.append('\0')
                        default: return InvalidToken()
                }
                default:
                    value.append(text[position])
            }
        } while true
    }

    function scanCharacterLiteral() -> Token {
    }

    function parseKeyword(fixedString: String) -> bool {
        if !(token is Identifier)
            return false

        let identifier: Identifier = token as Identifier
        return identifier.name == fixedString
    }

    function parseIdentifier() -> String? {
        if !(token is Identifier)
            return null

        let identifier: Identifier = token as Identifier
        return String(identifier.name)
    }

    function parseLiteral() -> Literal? {
        if !(token is Literal)
            return null

        return token as Literal
    }

    function parsePunctuation(fixedString: String) -> bool {
        if !(token is Punctuation)
            return false

        let punctuation: Punctuation = token as Punctuation
        return punctuation.sign == fixedString
    }

    function parseOperator() -> String? {
        if !(token is Operator)
            return null

        let op: Operator = token as Operator
        return String(op.operation)
    }

    function parsePrefixOperator() -> String? {
        if !(token is PrefixOperator)
            return null

        let op: Operator = token as Operator
        return String(op.operation)
    }

    function parseBinaryOperator() -> String? {
        if !(token is BinaryOperator) {
            if (token is Punctuation) && ((token as Punctuation).sign == "<") {
                let op: Operator = token as Operator
                return String(op.operation)
            }

            return null
        }

        let op = token as Operator
        return String(op.operation)
    }


    function parsePostfixOperator() -> String? {
        if !(token is PostfixOperator)
            return null

        let op: Operator = token as Operator
        return String(op.operation)
    }

    function skipWhitespace() -> bool {
        whitespaceSkipped = false
        do {
            if (position == end)
                return true

            switch text[position] {
                case ' ': {
                    whitespaceSkipped = true
                    position++ column++
                    continue
                }
                case '\t': {
                    whitespaceSkipped = true
                    position++ column += 4
                    continue
                }
                case '\r': {
                    whitespaceSkipped = true
                    position++
                    continue
                }
                case '\n': {
                    whitespaceSkipped = true
                    position++ column = 1 line++
                    continue
                }
                case '/': {
                    position++ column++

                    if position == end
                        return whitespaceSkipped
                        
                    if text[position] == '/' { 
                        whitespaceSkipped = true
                        handleSingleLineComment()
                    }
                    else if text[position] == '*' { 
                        whitespaceSkipped = true
                        handleMultiLineComment()
                    }
                    else
                        return whitespaceSkipped
                }
                default:
                    return whitespaceSkipped
            }
        } 
        while true
    }

    function isAtEnd() -> bool {
        return position == end
    }

    function getPosition() -> Position {
        return Position(line, column)
    }

    function getPreviousPosition() -> Position {
        return Position(previousLine, previousColumn)
    }

    function handleSingleLineComment() {
        do {
            if position == end
                return
                
            switch text[position] {
                case '\t': {
                    whitespaceSkipped = true
                    position++ column += 4
                    continue
                }
                case '\r': {
                    whitespaceSkipped = true
                    position++
                    continue
                }
                case '\n': {
                    whitespaceSkipped = true
                    position++ column = 1 line++
                    return
                }
                default: {
                    position++ column++
                    continue
                }
            }
        }
        while true
    }

    function handleMultiLineComment() {
        do {
            if position == end
                return
                
            let character: character = text[position]
            switch (character) {
                case '/': {
                    position++ column++
                    if position == end
                        return
                    else if text[position] == "*"
                        handleMultiLineComment()
                    else
                        return
                }
                case '*': {
                    position++ column++

                    if position == end
                        return
                    else if text[position] == '/' { 
                        position++ column++
                        return
                    }
                    else
                        fallthrough
                }
                case '\t': {
                    whitespaceSkipped = true
                    position++ column += 4
                    continue
                }
                case '\r': {
                    whitespaceSkipped = true
                    position++
                    continue
                }
                case '\n': {
                    whitespaceSkipped = true
                    position++ column = 1 line++
                    continue
                }
                default: {
                    position++ column++
                    continue
                }
            }
        }
        while true
    }
}
