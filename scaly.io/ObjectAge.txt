Object age
==========

In Scaly, _objects live on the stack_, either referenced by local items, or by references held by other objects, arrays, or dictionaries, which in turn live somwhere on the stack directly or indirectly (held by other objects).

If a block is left, the memory of all objects which were created in this block is recycled. Therefore, a reference must not be held by an item that outlives the object it references:

  let a: Foo
  {
      let b: Foo = Foo()
      // a = b // If b goes out of scope, a would point to recycled memory
  }

To make `b` assignable to `a`, its declaration can be moved to the outer block:

  let a: Foo
  let b: Foo
  {
      b = Foo()
      a = b
  }

The lifetime of an object is determined by the place where a reference to it is declared. The older an object, the longer it lives. Since older data live at least as long as younger data, it can never happen that references to dead data are accessible.

The age of data depends on where it is declared. Items declared in a local block are younger than items in the enclosing block. Parameters that are passed to a function are older than its local items:

  function f(a: Foo) {
      let b: Bar = Bar()
      {
          let c: Caf = Caf()
      }
  }

In this example, `a` is oldest, `b` is younger than `a`, and `c` is youngest.

A reference returned by a function is assumed to be _fresh_ by default. This means that the function creates the object (either by calling an object constructor or another function which returns a reference to a fresh object). The caller of such a function then assigns the returned reference to an item whose location determines the age of the object:

  function g() -> Foo {
      Foo(42) // Fresh object created and returned
  }
  
  function h() {
      let k: Foo = g() // The object lives here, accessible via k
  }

If a function is to return a reference to an object which is not fresh, the age of such a returned reference must be made explicit by an _age tag_ which is written after the type of the return value.

An age tag starts with a single quote (`'`) and continues with digits which form a nonnegative number. Leading zero digits are not allowed. `'0` is a valid age tag, `'42` is a valid age tag as well, whereas `'01` is not a valid age tag.

If a function without parameters returns a reference to an existing object, it would be pointless to provide a value to its age tag. Therefore, the value is omitted in this case, making the tag consist of a single quote:

  function k() -> Foo' {
     getSomeGlobalFoo()
  }

Such an _empty age tag_ denotes the age of immutable global data which is the oldest possible. (In fact, this age is the only possible for a reference to a non-fresh object to be returned by a function without parameters.)

If there are parameters from which to take the returned reference in some way, age tag numbers are used to express age relations between the parameters of a function. The higher the age tag value is, the younger is the tagged reference:

  function superiorFoo(fooOld: Foo'1, fooYoung: Foo'2) -> Foo'2 {
      if fooOld.number > fooYoung
          fooOld
      else
          fooYoung
  }

In this example, the returned refrerence can be taken from any of the two parameters, and so its age must be that of the youngest parameter.

The following example checks assignments for age validity:

  function bar(mutable foo: Foo'1, mutable bar: Bar'2) {
      bar.foo = foo // Valid because foo is declared older
      // foo.bar = bar // Invalid because bar is younger
  } 

If age tags are omitted, the age of the parameters is irrelevant:

  function baz(p: Foo, q: Foo) -> bool {
      p.number > q
  }

The age of a member is assumed to be the same as the age of the object containing it (even though the object it points to might be older). Similarly, the age of an array element is assumed to be that of the array, and the age of a dictionary key or value is assumed to be that of the dictionary.

